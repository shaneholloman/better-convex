# Better Convex ORM Testing

Comprehensive testing patterns for Better Convex ORM covering both compile-time type verification and runtime behavior testing.

## Two Testing Approaches

### Type-Only Testing (Compile-Time)
- Zero runtime cost, pure TypeScript type checking
- Verify query result types, InferSelectModel, InferInsertModel
- Follow Drizzle ORM patterns with Equal<>/Expect<>
- Test type system specifics (GenericId brands, nullable conventions)
- See [references/type-testing.md](references/type-testing.md)

### Runtime Testing (Execution)
- Test actual Convex function behavior with convex-test library
- Query/mutation operations, edge traversal, rules, scheduled functions
- In-memory mock Convex backend with Vitest
- See [references/runtime-testing.md](references/runtime-testing.md)

## Quick Decision Guide

**Use type-only tests when:**
- Verifying ORM type inference is correct
- Testing that invalid code produces type errors
- No database execution needed
- Building type safety guarantees

**Use runtime tests when:**
- Testing function logic and behavior
- Verifying edge traversal, rules, cascading deletes
- Testing scheduled functions, authentication
- Need actual query execution results

**Use both when:**
- Building new ORM features (verify types + behavior)
- Comprehensive test coverage required

## Quick Start

### Type-Only Test
```typescript
import { buildSchema, createDatabase } from 'better-convex/orm';
import type { GenericDatabaseReader } from 'convex/server';
import * as schema from './schema';
import { type Equal, Expect } from './utils';

// Mock database (type-only, never executes)
const mockDb = {} as GenericDatabaseReader<any>;
const schemaConfig = buildSchema(schema);
const db = createDatabase(mockDb, schemaConfig);

// Test query result type
{
  const result = await db.query.users.findMany({
    where: (users, { eq }) => eq(users.name, 'Alice'),
  });

  type Expected = Array<{
    _id: GenericId<'users'>;
    _creationTime: number;
    name: string;
  }>;
  Expect<Equal<typeof result, Expected>>;
}
```

### Runtime Test
```typescript
import { test, expect } from 'vitest';
import { convexTest, runCtx } from './setup.testing';
import schema from './schema';

test('insert and query user', async () => {
  const t = convexTest(schema);
  await t.run(async (baseCtx) => {
    const ctx = await runCtx(baseCtx);

    const userId = await ctx.table('users')
      .insert({ name: 'Alice', email: 'alice@example.com' });

    const user = await ctx.table('users').getX(userId);
    expect(user.name).toEqual('Alice');
  });
});
```

## Navigation

- **[Type Testing Guide](references/type-testing.md)** - Complete guide to type-only testing: patterns, Drizzle parity methodology, Better Convex type system specifics, mock database pattern
- **[Runtime Testing Guide](references/runtime-testing.md)** - Complete guide to runtime testing: convex-test setup, testing patterns for queries/mutations/edges/rules/scheduled functions

## Key Principles

### Type Testing
1. Mirror Drizzle ORM test patterns for industry-standard approach
2. Use Equal<>/Expect<> assertions (no external dependencies)
3. Test public API only, not implementation details
4. Include negative tests (@ts-expect-error for invalid code)
5. Extract shared types to fixtures/ to eliminate duplication

### Runtime Testing
1. Always use project's `convexTest` wrapper from setup.testing
2. Always wrap baseCtx with `runCtx(baseCtx)`
3. Use context injection pattern for cleaner tests
4. Use `vi.useFakeTimers()` for scheduled function tests
5. Use `ctx.skipRules` when setting up test data that violates rules

## Common Mistakes

| Mistake | Fix |
|---------|-----|
| Type test executes code | Use mock database: `{} as GenericDatabaseReader<any>` |
| _id typed as string | Use `GenericId<'tableName'>` not `string` |
| Nullable field optional in insert | Required with `\| null`, not optional with `?` |
| Using baseConvexTest directly | Use `convexTest` from setup.testing |
| Not wrapping context | Always `await runCtx(baseCtx)` |
| Missing schema import | Always pass `schema` to `convexTest()` |
| Scheduled tests fail | Use `vi.useFakeTimers()` and cleanup with `vi.useRealTimers()` |

## References

Both reference files provide exhaustive coverage:
- Type testing: Mock database pattern, Better Convex type system rules, Drizzle parity methodology, implementation phases
- Runtime testing: Complete convex-test patterns for all operations (queries, mutations, edges, rules, scheduling, HTTP)