'use client';

/**
 * Auth Mutations Factory
 *
 * Creates TanStack Query mutation option hooks from auth functions.
 */

import type { DefaultError, UseMutationOptions } from '@tanstack/react-query';

import type { AuthStore } from './auth-store';
import { useAuthStore } from './auth-store';
import { useConvexQueryClient } from './context';

type MutationOptionsHook<TData, TVariables = void> = (
  options?: Omit<
    UseMutationOptions<TData, DefaultError, TVariables>,
    'mutationFn'
  >
) => UseMutationOptions<TData, DefaultError, TVariables>;

/** Poll until token is null (max 5s) */
const waitForTokenClear = async (
  store: AuthStore,
  timeout = 5000
): Promise<void> => {
  const start = Date.now();
  while (Date.now() - start < timeout) {
    if (!store.get('token')) return;
    await new Promise((r) => setTimeout(r, 50));
  }
};

/** Poll until authenticated (token set + Convex verified) (max 5s) */
const waitForAuth = async (store: AuthStore, timeout = 5000): Promise<void> => {
  const start = Date.now();
  while (Date.now() - start < timeout) {
    if (store.get('isAuthenticated')) return;
    await new Promise((r) => setTimeout(r, 50));
  }
};

type AnyFn = (...args: any[]) => Promise<any>;

type AuthClient = {
  signOut: AnyFn;
  signIn: {
    social: AnyFn;
    email: AnyFn;
  };
  signUp: {
    email: AnyFn;
  };
};

type AuthMutationsResult<T extends AuthClient> = {
  useSignOutMutationOptions: MutationOptionsHook<
    Awaited<ReturnType<T['signOut']>>,
    // biome-ignore lint/suspicious/noConfusingVoidType: allows mutate() or mutate(options)
    Parameters<T['signOut']>[0] | void
  >;
  useSignInSocialMutationOptions: MutationOptionsHook<
    Awaited<ReturnType<T['signIn']['social']>>,
    Parameters<T['signIn']['social']>[0]
  >;
  useSignInMutationOptions: MutationOptionsHook<
    Awaited<ReturnType<T['signIn']['email']>>,
    Parameters<T['signIn']['email']>[0]
  >;
  useSignUpMutationOptions: MutationOptionsHook<
    Awaited<ReturnType<T['signUp']['email']>>,
    Parameters<T['signUp']['email']>[0]
  >;
};

/**
 * Create mutation option hooks from a better-auth client.
 *
 * @example
 * ```tsx
 * // lib/auth-client.ts
 * import { createAuthMutations } from 'better-convex/react';
 *
 * export const authClient = createAuthClient({...});
 *
 * export const {
 *   useSignOutMutationOptions,
 *   useSignInSocialMutationOptions,
 *   useSignInMutationOptions,
 *   useSignUpMutationOptions,
 * } = createAuthMutations(authClient);
 *
 * // components/header.tsx
 * const signOutMutation = useMutation(useSignOutMutationOptions({
 *   onSuccess: () => router.push('/login'),
 * }));
 * ```
 */
export function createAuthMutations<T extends AuthClient>(
  authClient: T
): AuthMutationsResult<T> {
  const useSignOutMutationOptions = ((options) => {
    const convexQueryClient = useConvexQueryClient();
    const authStoreApi = useAuthStore();

    return {
      ...options,
      mutationFn: async (args?: Parameters<T['signOut']>[0]) => {
        convexQueryClient?.unsubscribeAuthQueries();
        const res = await authClient.signOut(args);
        await waitForTokenClear(authStoreApi);
        return res;
      },
    };
  }) as AuthMutationsResult<T>['useSignOutMutationOptions'];

  const useSignInSocialMutationOptions = ((options) => {
    const authStoreApi = useAuthStore();

    return {
      ...options,
      mutationFn: async (args: Parameters<T['signIn']['social']>[0]) => {
        const res = await authClient.signIn.social(args);
        // Only wait if no error (better-auth returns { error } on failure)
        if (!res?.error) {
          await waitForAuth(authStoreApi);
        }
        return res;
      },
    };
  }) as AuthMutationsResult<T>['useSignInSocialMutationOptions'];

  const useSignInMutationOptions = ((options) => {
    const authStoreApi = useAuthStore();

    return {
      ...options,
      mutationFn: async (args: Parameters<T['signIn']['email']>[0]) => {
        const res = await authClient.signIn.email(args);
        if (!res?.error) {
          await waitForAuth(authStoreApi);
        }
        return res;
      },
    };
  }) as AuthMutationsResult<T>['useSignInMutationOptions'];

  const useSignUpMutationOptions = ((options) => {
    const authStoreApi = useAuthStore();

    return {
      ...options,
      mutationFn: async (args: Parameters<T['signUp']['email']>[0]) => {
        const res = await authClient.signUp.email(args);
        if (!res?.error) {
          await waitForAuth(authStoreApi);
        }
        return res;
      },
    };
  }) as AuthMutationsResult<T>['useSignUpMutationOptions'];

  return {
    useSignOutMutationOptions,
    useSignInSocialMutationOptions,
    useSignInMutationOptions,
    useSignUpMutationOptions,
  };
}
