import type { GenericDatabaseWriter } from 'convex/server';
import type { ColumnBuilder } from './builders/column-builder';
import type { FilterExpression } from './filter-expression';
import { findIndexForColumns, getIndexes } from './index-utils';
import {
  applyDefaults,
  enforceCheckConstraints,
  enforceForeignKeys,
  enforceUniqueIndexes,
  evaluateFilter,
  getColumnName,
  getOrmContext,
  getTableColumns,
  getTableName,
  getUniqueIndexes,
  selectReturningRow,
} from './mutation-utils';
import { QueryPromise } from './query-promise';
import { canInsertRow, evaluateUpdateDecision } from './rls/evaluator';
import type { ConvexTable } from './table';
import type {
  InsertValue,
  MutationResult,
  MutationReturning,
  ReturningSelection,
  UpdateSet,
} from './types';

export type InsertOnConflictDoNothingConfig<_TTable extends ConvexTable<any>> =
  {
    target?: ColumnBuilder<any, any, any> | ColumnBuilder<any, any, any>[];
    where?: FilterExpression<boolean>;
  };

export type InsertOnConflictDoUpdateConfig<TTable extends ConvexTable<any>> = {
  target: ColumnBuilder<any, any, any> | ColumnBuilder<any, any, any>[];
  set: UpdateSet<TTable>;
  where?: FilterExpression<boolean>;
  targetWhere?: FilterExpression<boolean>;
  setWhere?: FilterExpression<boolean>;
};

type InsertConflictConfig<TTable extends ConvexTable<any>> =
  | {
      action: 'nothing';
      config: InsertOnConflictDoNothingConfig<TTable>;
    }
  | {
      action: 'update';
      config: InsertOnConflictDoUpdateConfig<TTable>;
    };

export type ConvexInsertWithout<
  T extends ConvexInsertBuilder<any, any>,
  K extends string,
> = Omit<T, K>;

export class ConvexInsertBuilder<
  TTable extends ConvexTable<any>,
  TReturning extends MutationReturning = undefined,
> extends QueryPromise<MutationResult<TTable, TReturning>> {
  declare readonly _: {
    readonly table: TTable;
    readonly returning: TReturning;
    readonly result: MutationResult<TTable, TReturning>;
  };

  private valuesList: InsertValue<TTable>[] = [];
  private returningFields?: TReturning;
  private conflictConfig?: InsertConflictConfig<TTable>;
  private allowFullScanFlag = false;

  constructor(
    private db: GenericDatabaseWriter<any>,
    private table: TTable
  ) {
    super();
  }

  values(values: InsertValue<TTable> | InsertValue<TTable>[]): this {
    const list = Array.isArray(values) ? values : [values];
    if (list.length === 0) {
      throw new Error('values() must be called with at least one value');
    }
    this.valuesList = list;
    return this;
  }

  returning(): ConvexInsertWithout<
    ConvexInsertBuilder<TTable, true>,
    'returning'
  >;
  returning<TSelection extends ReturningSelection<TTable>>(
    fields: TSelection
  ): ConvexInsertWithout<ConvexInsertBuilder<TTable, TSelection>, 'returning'>;
  returning(
    fields?: ReturningSelection<TTable>
  ): ConvexInsertWithout<
    ConvexInsertBuilder<TTable, MutationReturning>,
    'returning'
  > {
    this.returningFields = (fields ?? true) as TReturning;
    return this as any;
  }

  allowFullScan(): this {
    this.allowFullScanFlag = true;
    return this;
  }

  onConflictDoNothing(
    config: InsertOnConflictDoNothingConfig<TTable> = {}
  ): ConvexInsertWithout<this, 'onConflictDoNothing' | 'onConflictDoUpdate'> {
    this.conflictConfig = {
      action: 'nothing',
      config,
    };
    return this as any;
  }

  onConflictDoUpdate(
    config: InsertOnConflictDoUpdateConfig<TTable>
  ): ConvexInsertWithout<this, 'onConflictDoNothing' | 'onConflictDoUpdate'> {
    if (config.where && (config.targetWhere || config.setWhere)) {
      throw new Error(
        'You cannot use both "where" and "targetWhere"/"setWhere" at the same time - "where" is deprecated, use "targetWhere" or "setWhere" instead.'
      );
    }
    this.conflictConfig = {
      action: 'update',
      config,
    };
    return this as any;
  }

  async execute(): Promise<MutationResult<TTable, TReturning>> {
    if (this.valuesList.length === 0) {
      throw new Error('values() must be called before execute()');
    }

    const results: Record<string, unknown>[] = [];
    for (const value of this.valuesList) {
      const preparedValue = applyDefaults(this.table, value as any);
      const ormContext = getOrmContext(this.db);
      const rls = ormContext?.rls;
      const tableName = getTableName(this.table);

      if (
        !canInsertRow({
          table: this.table,
          row: preparedValue as any,
          rls,
        })
      ) {
        throw new Error(
          `RLS policy violation for insert on table "${tableName}"`
        );
      }

      const conflictResult = await this.handleConflict(preparedValue);

      if (conflictResult?.status === 'skip') {
        continue;
      }

      if (conflictResult?.status === 'updated') {
        if (conflictResult.row && this.returningFields) {
          results.push(this.resolveReturningRow(conflictResult.row));
        }
        continue;
      }

      enforceCheckConstraints(this.table, preparedValue as any);
      await enforceForeignKeys(this.db, this.table, preparedValue as any, {
        changedFields: new Set(Object.keys(preparedValue as any)),
      });
      await enforceUniqueIndexes(this.db, this.table, preparedValue as any, {
        changedFields: new Set(Object.keys(preparedValue as any)),
      });
      const id = await this.db.insert(tableName, preparedValue as any);

      if (!this.returningFields) {
        continue;
      }

      const inserted = await this.db.get(id as any);
      if (inserted) {
        results.push(this.resolveReturningRow(inserted as any));
      }
    }

    if (!this.returningFields) {
      return undefined as MutationResult<TTable, TReturning>;
    }

    return results as MutationResult<TTable, TReturning>;
  }

  private resolveReturningRow(row: Record<string, unknown>) {
    if (this.returningFields === true) {
      return row;
    }
    return selectReturningRow(row, this.returningFields as any);
  }

  private async handleConflict(value: InsertValue<TTable>): Promise<
    | {
        status: 'skip';
      }
    | {
        status: 'updated';
        row?: Record<string, unknown> | null;
      }
    | undefined
  > {
    if (!this.conflictConfig) {
      return;
    }

    const { action, config } = this.conflictConfig;
    const targetColumns = Array.isArray(config.target)
      ? config.target
      : config.target
        ? [config.target]
        : [];

    const existing =
      targetColumns.length > 0
        ? await this.findConflictRow(value, targetColumns)
        : action === 'nothing'
          ? await this.findAnyUniqueConflictRow(value)
          : null;
    if (!existing) {
      return;
    }

    if (action === 'nothing') {
      if (config.where && !evaluateFilter(existing, config.where)) {
        return;
      }
      return { status: 'skip' };
    }

    const updateConfig = config as InsertOnConflictDoUpdateConfig<TTable>;

    if (
      updateConfig.targetWhere &&
      !evaluateFilter(existing, updateConfig.targetWhere)
    ) {
      return;
    }

    if (updateConfig.where && !evaluateFilter(existing, updateConfig.where)) {
      return { status: 'updated', row: null };
    }

    if (
      updateConfig.setWhere &&
      !evaluateFilter(existing, updateConfig.setWhere)
    ) {
      return { status: 'updated', row: null };
    }

    const tableName = getTableName(this.table);
    const ormContext = getOrmContext(this.db);
    const rls = ormContext?.rls;

    const onUpdateSet: Record<string, unknown> = {};
    for (const [columnName, builder] of Object.entries(
      getTableColumns(this.table)
    )) {
      if (columnName in (updateConfig.set as any)) {
        continue;
      }
      const onUpdateFn = (builder as any).config?.onUpdateFn;
      if (typeof onUpdateFn === 'function') {
        onUpdateSet[columnName] = onUpdateFn();
      }
    }

    const effectiveSet = {
      ...onUpdateSet,
      ...(updateConfig.set as any),
    };

    const updateDecision = evaluateUpdateDecision({
      table: this.table,
      existingRow: existing as any,
      updatedRow: { ...(existing as any), ...(effectiveSet as any) },
      rls,
    });

    if (!updateDecision.allowed) {
      if (updateDecision.usingAllowed && !updateDecision.withCheckAllowed) {
        throw new Error(
          `RLS policy violation for update on table "${tableName}"`
        );
      }
      return { status: 'updated', row: null };
    }

    await enforceForeignKeys(
      this.db,
      this.table,
      (() => {
        const candidate = { ...(existing as any), ...(effectiveSet as any) };
        enforceCheckConstraints(this.table, candidate);
        return candidate;
      })(),
      {
        changedFields: new Set(Object.keys(effectiveSet as any)),
      }
    );
    await enforceUniqueIndexes(
      this.db,
      this.table,
      { ...(existing as any), ...(effectiveSet as any) },
      {
        currentId: (existing as any)._id,
        changedFields: new Set(Object.keys(effectiveSet as any)),
      }
    );
    await this.db.patch(tableName, (existing as any)._id, effectiveSet as any);
    const updated = this.returningFields
      ? await this.db.get((existing as any)._id)
      : null;

    return { status: 'updated', row: updated };
  }

  private async findConflictRow(
    value: InsertValue<TTable>,
    targetColumns: ColumnBuilder<any, any, any>[]
  ): Promise<Record<string, unknown> | null> {
    if (targetColumns.length === 0) {
      return null;
    }

    const tableName = getTableName(this.table);
    const filterValuePairs: [string, unknown][] = [];

    for (const column of targetColumns) {
      const columnName = getColumnName(column);
      const columnValue = (value as any)[columnName];
      if (columnValue === undefined) {
        return null;
      }
      filterValuePairs.push([columnName, columnValue]);
    }

    const allowFullScan = this.allowFullScanFlag;
    const ormContext = getOrmContext(this.db);
    const strict = ormContext?.strict ?? true;
    const indexName = findIndexForColumns(
      getIndexes(this.table),
      filterValuePairs.map(([field]) => field)
    );

    let query: any = this.db.query(tableName);

    if (indexName) {
      query = query.withIndex(indexName, (q: any) => {
        let builder = q.eq(filterValuePairs[0][0], filterValuePairs[0][1]);
        for (let i = 1; i < filterValuePairs.length; i++) {
          const [field, fieldValue] = filterValuePairs[i];
          builder = builder.eq(field, fieldValue);
        }
        return builder;
      });
    } else {
      if (!allowFullScan) {
        throw new Error(
          'onConflict requires allowFullScan: true when no index is available.'
        );
      }
      if (strict) {
        console.warn('onConflict running without index (allowFullScan: true).');
      }
      query = query.filter((q: any) => {
        let expr = q.eq(
          q.field(filterValuePairs[0][0]),
          filterValuePairs[0][1]
        );
        for (let i = 1; i < filterValuePairs.length; i++) {
          const [field, fieldValue] = filterValuePairs[i];
          expr = q.and(expr, q.eq(q.field(field), fieldValue));
        }
        return expr;
      });
    }

    const row = await query.first();
    return row ? (row as any) : null;
  }

  private async findAnyUniqueConflictRow(
    value: InsertValue<TTable>
  ): Promise<Record<string, unknown> | null> {
    const uniqueIndexes = getUniqueIndexes(this.table);
    if (uniqueIndexes.length === 0) {
      return null;
    }

    const tableName = getTableName(this.table);

    for (const index of uniqueIndexes) {
      const entries = index.fields.map(
        (field) => [field, (value as any)[field]] as [string, unknown]
      );
      const hasNullish = entries.some(
        ([, entryValue]) => entryValue === undefined || entryValue === null
      );
      if (hasNullish && !index.nullsNotDistinct) {
        continue;
      }

      const existing = await this.db
        .query(tableName)
        .withIndex(index.name, (q: any) => {
          let builder = q.eq(entries[0][0], entries[0][1]);
          for (let i = 1; i < entries.length; i++) {
            builder = builder.eq(entries[i][0], entries[i][1]);
          }
          return builder;
        })
        .unique();

      if (existing !== null) {
        return existing as any;
      }
    }

    return null;
  }
}
