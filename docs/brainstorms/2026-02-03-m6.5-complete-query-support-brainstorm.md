---
date: 2026-02-03
topic: m6.5-complete-query-support
milestone: M6.5
---

# M6.5: Complete Query Support

## What We're Building

**Milestone 6.5** completes all query features that Convex can support before moving to mutations (M7). This ensures queries are 100% production-ready with runtime relation loading and Convex-native pagination advantages.

**Core deliverables:**
1. **Relation loading runtime** - Make `with: { posts: true }` actually load related data
2. **Nested relations** - Support `with: { posts: { with: { comments: true } } }`
3. **Relation filters** - Support `with: { posts: { where, limit, orderBy } }`
4. **Cursor pagination** - Convex-native `.paginate({ cursor, numItems })` (O(1) vs O(n) for offset)

**Deferred (not in scope):**
- Column exclusion (`columns: { age: false }`) - low value, workaround exists
- Multi-field ordering - Convex only supports single-field ordering
- Aggregations (COUNT, SUM, etc.) - separate milestone

## Why This Approach

**Context:** M1-M6 are complete, M7 (Mutations) is next. But relation loading runtime is stubbed (types work, execution doesn't). This creates a confusing UX where types pass but queries return empty relations.

**Decision:** Block M7 until queries are 100% complete.

**Rationale:**
1. **User expectations** - If types infer relations, runtime should load them
2. **Testing foundation** - Mutations need working relation loading for comprehensive tests
3. **Clean boundaries** - Complete reads before adding writes
4. **Convex advantages** - Cursor pagination showcases Convex's O(1) performance

**Alternatives considered:**
- **M7 first, relations later** - Rejected: Queries incomplete, technical debt grows
- **Minimal relations in M7a** - Rejected: Half-baked solution, likely needs rework

## Key Decisions

### Decision 1: Include Cursor Pagination
**Choice:** Add cursor pagination to M6.5 (not defer to M8)

**Rationale:**
- Cursor pagination is a Convex differentiator (O(1) vs O(n) for deep offset pages)
- Natural fit with relation loading (both are "complete queries")
- Offset pagination already works but performs poorly for deep pages
- Provides immediate user value (infinite scroll, stable pagination)

**Trade-off:** Adds ~3-5 days to milestone but delivers major performance win

---

### Decision 2: Defer Column Exclusion
**Choice:** Skip `columns: { age: false }` in M6.5

**Rationale:**
- Column inclusion already works (`columns: { name: true, email: true }`)
- Workaround: Explicitly list included columns
- Low value (Convex returns full documents, projection happens client-side)
- Would add complexity for minimal user benefit

**Trade-off:** Documentation needs to explain workaround, but saves ~2-3 days

---

### Decision 3: Full Relation Loading (not minimal)
**Choice:** Implement nested relations + filters in M6.5, not just one-level

**Rationale:**
- Type system already supports nested relations (type-only implementation exists)
- Half-baked solution (one-level only) would need rework later
- Core implementation (edge traversal) is same complexity for nested vs flat
- Users expect nesting to work (Drizzle parity)

**Trade-off:** Slightly longer timeline (~2-3 weeks) but complete solution

## Implementation Scope

### Core Features (MUST)

#### 1. Relation Loading Runtime
**Current state:** Types inferred correctly, but `_loadRelations()` returns rows unchanged (stub)

**Implementation:**
- Implement `_loadRelations` method in `packages/better-convex/src/orm/query.ts`
- Use edge metadata from `extractRelationsConfig()` to determine field mappings
- Query related tables using Convex `.withIndex()` for edge fields
- Batch relation loading with `Promise.all()` to avoid N+1 queries

**Example:**
```typescript
// Currently: Types work, runtime doesn't
const users = await db.query.users.findMany({
  with: {
    posts: true, // ❌ Returns users without posts loaded
  },
});

// After M6.5: Runtime loads relations
const users = await db.query.users.findMany({
  with: {
    posts: true, // ✅ Returns users with posts array populated
  },
});
```

**Technical approach:**
```typescript
// Pseudocode for _loadRelations implementation
async _loadRelations(rows, withConfig) {
  if (!withConfig) return rows;

  for (const [relationName, relationConfig] of Object.entries(withConfig)) {
    const edge = this.edgeMetadata[relationName];

    // Batch load all related records
    const relatedIds = rows.map(row => row[edge.fieldName]);
    const relatedRecords = await this.db
      .query(edge.targetTable)
      .withIndex(edge.indexName, q => q.in(relatedIds))
      .collect();

    // Map relations back to parent rows
    for (const row of rows) {
      row[relationName] = relatedRecords.filter(
        r => r[edge.referenceField] === row[edge.fieldName]
      );
    }
  }

  return rows;
}
```

---

#### 2. Nested Relations
**Current state:** Type inference supports nesting, runtime doesn't traverse

**Implementation:**
- Recursive relation loading in `_loadRelations`
- Pass nested `with` config to child queries
- Handle circular references (max depth limit)

**Example:**
```typescript
const users = await db.query.users.findMany({
  with: {
    posts: {
      with: {
        comments: true, // ✅ Loads users → posts → comments
      },
    },
  },
});
```

**Technical approach:**
```typescript
// Recursive relation loading
async _loadRelations(rows, withConfig, depth = 0) {
  if (!withConfig || depth > 3) return rows; // Max depth 3

  for (const [relationName, relationConfig] of Object.entries(withConfig)) {
    // Load current level
    const relatedRows = await this._loadRelationLevel(rows, relationName, relationConfig);

    // Recursively load nested relations
    if (relationConfig.with) {
      await this._loadRelations(relatedRows, relationConfig.with, depth + 1);
    }
  }

  return rows;
}
```

---

#### 3. Relation Filters/Limits
**Current state:** Type system accepts `where`, `limit`, `orderBy` in relation config, runtime ignores

**Implementation:**
- Apply filters to relation queries during batch loading
- Use existing `WhereClauseCompiler` for relation `where` clauses
- Apply `limit` and `orderBy` to relation results

**Example:**
```typescript
const users = await db.query.users.findMany({
  with: {
    posts: {
      where: (post, { eq }) => eq(post.published, true),
      orderBy: desc(posts._creationTime),
      limit: 5, // ✅ Only load 5 most recent published posts per user
    },
  },
});
```

**Technical approach:**
```typescript
// Apply relation filters during batch load
async _loadRelationLevel(rows, relationName, relationConfig) {
  const edge = this.edgeMetadata[relationName];

  let query = this.db.query(edge.targetTable)
    .withIndex(edge.indexName, q => q.in(relatedIds));

  // Apply where filter if provided
  if (relationConfig.where) {
    query = applyWhereClause(query, relationConfig.where);
  }

  // Apply orderBy if provided
  if (relationConfig.orderBy) {
    query = applyOrderBy(query, relationConfig.orderBy);
  }

  let relatedRecords = await query.collect();

  // Apply limit per parent (not global limit)
  if (relationConfig.limit) {
    relatedRecords = groupByParent(relatedRecords, edge.fieldName)
      .map(group => group.slice(0, relationConfig.limit));
  }

  return relatedRecords;
}
```

---

#### 4. Cursor Pagination
**Current state:** Offset pagination works but O(n) for deep pages

**Implementation:**
- Add `.paginate()` method to query builder
- Accept `{ cursor: string | null, numItems: number }` config
- Use Convex native `.paginate()` under the hood
- Return `{ page: T[], continueCursor: string | null, isDone: boolean }`

**Example:**
```typescript
// Offset pagination (current - works but slow for deep pages)
const users = await db.query.users.findMany({
  offset: page * 20, // O(n) - skips first page*20 records
  limit: 20,
});

// Cursor pagination (new - O(1) constant time)
const result = await db.query.users.paginate({
  cursor: args.cursor ?? null,
  numItems: 20,
});
// Returns: { page: User[], continueCursor: string | null, isDone: boolean }
```

**Technical approach:**
```typescript
// Add paginate method to RelationalQueryBuilder
paginate(config: { cursor: string | null; numItems: number }) {
  const query = this.db.query(this.tableName);

  // Apply where filters
  if (this.config.where) {
    applyWhereClause(query, this.config.where);
  }

  // Apply orderBy (required for cursor pagination)
  if (this.config.orderBy) {
    applyOrderBy(query, this.config.orderBy);
  } else {
    // Default: order by _creationTime
    query = query.order('desc');
  }

  // Use Convex native paginate
  return query.paginate({
    cursor: config.cursor,
    numItems: config.numItems,
  });
}
```

---

### Type Testing (Apply M4.5 Methodology)

**Add 7 deferred relation loading tests** from `convex/test-types/db-rel.ts`:
1. One-to-one relation type inference
2. One-to-many relation array types
3. Many-to-one relation nullable types
4. Nested relation type inference (2-3 levels deep)
5. Relation with filters type inference
6. Relation with limit type inference
7. Circular relation detection (negative test)

**Add cursor pagination type tests** (new file: `convex/test-types/pagination.ts`):
1. Paginate result type (`{ page, continueCursor, isDone }`)
2. Cursor type (string | null)
3. numItems parameter (number)
4. Empty result page type
5. Combined with filters type inference

**Follow M4.5 pattern:**
- Use mock database with type casting
- Use `await` for type inference without execution
- Use `Equal<>` and `Expect<>` assertions
- Add negative tests with `@ts-expect-error`

---

### Runtime Testing (convex-test)

**Relation loading tests** (`convex/relations-loading.test.ts`):
```typescript
import { convexTest } from 'convex-test';
import { test, expect } from 'vitest';
import schema from './schema';

test('loads one-to-many relations', async () => {
  const t = convexTest(schema);

  // Setup: Create user with posts
  const userId = await t.mutation(api.users.create, { name: 'Alice' });
  await t.mutation(api.posts.create, { userId, title: 'Post 1' });
  await t.mutation(api.posts.create, { userId, title: 'Post 2' });

  // Test: Load user with posts
  const users = await t.query(api.users.findWithPosts);

  expect(users).toHaveLength(1);
  expect(users[0].posts).toHaveLength(2);
  expect(users[0].posts[0].title).toBe('Post 1');
});

test('loads nested relations', async () => {
  // User → Posts → Comments (3 levels)
  const t = convexTest(schema);

  // Setup: Create user → post → comment
  const userId = await t.mutation(api.users.create, { name: 'Alice' });
  const postId = await t.mutation(api.posts.create, { userId, title: 'Post 1' });
  await t.mutation(api.comments.create, { postId, text: 'Comment 1' });

  // Test: Load nested relations
  const users = await t.query(api.users.findWithNestedPosts);

  expect(users[0].posts[0].comments).toHaveLength(1);
  expect(users[0].posts[0].comments[0].text).toBe('Comment 1');
});

test('applies relation filters', async () => {
  const t = convexTest(schema);

  // Setup: Create user with published + unpublished posts
  const userId = await t.mutation(api.users.create, { name: 'Alice' });
  await t.mutation(api.posts.create, { userId, title: 'Draft', published: false });
  await t.mutation(api.posts.create, { userId, title: 'Live', published: true });

  // Test: Load only published posts
  const users = await t.query(api.users.findWithPublishedPosts);

  expect(users[0].posts).toHaveLength(1);
  expect(users[0].posts[0].title).toBe('Live');
});
```

**Cursor pagination tests** (`convex/pagination.test.ts`):
```typescript
test('cursor pagination returns consistent pages', async () => {
  const t = convexTest(schema);

  // Setup: Create 50 users
  for (let i = 0; i < 50; i++) {
    await t.mutation(api.users.create, { name: `User ${i}` });
  }

  // Test: Paginate through all users
  let cursor = null;
  let allUsers = [];

  for (let page = 0; page < 3; page++) {
    const result = await t.query(api.users.paginate, { cursor, numItems: 20 });
    allUsers.push(...result.page);
    cursor = result.continueCursor;

    if (page === 0) {
      expect(result.page).toHaveLength(20);
      expect(result.isDone).toBe(false);
    }
  }

  expect(allUsers).toHaveLength(50);
});
```

---

### Documentation Updates

**Update limitations.mdx:**
- ✅ Move relation loading from "Coming Soon" to "Implemented (M6.5)"
- ✅ Move cursor pagination from "Coming Soon" to "Implemented (M6.5)"
- ✅ Update "Current Status" section with M6.5 features

**Update index.mdx:**
- ✅ Update feature compatibility list (Category 1 + Category 3)
- ✅ Add cursor pagination to Convex-Native Advantages

**Create new doc:**
- ✅ `www/content/docs/db/orm/pagination.mdx` - Cursor vs offset pagination guide

---

## Open Questions

1. **Circular relation depth limit?**
   - Proposed: Max depth 3 for nested relations
   - Alternative: User-configurable depth limit
   - Decision: Default max depth 3, expose `maxDepth` option in config

2. **Relation loading performance strategy?**
   - Proposed: Batch load with `Promise.all()` to avoid N+1
   - Alternative: Dataloader pattern with request deduplication
   - Decision: Start with simple batch loading, optimize with dataloader if needed

3. **Cursor pagination ordering requirement?**
   - Question: Should cursor pagination require explicit `orderBy`?
   - Proposed: Default to `_creationTime desc` if no `orderBy` provided
   - Alternative: Throw error if no `orderBy` (stricter)
   - Decision: Default to `_creationTime desc` for convenience

4. **Column exclusion priority?**
   - Question: Should we implement `columns: { age: false }` in M6.5 or defer?
   - Current decision: Defer (low value, workaround exists)
   - Reconsider if user feedback demands it

---

## Success Criteria

**M6.5 is complete when:**

- ✅ Relation loading runtime works (one-level and nested)
- ✅ Relation filters/limits apply correctly
- ✅ Cursor pagination API implemented
- ✅ All 7 deferred relation loading type tests pass
- ✅ All new cursor pagination type tests pass
- ✅ Runtime tests with convex-test pass (20+ tests)
- ✅ `bun typecheck` passes with 0 errors
- ✅ `bun run test` passes (all vitest tests)
- ✅ Documentation updated (limitations.mdx, index.mdx, new pagination.mdx)
- ✅ README.md in convex/test-types/ references M6.5 completion

**Performance benchmarks:**
- Relation loading: No N+1 queries (verify with Convex dashboard logs)
- Cursor pagination: O(1) performance for page 100+ (vs O(n) for offset)
- Nested relations: Max depth 3 supported without stack overflow

---

## Next Steps

→ `/workflows:plan` for detailed M6.5 implementation plan

**Estimated timeline:** 2-3 weeks
- Week 1: Relation loading runtime + nested relations
- Week 2: Relation filters + cursor pagination
- Week 3: Type tests + runtime tests + documentation

**After M6.5 complete:**
→ M7: Mutations (INSERT/UPDATE/DELETE)

---

## References

- [M4.5 Type Testing Methodology](../../convex/test-types/README.md)
- [Original Brainstorm: Drizzle-Convex ORM](./2026-01-31-drizzle-orm-brainstorm.md)
- [Convex Pagination Docs](https://docs.convex.dev/database/pagination)
- [Drizzle Relations API](https://orm.drizzle.team/docs/rqb#with-select)
