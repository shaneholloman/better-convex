# ORM Reference

Complete ORM API for feature work. Setup: `./setup.md`. Filters/search/pagination: `./filters.md`.

## Core Rules

1. `ctx.orm.query.*` for reads, `ctx.orm.insert/update/delete` for writes.
2. Keep list queries bounded (`limit`/cursor) and index-aware.
3. Use relations (`with`) for loading related data.
4. Put cross-row side effects in schema triggers.
5. Constraints (unique, FK, check) enforced by ORM mutations only — `ctx.db` bypasses them.

## Column Types

All from `better-convex/orm`:

| Builder                         | TS Type       | Convex                 | Notes                                      |
| ------------------------------- | ------------- | ---------------------- | ------------------------------------------ |
| `text()`                        | `string`      | `v.string()`           |                                            |
| `textEnum(['a','b'] as const)`  | `'a' \| 'b'`  | `v.string()`           | Runtime-validated                          |
| `integer()`                     | `number`      | `v.number()`           | Float64                                    |
| `boolean()`                     | `boolean`     | `v.boolean()`          |                                            |
| `bigint()`                      | `bigint`      | `v.int64()`            |                                            |
| `timestamp()`                   | `Date`        | `v.number()`           | `.defaultNow()` for createdAt              |
| `timestamp({ mode: 'string' })` | `string`      | `v.number()`           |                                            |
| `date()`                        | `string`      | `v.string()`           | YYYY-MM-DD, or `{ mode: 'date' }` → `Date` |
| `id('table')`                   | `Id<'table'>` | `v.id('table')`        | Typed reference                            |
| `vector(dims)`                  | `number[]`    | `v.array(v.float64())` | For vectorIndex                            |
| `bytes()`                       | `ArrayBuffer` | `v.bytes()`            |                                            |
| `json<T>()`                     | `T`           | `v.any()`              | Type-only, no runtime validation           |
| `custom(validator)`             | inferred      | any `v.*`              | Full Convex validator                      |

### Column Modifiers

```ts
text().notNull(); // required on select, required on insert
text().default("draft"); // optional on insert, uses default
text().notNull().unique(); // unique constraint (runtime-enforced)
timestamp().defaultNow(); // shorthand for $defaultFn(() => new Date())
timestamp().$onUpdateFn(() => new Date()); // runs on update when field not explicitly set
json<T>().$type<T>(); // type-only override
text().$defaultFn(() => crypto.randomUUID()); // custom default
```

### Type Inference

```ts
type Post = typeof posts.$inferSelect; // Select type (fields are T | null unless .notNull())
type NewPost = typeof posts.$inferInsert; // Insert type (required if .notNull() + no default)

// Or with helpers:
import { InferSelectModel, InferInsertModel } from "better-convex/orm";
type Post = InferSelectModel<typeof posts>;
```

## Constraints

### Unique

```ts
// Column-level
email: text().notNull().unique();

// Table-level unique index
import { uniqueIndex } from "better-convex/orm";
(t) => [uniqueIndex("users_email_unique").on(t.email)];

// Compound unique
import { unique } from "better-convex/orm";
(t) => [unique("full_name").on(t.firstName, t.lastName)];
```

### Foreign Keys

```ts
// Column-level (.references)
authorId: id("users")
  .notNull()
  .references(() => users.id);

// With cascading actions
authorId: id("users")
  .notNull()
  .references(() => users.id, {
    onDelete: "cascade", // cascade | set null | set default | restrict | no action
  });

// Self-referencing (use AnyColumn return type)
import { type AnyColumn } from "better-convex/orm";
parentId: text().references((): AnyColumn => commentsTable.id, {
  onDelete: "cascade",
});

// Table-level (foreignKey builder, for non-id references)
import { foreignKey } from "better-convex/orm";
(t) => [foreignKey({ columns: [t.userSlug], foreignColumns: [users.slug] })];
```

### Check Constraints

```ts
import { check, gt, isNotNull } from "better-convex/orm";
(t) => [
  check("age_over_18", gt(t.age, 18)),
  check("email_present", isNotNull(t.email)),
];
```

## Indexes

```ts
import { index, searchIndex, vectorIndex } from 'better-convex/orm';

// Standard index
(t) => [index('by_author').on(t.authorId)]

// Search index (full-text)
(t) => [searchIndex('by_title').on(t.title).filter(t.authorId)]

// Vector index
(t) => [vectorIndex('embedding_vec').on(t.embedding).dimensions(1536).filter(t.authorId)]
```

## Relations

```ts
import { defineRelations } from "better-convex/orm";

export const relations = defineRelations(
  { users, posts, tags, postsTags },
  (r) => ({
    users: {
      posts: r.many.posts(),
    },
    posts: {
      author: r.one.users({ from: r.posts.authorId, to: r.users.id }),
      // optional: false → non-nullable return type
      // alias: 'author' → disambiguate multiple relations to same table
      // where: { published: true } → predefined filter
    },
    // Many-to-many via join table
    postsTags: {
      post: r.one.posts({ from: r.postsTags.postId, to: r.posts.id }),
      tag: r.one.tags({ from: r.postsTags.tagId, to: r.tags.id }),
    },
  })
);
```

### Many-to-many with `.through()`

```ts
users: {
  groups: r.many.groups({
    from: r.users.id.through(r.usersToGroups.userId),
    to: r.groups.id.through(r.usersToGroups.groupId),
    alias: 'users-groups-direct',
  }),
},
```

### Self-referencing

```ts
users: {
  manager: r.one.users({ from: r.users.managerId, to: r.users.id, alias: 'manager' }),
  reports: r.many.users({ from: r.users.id, to: r.users.managerId, alias: 'manager' }),
},
```

### Split relations (`defineRelationsPart`)

For large schemas, split relation definitions across modules and merge:

```ts
import { defineRelationsPart } from "better-convex/orm";
const userRelations = defineRelationsPart({ users, posts }, (r) => ({
  users: { posts: r.many.posts({ from: r.users.id, to: r.posts.authorId }) },
}));
// Merge into defineRelations
```

### Relation indexing requirements

- `many()` → index child FK field (e.g., `posts.userId`)
- `.through()` → index junction table FK fields (both directions)
- `one()` with `to: ...id` → uses `db.get()` (no extra index)
- Missing index throws unless `allowFullScan` on parent query

## Schema Definition

```ts
import { defineSchema } from "better-convex/orm";

// defineSchema takes tables map (not relations)
export default defineSchema(tables, {
  strict: false, // false = warn instead of throw on missing indexes
  defaults: {
    defaultLimit: 100, // default limit for findMany
    mutationBatchSize: 100, // page size for mutation row collection
    mutationMaxRows: 1000, // sync-mode hard cap
    mutationLeafBatchSize: 900, // async FK fan-out batch size
    mutationMaxBytesPerBatch: 2_097_152, // async measured-byte budget
    mutationScheduleCallCap: 100, // async schedule calls per mutation
    mutationExecutionMode: "sync", // or 'async'
    mutationAsyncDelayMs: 0,
    relationFanOutMaxKeys: 1000,
  },
});
```

## Queries

```ts
// findMany with full options
const posts = await ctx.orm.query.posts.findMany({
  where: { authorId: ctx.userId, status: "published" },
  orderBy: { createdAt: "desc" },
  limit: 20,
  columns: { id: true, title: true, createdAt: true },
  with: { author: true, tags: { limit: 5 } },
});

// findFirst / findFirstOrThrow
const post = await ctx.orm.query.posts.findFirst({ where: { id: input.id } });
const post = await ctx.orm.query.posts.findFirstOrThrow({
  where: { id: input.id },
});

// Cursor pagination
const page = await ctx.orm.query.posts.findMany({
  where: { published: true },
  orderBy: { createdAt: "desc" },
  cursor: input.cursor ?? null,
  limit: 20,
});
// Returns: { page, continueCursor, isDone }

// Extras (computed fields, post-fetch)
const users = await ctx.orm.query.users.findMany({
  extras: { emailDomain: (row) => row.email.split("@")[1]! },
  limit: 50,
});

// System tables (raw Convex, not ORM)
const job = await ctx.orm.system.get(jobId);
const files = await ctx.orm.system.query("_storage").take(20);
```

### allowFullScan

Non-paginated `findMany()` requires sizing: `limit`, `cursor + limit`, `allowFullScan`, or `defaults.defaultLimit`.

For filter operators, search, select composition, pagination: see `./filters.md`.

## Mutations

### Insert

```ts
import { user } from "./schema";

// Basic
await ctx.orm.insert(user).values({ name: "Ada", email: "ada@domain.test" });

// Multi-row
await ctx.orm.insert(user).values([
  { name: "A", email: "a@domain.test" },
  { name: "B", email: "b@domain.test" },
]);

// Returning
const [row] = await ctx.orm
  .insert(user)
  .values({ name: "Ada", email: "ada@domain.test" })
  .returning(); // all fields

const [partial] = await ctx.orm
  .insert(user)
  .values({ name: "Ada", email: "ada@domain.test" })
  .returning({ id: user.id, email: user.email });

// Upsert: onConflictDoUpdate
await ctx.orm
  .insert(user)
  .values({ email: "ada@domain.test", name: "Ada" })
  .onConflictDoUpdate({ target: user.email, set: { name: "Ada Lovelace" } });

// Skip on conflict
await ctx.orm
  .insert(user)
  .values({ email: "ada@domain.test", name: "Ada" })
  .onConflictDoNothing({ target: user.email });
```

### Update

```ts
import { eq } from "better-convex/orm";
import { user } from "./schema";

// Basic
await ctx.orm
  .update(user)
  .set({ name: "Updated" })
  .where(eq(user.id, input.id));

// Returning
const [updated] = await ctx.orm
  .update(user)
  .set({ name: "New" })
  .where(eq(user.id, input.id))
  .returning();

// Unset a field
import { unsetToken } from "better-convex/orm";
await ctx.orm
  .update(user)
  .set({ nickname: unsetToken })
  .where(eq(user.id, input.id));

// Update without .where() throws — use .allowFullScan() to opt in
await ctx.orm.update(user).set({ role: "member" }).allowFullScan();
```

### Delete

```ts
await ctx.orm.delete(user).where(eq(user.id, input.id));

// Returning
const [deleted] = await ctx.orm
  .delete(user)
  .where(eq(user.id, input.id))
  .returning();

// Delete all (use with care)
await ctx.orm.delete(user).allowFullScan();
```

### Delete Modes

```ts
// Table-level default
import { deletion } from "better-convex/orm";
const user = convexTable(
  "user",
  {
    slug: text().notNull(),
    deletionTime: integer(),
  },
  () => [deletion("scheduled", { delayMs: 60_000 })]
);

// Per-query overrides
await ctx.orm.delete(user).where(eq(user.id, id)).hard(); // immediate
await ctx.orm.delete(user).where(eq(user.id, id)).soft(); // mark deleted
await ctx.orm
  .delete(user)
  .where(eq(user.id, id))
  .scheduled({ delayMs: 60_000 });

// Cancel scheduled delete: clear/change deletionTime before worker runs
```

### Paginated Mutations

For large workloads exceeding safety limits:

```ts
// Requires index on filtered field: index('by_role').on(t.role)
const page1 = await ctx.orm
  .update(user)
  .set({ role: "member" })
  .where(eq(user.role, "pending"))
  .paginate({ cursor: null, limit: 100 });
// Returns: { continueCursor, isDone, numAffected }
```

### Async Batched Mutations

First batch runs sync, remaining auto-scheduled:

```ts
// Per call
await ctx.orm
  .update(user)
  .set({ role: "member" })
  .where(eq(user.role, "pending"))
  .execute({ mode: "async", batchSize: 200, delayMs: 0 });

// Or convenience alias
await ctx.orm.delete(user).where(eq(user.role, "inactive")).executeAsync();

// Or global default
defineSchema(relations, { defaults: { mutationExecutionMode: "async" } });
```

Async requires wiring `ormFunctions` + `scheduledMutationBatch` in ORM setup. See setup.md.

## RLS (Row-Level Security)

### Define policies

```ts
import { convexTable, rlsPolicy, text, id, eq } from "better-convex/orm";

export const secrets = convexTable.withRLS(
  "secrets",
  {
    value: text().notNull(),
    ownerId: id("users").notNull(),
  },
  (t) => [
    rlsPolicy("read_own", {
      for: "select",
      using: (ctx) => eq(t.ownerId, ctx.viewerId),
    }),
    rlsPolicy("insert_own", {
      for: "insert",
      withCheck: (ctx) => eq(t.ownerId, ctx.viewerId),
    }),
    rlsPolicy("update_own", {
      for: "update",
      using: (ctx) => eq(t.ownerId, ctx.viewerId),
      withCheck: (ctx) => eq(t.ownerId, ctx.viewerId),
    }),
    rlsPolicy("delete_own", {
      for: "delete",
      using: (ctx) => eq(t.ownerId, ctx.viewerId),
    }),
  ]
);
```

### Policy operations

| Operation | Clause                | When                            |
| --------- | --------------------- | ------------------------------- |
| `select`  | `using`               | Filters rows after fetch        |
| `insert`  | `withCheck`           | Validates new rows before write |
| `update`  | `using` + `withCheck` | Filters existing, validates new |
| `delete`  | `using`               | Filters rows before delete      |

### Context setup

```ts
const orm = createOrm({ schema: relations });
const ormDb = orm.db(ctx, { rls: { ctx } });
```

### Bypass RLS

```ts
await ctx.orm.skipRules.query.secrets.findMany();
```

### Roles

```ts
import { rlsRole } from "better-convex/orm";
const admin = rlsRole("admin");
rlsPolicy("admin_only", {
  for: "select",
  to: admin,
  using: (ctx, t) => eq(t.ownerId, ctx.viewerId),
});

// Provide roleResolver
const ormDb = orm.db(ctx, {
  rls: { ctx, roleResolver: (ctx) => ctx.roles ?? [] },
});
```

**Important:** `ctx.db` bypasses RLS. Only `ctx.orm` enforces policies. FK cascade fan-out also bypasses child-table RLS.

## Triggers

Schema-level hooks: `onInsert`, `onUpdate`, `onDelete`, `onChange`. All from `better-convex/orm`.

```ts
export const comments = convexTable(
  "comments",
  {
    postId: id("posts").notNull(),
    body: text().notNull(),
  },
  (t) => [
    index("by_post").on(t.postId),
    onInsert(async (ctx, change) => {
      await ctx.orm
        .update(posts)
        .set({ lastCommentAt: new Date() })
        .where(eq(posts.id, change.newDoc.postId));
    }),
    onDelete(async (ctx, change) => {
      await ctx.orm
        .update(posts)
        .set({ lastCommentAt: new Date() })
        .where(eq(posts.id, change.oldDoc.postId));
    }),
  ]
);
```

### onChange payload

```ts
onChange(async (ctx, change) => {
  change.id; // always present
  change.operation; // 'insert' | 'update' | 'delete'
  change.oldDoc; // null on insert
  change.newDoc; // null on delete
});
```

### Aggregate triggers

```ts
import { aggregatePostLikes } from "./aggregates";
() => [aggregatePostLikes.trigger()];
```

### Trigger safety checklist

1. Idempotent logic.
2. Bounded writes (no full-scan loops).
3. No recursive ping-pong between tables.
4. Expensive work → `ctx.scheduler.runAfter`, not long trigger chains.
5. Auth checks in procedure layer; triggers focus on data invariants.

### Auth triggers vs DB triggers

Auth triggers (`triggers: { user, session }` in `createClient`) are separate from DB triggers. For DB-level side effects, use schema triggers with `withOrm` in auth setup.

## Complete Schema Template

```ts
import {
  boolean,
  check,
  convexTable,
  defineRelations,
  defineSchema,
  deletion,
  eq,
  id,
  index,
  integer,
  json,
  onChange,
  onInsert,
  searchIndex,
  text,
  textEnum,
  timestamp,
  uniqueIndex,
} from "better-convex/orm";

export const user = convexTable("user", {
  name: text().notNull(),
  email: text().notNull().unique(),
  role: textEnum(["admin", "user"] as const)
    .notNull()
    .default("user"),
  plan: text(),
  banned: boolean(),
  createdAt: timestamp().notNull().defaultNow(),
  updatedAt: timestamp()
    .notNull()
    .defaultNow()
    .$onUpdateFn(() => new Date()),
  metadata: json<Record<string, unknown>>(),
});

export const post = convexTable(
  "post",
  {
    title: text().notNull(),
    content: text().notNull(),
    published: boolean().notNull().default(false),
    authorId: id("user")
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    deletionTime: integer(),
    createdAt: timestamp().notNull().defaultNow(),
  },
  (t) => [
    index("by_author").on(t.authorId),
    index("by_author_created").on(t.authorId, t.createdAt),
    searchIndex("search_title").on(t.title).filter(t.authorId),
    deletion("scheduled", { delayMs: 60_000 }),
    onInsert(async (ctx, change) => {
      console.log("post created", change.id);
    }),
  ]
);

const tables = { user, post };
export default defineSchema(tables, { strict: false });

export const relations = defineRelations(tables, (r) => ({
  user: { posts: r.many.post() },
  post: {
    author: r.one.user({
      from: r.post.authorId,
      to: r.user.id,
      optional: false,
    }),
  },
}));
```

## Related References

- Filters/search/pagination: `./filters.md`
- Aggregates: `./aggregates.md`
- Scheduling: `./scheduling.md`
- HTTP: `./http.md`
- React/RSC: `./react.md`
