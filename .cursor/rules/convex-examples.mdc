---
description: Complete examples for building Convex applications including chat apps and other common patterns
globs: **/*.ts,**/*.tsx
alwaysApply: false
---

# Convex Examples

## Example: Real-time Chat Application

### Overview

This example demonstrates building a real-time chat application backend with AI responses. The app includes:

- User management with authentication
- Multiple chat channels
- Real-time messaging
- AI-powered responses using OpenAI
- Message history with proper ordering

### Requirements

```json
{
  "dependencies": {
    "convex": "^1.17.4",
    "openai": "^4.79.0",
    "@convex-dev/better-auth": "^1.0.0",
    "@convex-dev/rate-limiter": "^0.2.0",
    "convex-helpers": "^0.1.0",
    "better-auth": "^1.0.0",
    "zod": "^3.0.0"
  }
}
```

### Schema Design

```typescript
// convex/schema.ts
import { defineEnt, defineEntSchema, getEntDefinitions } from 'convex-ents';
import { v } from 'convex/values';

const schema = defineEntSchema({
  channels: defineEnt({
    name: v.string(),
    createdBy: v.id('user'),
  }),

  users: defineEnt({
    name: v.string(),
    username: v.string(),
    email: v.optional(v.string()),
    role: v.optional(v.union(v.literal('user'), v.literal('admin'))),
  }).index('username', ['username']),

  messages: defineEnt({
    channelId: v.id('channels'),
    authorId: v.optional(v.id('user')),
    content: v.string(),
  })
    .index('channel', ['channelId'])
    .index('author_channel', ['authorId', 'channelId']),

  channelMembers: defineEnt({
    channelId: v.id('channels'),
    userId: v.id('user'),
    joinedAt: v.number(),
  })
    .index('channel', ['channelId'])
    .index('user', ['userId'])
    .index('channel_user', ['channelId', 'userId']),
});

export default schema;
export const entDefinitions = getEntDefinitions(schema);
```

### Implementation

```typescript
// convex/chat.ts
import { z } from 'zod';
import { zid } from 'convex-helpers/server/zod';
import { asyncMap } from 'convex-helpers';
import { ConvexError } from 'convex/values';
import OpenAI from 'openai';
import { internal } from './_generated/api';
import {
  createAuthQuery,
  createPublicQuery,
  createAuthMutation,
  createPublicMutation,
  createInternalQuery,
  createInternalMutation,
  createInternalAction,
} from './functions';

/** Create a user with a given name. */
export const createUser = createPublicMutation()({
  args: {
    name: z.string(),
  },
  returns: zid('user'),
  handler: async (ctx, args) => {
    return await ctx.table('user').insert({
      name: args.name,
    });
  },
});

/** Create a channel with a given name. */
export const createChannel = createAuthMutation({
  rateLimit: 'channel/create',
})({
  args: {
    name: z.string(),
  },
  returns: zid('channels'),
  handler: async (ctx, args) => {
    return await ctx.table('channels').insert({
      name: args.name,
      createdBy: ctx.userId,
    });
  },
});

/** List messages with author details using relationship helpers. */
export const listMessages = createPublicQuery()({
  args: {
    channelId: zid('channels'),
  },
  returns: z.array(
    z.object({
      _id: zid('messages'),
      _creationTime: z.number(),
      channelId: zid('channels'),
      authorId: z.union([zid('user'), z.null()]).optional(),
      author: z
        .union([
          z.object({
            _id: zid('user'),
            name: z.string(),
          }),
          z.null(),
        ])
        .optional(),
      content: z.string(),
    })
  ),
  handler: async (ctx, args) => {
    const messages = await ctx
      .table('messages', 'channel', (q) => q.eq('channelId', args.channelId))
      .take(10);

    // Get unique author IDs
    const authorIds = [
      ...new Set(messages.filter((m) => m.authorId).map((m) => m.authorId!)),
    ];

    // Fetch all authors at once
    const authors = await ctx.table('user').getMany(authorIds);
    const authorMap = new Map(authors.map((a) => a && [a._id, a]));

    // Combine messages with authors
    return messages.reverse().map((msg) => ({
      ...msg,
      author: msg.authorId ? authorMap.get(msg.authorId) || null : null,
    }));
  },
});

/** Send a message to a channel and schedule a response from the AI. */
export const sendMessage = createAuthMutation({
  rateLimit: 'ai',
})({
  args: {
    channelId: zid('channels'),
    content: z.string(),
  },
  returns: z.null(),
  handler: async (ctx, args) => {
    const channel = await ctx.table('channels').getX(args.channelId);

    await ctx.table('messages').insert({
      channelId: args.channelId,
      authorId: ctx.userId,
      content: args.content,
    });

    await ctx.scheduler.runAfter(0, internal.chat.generateResponse, {
      channelId: args.channelId,
    });
    return null;
  },
});

const openai = new OpenAI();

/** Get channel members - example of many-to-many with asyncMap */
export const getChannelMembers = createPublicQuery()({
  args: { channelId: zid('channels') },
  returns: z.array(
    z.object({
      _id: zid('user'),
      name: z.string(),
      lastSeen: z.number().optional(),
    })
  ),
  handler: async (ctx, args) => {
    // Get channel members via join table
    const members = await ctx.table('channelMembers', 'channel', (q) =>
      q.eq('channelId', args.channelId)
    );

    // Fetch user details and last activity in parallel
    return await asyncMap(members, async (member) => {
      const user = await ctx.table('user').get(member.userId);
      if (!user) return null;

      // Get last message timestamp
      const lastMessage = await ctx
        .table('messages', 'author_channel', (q) =>
          q.eq('authorId', user._id).eq('channelId', args.channelId)
        )
        .order('desc')
        .first();

      return {
        _id: user._id,
        name: user.name,
        lastSeen: lastMessage?._creationTime,
      };
    }).then((results) => results.filter((r) => r !== null) as any);
  },
});

export const generateResponse = createInternalAction()({
  args: {
    channelId: zid('channels'),
  },
  returns: z.null(),
  handler: async (ctx, args) => {
    const context = await ctx.runQuery(internal.chat.loadContext, {
      channelId: args.channelId,
    });
    const response = await openai.chat.completions.create({
      model: 'gpt-4o',
      messages: context,
    });
    const content = response.choices[0].message.content;
    if (!content) {
      throw new ConvexError({
        code: 'INTERNAL_ERROR',
        message: 'No content in response',
      });
    }
    await ctx.runMutation(internal.chat.writeAgentResponse, {
      channelId: args.channelId,
      content,
    });
    return null;
  },
});

export const loadContext = createInternalQuery()({
  args: {
    channelId: zid('channels'),
  },
  returns: z.array(
    z.object({
      role: z.union([z.literal('user'), z.literal('assistant')]),
      content: z.string(),
    })
  ),
  handler: async (ctx, args) => {
    const channel = await ctx.table('channels').getX(args.channelId);
    const messages = await ctx
      .table('messages', 'channel', (q) => q.eq('channelId', args.channelId))
      .order('desc')
      .take(10);

    const result = [];
    for (const message of messages) {
      if (message.authorId) {
        const user = await ctx.table('user').getX(message.authorId);
        result.push({
          role: 'user' as const,
          content: `${user.name}: ${message.content}`,
        });
      } else {
        result.push({ role: 'assistant' as const, content: message.content });
      }
    }
    return result;
  },
});

export const writeAgentResponse = createInternalMutation()({
  args: {
    channelId: zid('channels'),
    content: z.string(),
  },
  returns: z.null(),
  handler: async (ctx, args) => {
    await ctx.table('messages').insert({
      channelId: args.channelId,
      content: args.content,
    });
    return null;
  },
});
```

### Frontend Integration

```tsx
// src/components/chat.tsx
import { useAuthQuery, useAuthMutation } from '@/lib/convex/hooks';
import { api } from '@convex/_generated/api';

export function Chat({ channelId }: { channelId: Id<'channels'> }) {
  const { data: messages } = useAuthQuery(api.chat.listMessages, { channelId });
  const sendMessage = useAuthMutation(api.chat.sendMessage);

  const handleSend = async (content: string) => {
    await sendMessage.mutateAsync({ channelId, content });
  };

  return (
    <div>
      {messages?.map((msg) => (
        <div key={msg._id}>
          <strong>{msg.author?.name || 'AI'}:</strong> {msg.content}
        </div>
      ))}
      {/* Add input form here */}
    </div>
  );
}
```

## Example: User Profile with Following System

### Schema

```typescript
// Add to schema.ts
follows: defineEnt({
  followerId: v.id('user'),
  followingId: v.id('user'),
})
  .index('follower', ['followerId'])
  .index('following', ['followingId'])
  .index('follower_following', ['followerId', 'followingId']),
```

### Implementation

```typescript
// convex/follows.ts
export const follow = createAuthMutation()({
  args: {
    userToFollowId: zid('user'),
  },
  returns: z.boolean(),
  handler: async (ctx, args) => {
    // Check if already following
    const existing = await ctx
      .table('follows', 'follower_following', (q) =>
        q.eq('followerId', ctx.userId).eq('followingId', args.userToFollowId)
      )
      .unique();

    if (existing) {
      throw new ConvexError({
        code: 'ALREADY_EXISTS',
        message: 'Already following this user',
      });
    }

    await ctx.table('follows').insert({
      followerId: ctx.userId,
      followingId: args.userToFollowId,
    });

    return true;
  },
});

export const getFollowers = createPublicQuery()({
  args: {
    userId: zid('user'),
  },
  returns: z.array(
    z.object({
      _id: zid('user'),
      name: z.string(),
      username: z.string(),
    })
  ),
  handler: async (ctx, args) => {
    // Get all follower relationships
    const follows = await ctx.table('follows', 'following', (q) =>
      q.eq('followingId', args.userId)
    );

    // Get user details
    const followerIds = follows.map((f) => f.followerId);
    const users = await ctx.table('user').getMany(followerIds);

    return users.filter((u) => u !== null) as any;
  },
});
```

## Example: Document Comments System

### Schema

```typescript
// Add to schema.ts
comments: defineEnt({
  documentId: v.id('documents'),
  userId: v.id('user'),
  content: v.string(),
  parentId: v.optional(v.id('comments')),
})
  .index('document', ['documentId'])
  .index('user', ['userId'])
  .index('parent', ['parentId']),

upvotes: defineEnt({
  commentId: v.id('comments'),
  userId: v.id('user'),
})
  .index('comment', ['commentId'])
  .index('user', ['userId'])
  .index('comment_user', ['commentId', 'userId']),
```

### Implementation

```typescript
// convex/comments.ts
export const addComment = createAuthMutation()({
  args: {
    documentId: zid('documents'),
    content: z.string().min(1).max(1000),
    parentId: zid('comments').optional(),
  },
  returns: zid('comments'),
  handler: async (ctx, args) => {
    // Verify document exists
    const doc = await ctx.table('documents').getX(args.documentId);

    // Verify parent comment if provided
    if (args.parentId) {
      const parent = await ctx.table('comments').get(args.parentId);
      if (!parent || parent.documentId !== args.documentId) {
        throw new ConvexError({
          code: 'INVALID_PARENT',
          message: 'Invalid parent comment',
        });
      }
    }

    return await ctx.table('comments').insert({
      documentId: args.documentId,
      userId: ctx.userId,
      content: args.content,
      parentId: args.parentId,
    });
  },
});

export const getCommentsWithUpvotes = createPublicQuery()({
  args: {
    documentId: zid('documents'),
  },
  returns: z.array(
    z.object({
      _id: zid('comments'),
      content: z.string(),
      user: z.object({
        _id: zid('user'),
        name: z.string(),
      }),
      upvoteCount: z.number(),
      hasUpvoted: z.boolean(),
      replies: z.array(z.any()), // Recursive type
    })
  ),
  handler: async (ctx, args) => {
    // Get all comments for document
    const comments = await ctx.table('comments', 'document', (q) =>
      q.eq('documentId', args.documentId)
    );

    // Get users
    const userIds = [...new Set(comments.map((c) => c.userId))];
    const users = await ctx.table('user').getMany(userIds);
    const userMap = new Map(users.map((u) => u && [u._id, u]));

    // Get upvotes
    const commentIds = comments.map((c) => c._id);
    const upvotes = await ctx
      .table('upvotes')
      .filter((q) =>
        q.or(...commentIds.map((id) => q.eq(q.field('commentId'), id)))
      );

    // Build comment tree
    const commentMap = new Map<Id<'comments'>, any>();
    const rootComments: any[] = [];

    // First pass: create all comments
    for (const comment of comments) {
      const upvoteCount = upvotes.filter(
        (u) => u.commentId === comment._id
      ).length;
      const hasUpvoted = ctx.userId
        ? upvotes.some(
            (u) => u.commentId === comment._id && u.userId === ctx.userId
          )
        : false;

      const commentData = {
        _id: comment._id,
        content: comment.content,
        user: userMap.get(comment.userId)!,
        upvoteCount,
        hasUpvoted,
        replies: [],
      };

      commentMap.set(comment._id, commentData);

      if (!comment.parentId) {
        rootComments.push(commentData);
      }
    }

    // Second pass: build tree
    for (const comment of comments) {
      if (comment.parentId) {
        const parent = commentMap.get(comment.parentId);
        if (parent) {
          parent.replies.push(commentMap.get(comment._id));
        }
      }
    }

    return rootComments;
  },
});
```

## Example: Skill Progress Tracking

### Schema

```typescript
// Add to schema.ts
progress: defineEnt({
  userId: v.id('user'),
  skillId: v.id('skills'),
  level: v.number(),
  completedAt: v.optional(v.number()),
})
  .index('user', ['userId'])
  .index('skill', ['skillId'])
  .index('user_skill', ['userId', 'skillId']),
```

### Implementation

```typescript
// convex/progress.ts
export const updateProgress = createAuthMutation()({
  args: {
    skillId: zid('skills'),
    level: z.number().min(0).max(100),
  },
  returns: z.object({
    progress: z.number(),
    justCompleted: z.boolean(),
  }),
  handler: async (ctx, args) => {
    // Get or create progress
    const existing = await ctx
      .table('progress', 'user_skill', (q) =>
        q.eq('userId', ctx.userId).eq('skillId', args.skillId)
      )
      .unique();

    const wasCompleted = existing?.completedAt !== undefined;
    const isNowCompleted = args.level >= 100;

    if (existing) {
      await existing.patch({
        level: args.level,
        completedAt:
          isNowCompleted && !wasCompleted ? Date.now() : existing.completedAt,
      });
    } else {
      await ctx.table('progress').insert({
        userId: ctx.userId,
        skillId: args.skillId,
        level: args.level,
        completedAt: isNowCompleted ? Date.now() : undefined,
      });
    }

    return {
      progress: args.level,
      justCompleted: !wasCompleted && isNowCompleted,
    };
  },
});

export const getUserProgress = createAuthQuery()({
  args: {},
  returns: z.array(
    z.object({
      skill: z.object({
        _id: zid('skills'),
        name: z.string(),
        category: z.string(),
      }),
      progress: z.number(),
      completedAt: z.number().optional(),
    })
  ),
  handler: async (ctx) => {
    // Get all progress for user
    const progressRecords = await ctx.table('progress', 'user', (q) =>
      q.eq('userId', ctx.userId)
    );

    // Get skill details
    const skillIds = progressRecords.map((p) => p.skillId);
    const skills = await ctx.table('skills').getMany(skillIds);

    return progressRecords
      .map((progress) => {
        const skill = skills.find((s) => s?._id === progress.skillId);
        if (!skill) return null;

        return {
          skill: {
            _id: skill._id,
            name: skill.name,
            category: skill.category,
          },
          progress: progress.level,
          completedAt: progress.completedAt,
        };
      })
      .filter((p) => p !== null) as any;
  },
});
```
