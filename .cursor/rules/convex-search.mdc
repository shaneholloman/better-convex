---
description: Guidelines for implementing full-text search in Convex applications
globs: **/*.ts,**/*.tsx
alwaysApply: false
---

# Convex Full-Text Search

**IMPORTANT**: This document follows the optimization guidelines from [convex-optimize.mdc](mdc:.cursor/rules/convex-optimize.mdc). Key principles:

- Never use post-filtering with pagination (use streams instead)
- Always limit results with `.take()`
- Use indexes for filtering when possible
- For complex filtering with search, use streams from `convex-helpers`

## Basic Search Setup

### Schema with Search Index

```typescript
// convex/schema.ts
import { defineEnt, defineEntSchema, getEntDefinitions } from 'convex-ents';
import { v } from 'convex/values';

const schema = defineEntSchema({
  articles: defineEnt({
    title: v.string(),
    content: v.string(),
    author: v.string(),
    tags: v.array(v.string()),
    category: v.string(),
    publishedAt: v.number(),
  })
    .searchIndex('search_content', {
      searchField: 'content',
      filterFields: ['category', 'author'],
    })
    .searchIndex('search_title', {
      searchField: 'title',
    })
    .index('category', ['category'])
    .index('author', ['author']),
});

export default schema;
export const entDefinitions = getEntDefinitions(schema);
```

## Search Queries

### Basic Search

```typescript
// convex/search.ts
import { createPublicQuery } from './functions';
import { z } from 'zod';

export const searchArticles = createPublicQuery()({
  args: {
    query: z.string(),
    limit: z.number().min(1).max(100).default(10),
  },
  returns: z.array(
    z.object({
      _id: zid('articles'),
      _score: z.number(),
      title: z.string(),
      content: z.string(),
      author: z.string(),
    })
  ),
  handler: async (ctx, args) => {
    const results = await ctx
      .table('articles')
      .search('search_content', (q) => q.search('content', args.query))
      .take(args.limit);

    return results;
  },
});
```

### Search with Filters

```typescript
export const searchByCategory = createPublicQuery()({
  args: {
    query: z.string(),
    category: z.string(),
    limit: z.number().min(1).max(100).default(10),
  },
  returns: z.array(
    z.object({
      _id: zid('articles'),
      _score: z.number(),
      title: z.string(),
      content: z.string(),
      category: z.string(),
    })
  ),
  handler: async (ctx, args) => {
    const results = await ctx
      .table('articles')
      .search('search_content', (q) =>
        q.search('content', args.query).eq('category', args.category)
      )
      .take(args.limit);

    return results;
  },
});
```

### Multiple Filter Fields

```typescript
// IMPORTANT: Search indexes only support equality filters on filterFields
// For range queries (like date ranges), use regular indexes or streams

export const advancedSearch = createPublicQuery()({
  args: {
    query: z.string(),
    filters: z.object({
      category: z.string().optional(),
      author: z.string().optional(),
      // Date filtering requires a different approach
      dateRange: z.enum(['today', 'week', 'month', 'all']).optional(),
    }),
    limit: z.number().min(1).max(100).default(20),
  },
  returns: z.array(
    z.object({
      _id: zid('articles'),
      _score: z.number(),
      title: z.string(),
      content: z.string(),
      author: z.string(),
      category: z.string(),
      publishedAt: z.number(),
    })
  ),
  handler: async (ctx, args) => {
    // For date filtering with search, you have options:

    // Option 1: If search is optional, use index for date filtering
    if (
      !args.query &&
      args.filters.dateRange &&
      args.filters.dateRange !== 'all'
    ) {
      const now = Date.now();
      const ranges = {
        today: now - 24 * 60 * 60 * 1000,
        week: now - 7 * 24 * 60 * 60 * 1000,
        month: now - 30 * 24 * 60 * 60 * 1000,
      };

      return await ctx
        .table('articles', 'publishedAt', (q) =>
          q.gte('publishedAt', ranges[args.filters.dateRange])
        )
        .order('desc')
        .take(args.limit);
    }

    // Option 2: Use search with available filter fields
    const results = await ctx
      .table('articles')
      .search('search_content', (q) => {
        let search = q.search('content', args.query);

        if (args.filters.category) {
          search = search.eq('category', args.filters.category);
        }
        if (args.filters.author) {
          search = search.eq('author', args.filters.author);
        }

        return search;
      })
      .take(args.limit);

    return results;
  },
});
```

## Complex Filtering with Search - Limitations

**IMPORTANT:** Streams do NOT support `withSearchIndex()`. Search queries and streams cannot be combined.

### Options for Complex Filtering with Search:

1. **Use search with available filterFields** (recommended when possible):

```typescript
// Add more filterFields to your search index
searchIndex('search_content', {
  searchField: 'content',
  filterFields: ['category', 'author', 'status', 'dateGroup'], // Add what you need
});
```

2. **Separate search and filter concerns**:

```typescript
export const searchOrFilter = createPublicPaginatedQuery()({
  args: {
    query: z.string().optional(),
    category: z.string().optional(),
    startDate: z.number().optional(),
    endDate: z.number().optional(),
  },
  handler: async (ctx, args) => {
    // Option A: If search query provided, use search (limited filtering)
    if (args.query) {
      return await ctx
        .table('articles')
        .search('search_content', (q) => {
          let search = q.search('content', args.query!);
          if (args.category) {
            search = search.eq('category', args.category);
          }
          // Note: Can't do date range filtering in search
          return search;
        })
        .paginate(args.paginationOpts);
    }

    // Option B: Without search, use streams for complex filtering
    return await stream(ctx.db, schema) // Note: streams still require ctx.db
      .query('articles')
      .withIndex('publishedAt', (q) => {
        if (args.startDate) {
          return q.gte('publishedAt', args.startDate);
        }
        return q;
      })
      .filterWith((article) => {
        if (args.category && article.category !== args.category) {
          return false;
        }
        if (args.endDate && article.publishedAt > args.endDate) {
          return false;
        }
        return true;
      })
      .paginate(args.paginationOpts);
  },
});
```

3. **Post-process search results** (only for small result sets):

```typescript
// Only viable if you can limit search results to manageable size
const searchResults = await ctx
  .table('articles')
  .search('search_content', (q) => q.search('content', args.query))
  .take(100); // Limit to prevent memory issues

// Then filter in memory
const filtered = searchResults.filter((article) => {
  return (
    article.publishedAt >= args.startDate && article.publishedAt <= args.endDate
  );
});
```

## Search in Multiple Fields

```typescript
export const searchAllFields = createPublicQuery()({
  args: {
    query: z.string(),
    searchIn: z.enum(['title', 'content', 'both']).default('both'),
  },
  returns: z.array(
    z.object({
      _id: zid('articles'),
      _score: z.number(),
      title: z.string(),
      content: z.string(),
      matchedField: z.enum(['title', 'content']),
    })
  ),
  handler: async (ctx, args) => {
    const results: any[] = [];

    if (args.searchIn === 'title' || args.searchIn === 'both') {
      const titleResults = await ctx
        .table('articles')
        .search('search_title', (q) => q.search('title', args.query))
        .take(10);

      results.push(
        ...titleResults.map((r) => ({
          ...r,
          matchedField: 'title' as const,
        }))
      );
    }

    if (args.searchIn === 'content' || args.searchIn === 'both') {
      const contentResults = await ctx
        .table('articles')
        .search('search_content', (q) => q.search('content', args.query))
        .take(10);

      results.push(
        ...contentResults.map((r) => ({
          ...r,
          matchedField: 'content' as const,
        }))
      );
    }

    // Remove duplicates and sort by score
    const uniqueResults = Array.from(
      new Map(results.map((r) => [r._id, r])).values()
    );

    return uniqueResults.sort((a, b) => (b._score || 0) - (a._score || 0));
  },
});
```

## Paginated Search

```typescript
export const paginatedSearch = createPublicPaginatedQuery()({
  args: {
    query: z.string(),
    category: z.string().optional(),
  },
  handler: async (ctx, args) => {
    return await ctx
      .table('articles')
      .search('search_content', (q) => {
        let search = q.search('content', args.query);
        if (args.category) {
          search = search.eq('category', args.category);
        }
        return search;
      })
      .paginate(args.paginationOpts);
  },
});
```

## Search Suggestions / Autocomplete

```typescript
// Schema for suggestions - add to existing schema
searchSuggestions: defineEnt({
  term: v.string(),
  count: v.number(),
})
  .index('term', ['term'])
  .index('count', ['count']),

// Track search terms
export const trackSearch = createInternalMutation()({
  args: {
    term: z.string().toLowerCase(),
  },
  returns: z.null(),
  handler: async (ctx, args) => {
    const existing = await ctx
      .table('searchSuggestions', 'term', (q) => q.eq('term', args.term))
      .unique();

    if (existing) {
      await ctx.table('searchSuggestions').getX(existing._id).patch({
        count: existing.count + 1,
      });
    } else {
      await ctx.table('searchSuggestions').insert({
        term: args.term,
        count: 1,
      });
    }

    return null;
  },
});

// Get suggestions
export const getSuggestions = createPublicQuery()({
  args: {
    prefix: z.string().toLowerCase(),
    limit: z.number().min(1).max(10).default(5),
  },
  returns: z.array(
    z.object({
      term: z.string(),
      count: z.number(),
    })
  ),
  handler: async (ctx, args) => {
    // Note: For prefix matching, consider:
    // 1. Adding a dedicated prefix search index
    // 2. Using a trie data structure in a separate table
    // 3. For small datasets (<1000), this approach is acceptable

    const suggestions = await ctx
      .table('searchSuggestions', 'count')
      .order('desc')
      .take(100); // Limit to reasonable amount

    // Post-filter for prefix matching (acceptable for small datasets)
    return suggestions
      .filter((s) => s.term.startsWith(args.prefix))
      .slice(0, args.limit);
  },
});
```

## Fuzzy Search Pattern

Since Convex doesn't have built-in fuzzy search, implement approximate matching:

```typescript
// Helper function for fuzzy matching
function calculateSimilarity(str1: string, str2: string): number {
  const longer = str1.length > str2.length ? str1 : str2;
  const shorter = str1.length > str2.length ? str2 : str1;

  if (longer.length === 0) return 1.0;

  const editDistance = levenshteinDistance(longer, shorter);
  return (longer.length - editDistance) / longer.length;
}

function levenshteinDistance(str1: string, str2: string): number {
  const matrix: number[][] = [];

  for (let i = 0; i <= str2.length; i++) {
    matrix[i] = [i];
  }

  for (let j = 0; j <= str1.length; j++) {
    matrix[0][j] = j;
  }

  for (let i = 1; i <= str2.length; i++) {
    for (let j = 1; j <= str1.length; j++) {
      if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
        matrix[i][j] = matrix[i - 1][j - 1];
      } else {
        matrix[i][j] = Math.min(
          matrix[i - 1][j - 1] + 1,
          matrix[i][j - 1] + 1,
          matrix[i - 1][j] + 1
        );
      }
    }
  }

  return matrix[str2.length][str1.length];
}

export const fuzzySearch = createPublicQuery()({
  args: {
    query: z.string(),
    threshold: z.number().min(0).max(1).default(0.7),
    field: z.enum(['title', 'author']),
  },
  returns: z.array(
    z.object({
      _id: zid('articles'),
      title: z.string(),
      author: z.string(),
      similarity: z.number(),
    })
  ),
  handler: async (ctx, args) => {
    // IMPORTANT: This is a client-side fuzzy search pattern
    // Only suitable for small datasets. For production consider:
    // 1. Using a dedicated search service (Algolia, Elasticsearch)
    // 2. Pre-computing similar terms during write operations
    // 3. Using vector embeddings for semantic search

    const articles = await ctx.table('articles').take(1000);

    const results = articles
      .map((article) => {
        const fieldValue = article[args.field];
        const similarity = calculateSimilarity(
          args.query.toLowerCase(),
          fieldValue.toLowerCase()
        );

        return {
          _id: article._id,
          title: article.title,
          author: article.author,
          similarity,
        };
      })
      .filter((r) => r.similarity >= args.threshold)
      .sort((a, b) => b.similarity - a.similarity)
      .slice(0, 20);

    return results;
  },
});
```

## Search with Highlighting

```typescript
// Helper to highlight search terms
function highlightTerms(text: string, query: string): string {
  const terms = query.toLowerCase().split(/\s+/);
  let highlighted = text;

  terms.forEach((term) => {
    const regex = new RegExp(`(${term})`, 'gi');
    highlighted = highlighted.replace(regex, '<mark>$1</mark>');
  });

  return highlighted;
}

export const searchWithHighlight = createPublicQuery()({
  args: {
    query: z.string(),
    limit: z.number().min(1).max(20).default(10),
  },
  returns: z.array(
    z.object({
      _id: zid('articles'),
      title: z.string(),
      titleHighlighted: z.string(),
      excerpt: z.string(),
      excerptHighlighted: z.string(),
    })
  ),
  handler: async (ctx, args) => {
    const results = await ctx
      .table('articles')
      .search('search_content', (q) => q.search('content', args.query))
      .take(args.limit);

    return results.map((article) => {
      // Create excerpt around first match
      const lowerContent = article.content.toLowerCase();
      const lowerQuery = args.query.toLowerCase();
      const matchIndex = lowerContent.indexOf(lowerQuery);

      let excerpt = article.content;
      if (matchIndex !== -1) {
        const start = Math.max(0, matchIndex - 50);
        const end = Math.min(article.content.length, matchIndex + 150);
        excerpt = '...' + article.content.slice(start, end) + '...';
      } else {
        excerpt = article.content.slice(0, 200) + '...';
      }

      return {
        _id: article._id,
        title: article.title,
        titleHighlighted: highlightTerms(article.title, args.query),
        excerpt,
        excerptHighlighted: highlightTerms(excerpt, args.query),
      };
    });
  },
});
```

## Search Analytics

```typescript
// Track what users search for
export const logSearch = createInternalMutation()({
  args: {
    userId: zid('user').optional(),
    query: z.string(),
    resultCount: z.number(),
    clickedResultId: zid('articles').optional(),
  },
  returns: z.null(),
  handler: async (ctx, args) => {
    await ctx.table('searchLogs').insert({
      userId: args.userId,
      query: args.query.toLowerCase(),
      resultCount: args.resultCount,
      clickedResultId: args.clickedResultId,
      timestamp: Date.now(),
    });

    // Update search suggestions
    await ctx.scheduler.runAfter(0, internal.search.trackSearch, {
      term: args.query.toLowerCase(),
    });

    return null;
  },
});

// Get popular searches
export const getPopularSearches = createPublicQuery()({
  args: {
    timeframe: z.enum(['day', 'week', 'month']).default('week'),
    limit: z.number().min(1).max(20).default(10),
  },
  returns: z.array(
    z.object({
      query: z.string(),
      count: z.number(),
    })
  ),
  handler: async (ctx, args) => {
    const cutoff =
      Date.now() -
      {
        day: 24 * 60 * 60 * 1000,
        week: 7 * 24 * 60 * 60 * 1000,
        month: 30 * 24 * 60 * 60 * 1000,
      }[args.timeframe];

    // Use index for timestamp filtering if this becomes a performance issue
    const logs = await ctx
      .table('searchLogs')
      .filter((q) => q.gte(q.field('timestamp'), cutoff))
      .take(1000); // Limit for safety

    // Count occurrences
    const counts = new Map<string, number>();
    logs.forEach((log) => {
      counts.set(log.query, (counts.get(log.query) || 0) + 1);
    });

    // Sort and return top queries
    return Array.from(counts.entries())
      .map(([query, count]) => ({ query, count }))
      .sort((a, b) => b.count - a.count)
      .slice(0, args.limit);
  },
});
```

## Best Practices

1. **Create appropriate indexes** - Each search field needs its own search index
2. **Limit search results** - Use `.take()` to avoid returning too many results
3. **Consider performance** - Search indexes have overhead, don't over-index
4. **Filter before searching when possible** - Use regular indexes first, then search
5. **Track search queries** - Helps improve search relevance and suggestions
6. **Implement pagination** - For large result sets, use paginated queries
7. **Handle empty queries** - Decide whether to return all results or none
8. **Normalize search terms** - Convert to lowercase for consistency
9. **Consider relevance** - Sort by `_score` for best matches first
10. **Provide search analytics** - Track what users search for to improve content
