---
description: Guidelines and best practices for using the Convex Aggregate component for efficient count and sum calculations
globs: **/*.ts,**/*.tsx
alwaysApply: false
---

# Convex Aggregate guidelines

## üö® CRITICAL: Always Use Triggers

**NEVER manually update aggregates in mutations. ALWAYS use triggers for automatic aggregate maintenance.**

```typescript
// ‚úÖ CORRECT: Register trigger once
triggers.register('scores', scoresAggregate.trigger());

// ‚ùå WRONG: Manual updates in every mutation
await scoresAggregate.insert(ctx, doc);
await scoresAggregate.delete(ctx, doc);
```

## Overview

The Convex Aggregate component provides O(log(n))-time lookups for efficient aggregation operations, replacing naive O(n) operations like collect or SQL `COUNT(*)`.

## Installation

- Install the Aggregate component:

  ```bash
  npm install @convex-dev/aggregate
  ```

- Configure in `convex/convex.config.ts`:

  ```typescript
  import { defineApp } from 'convex/server';
  import aggregate from '@convex-dev/aggregate/convex.config';

  const app = defineApp();
  app.use(aggregate);
  export default app;
  ```

## Core concepts

### When to use Aggregates

- **Count operations**: Total count of documents without fetching all
- **Sum calculations**: Efficient sum of numeric values
- **Statistical queries**: Percentiles, averages, rankings
- **Paginated access**: Offset-based pagination
- **Random access**: Access document at specific index

### Aggregate types

- **TableAggregate**: For aggregating data from Convex tables
- **DirectAggregate**: For aggregating data not stored in tables

## TableAggregate setup

### Basic configuration

```typescript
import { components } from './_generated/api';
import { DataModel } from './_generated/dataModel';
import { TableAggregate } from '@convex-dev/aggregate';

// Simple aggregate by creation time
const aggregate = new TableAggregate<{
  Key: number;
  DataModel: DataModel;
  TableName: 'scores';
}>(components.aggregate, {
  sortKey: (doc) => doc.score,
  sumValue: (doc) => doc.points, // Optional: for sum calculations
});
```

### Advanced configuration with namespaces

```typescript
// Namespace by game, sort by score
const leaderboardByGame = new TableAggregate<{
  Namespace: Id<'games'>;
  Key: number;
  DataModel: DataModel;
  TableName: 'scores';
}>(components.leaderboardByGame, {
  namespace: (doc) => doc.gameId,
  sortKey: (doc) => doc.score,
});
```

### Multiple aggregates

- Define multiple instances in `convex.config.ts`:
  ```typescript
  app.use(aggregate, { name: 'aggregateScores' });
  app.use(aggregate, { name: 'aggregateByGame' });
  app.use(aggregate, { name: 'aggregateByUser' });
  ```

## Key selection patterns

### Simple keys

```typescript
// By number (e.g., scores)
sortKey: (doc) => doc.score;

// By string (e.g., usernames)
sortKey: (doc) => doc.username;

// By timestamp
sortKey: (doc) => doc._creationTime;

// No sorting (random access by _id)
sortKey: (doc) => null;
```

### Composite keys for grouping

```typescript
// Group by game, then username, then score
sortKey: (doc) => [doc.game, doc.username, doc.score];

// Query with prefix
const gameCount = await aggregate.count(ctx, {
  prefix: [game],
});
const userGameCount = await aggregate.count(ctx, {
  prefix: [game, username],
});
```

### Key ordering considerations

- **CRITICAL**: Sort order matters for composite keys
- `[game, username, score]` allows querying by game or game+username
- `[game, score]` allows finding highest score per game
- `[username, score]` allows finding user's highest score

### Bounds requirement for null keys

**IMPORTANT**: When using `sortKey: () => null`, the aggregate requires `bounds` to be explicitly provided, even if empty:

```typescript
// Aggregate with null key (no sorting)
const countAggregate = new TableAggregate<{
  Key: null;
  DataModel: DataModel;
  TableName: 'items';
}>(components.countAggregate, {
  sortKey: () => null,
});

// ‚ùå WRONG: Missing bounds parameter
const count = await countAggregate.count(ctx, {
  namespace: itemId,
});

// ‚úÖ CORRECT: Include empty bounds for unbounded counting
const count = await countAggregate.count(ctx, {
  namespace: itemId,
  bounds: {} as any,
});
```

This is because aggregates with `null` keys don't have natural ordering, so bounds must be explicitly specified to indicate you want all items.

### TypeScript "Type instantiation is excessively deep" error

If you encounter the TypeScript error "Type instantiation is excessively deep and possibly infinite" when using aggregate methods, you have several options:

```typescript
// ‚ùå May cause TypeScript error with complex types
const count = await aggregate.count(ctx, {
  namespace: itemId,
  bounds: {} as any,
});

// ‚úÖ Use bounds with type assertion (pragmatic solution)
const count = await aggregate.count(ctx, {
  namespace: itemId,
  bounds: {} as any,
});
```

This is a TypeScript limitation when dealing with deeply nested generic types in the aggregate component. The `bounds: {} as any` approach is acceptable when other solutions don't resolve the error, as the bounds parameter is correctly typed at runtime.

## Write operations with triggers (RECOMMENDED)

**üö® CRITICAL: ALWAYS use triggers for aggregate maintenance. Never update aggregates manually in mutations.**

### Setup triggers

```typescript
// In convex/triggers.ts
import { Triggers } from 'convex-helpers/server/triggers';
import { leaderboardByGame } from './aggregates';

export const triggers = new Triggers<DataModel>();

// Register aggregate trigger - handles ALL insert/update/delete automatically
triggers.register('scores', leaderboardByGame.trigger());
```

### Insert operations (with triggers)

```typescript
export const addScore = createAuthMutation()({
  args: {
    gameId: zid('games'),
    score: z.number().positive(),
  },
  returns: zid('scores'),
  handler: async (ctx, args) => {
    // Just insert - trigger handles aggregate automatically!
    const id = await ctx.table('scores').insert({
      gameId: args.gameId,
      userId: ctx.userId,
      score: args.score,
      timestamp: Date.now(),
    });

    return id;
  },
});
```

### Update operations (with triggers)

```typescript
export const updateScore = createAuthMutation()({
  args: {
    scoreId: zid('scores'),
    newScore: z.number().positive(),
  },
  returns: z.null(),
  handler: async (ctx, args) => {
    // Just update - trigger handles aggregate automatically!
    await ctx
      .table('scores')
      .getX(args.scoreId)
      .patch({ score: args.newScore });

    return null;
  },
});
```

### Delete operations (with triggers)

```typescript
export const deleteScore = createAuthMutation()({
  args: {
    scoreId: zid('scores'),
  },
  returns: z.null(),
  handler: async (ctx, args) => {
    // Just delete - trigger handles aggregate automatically!
    await ctx.table('scores').getX(args.scoreId).delete();

    return null;
  },
});
```

### Multiple aggregates on same table

```typescript
// When multiple aggregates use the same table, register each separately
triggers.register('follows', aggregateUserFollowsByFollowing.trigger());
triggers.register('follows', aggregateUserFollowsByFollower.trigger());
```

### Benefits of triggers

- **Automatic**: Aggregates always stay in sync
- **Clean code**: Mutations only contain business logic
- **No manual updates**: Can't forget to update aggregates

## Read operations

### Count operations

```typescript
export const getStats = createPublicQuery()({
  args: {
    gameId: zid('games').optional(),
    username: z.string().optional(),
  },
  returns: z.object({
    totalCount: z.number(),
    gameCount: z.number().optional(),
    userGameCount: z.number().optional(),
  }),
  handler: async (ctx, args) => {
    // Total count across all games
    const totalCount = await leaderboardByGame.count(ctx);

    // Count for specific game
    const gameCount = args.gameId
      ? await leaderboardByGame.count(ctx, { namespace: args.gameId })
      : undefined;

    // Count for user in game
    const userGameCount =
      args.gameId && args.username
        ? await leaderboardByGame.count(ctx, {
            namespace: args.gameId,
            bounds: { prefix: [args.username] },
          })
        : undefined;

    return { totalCount, gameCount, userGameCount };
  },
});
```

### Bounded queries

```typescript
export const getHighScores = createPublicQuery()({
  args: {
    gameId: zid('games'),
    minScore: z.number().optional(),
    maxScore: z.number().optional(),
  },
  returns: z.object({
    count: z.number(),
    topScore: z.number().nullable(),
  }),
  handler: async (ctx, args) => {
    const bounds = {
      lower: args.minScore
        ? { key: args.minScore, inclusive: true }
        : undefined,
      upper: args.maxScore
        ? { key: args.maxScore, inclusive: true }
        : undefined,
    };

    const count = await leaderboardByGame.count(ctx, {
      namespace: args.gameId,
      bounds,
    });

    const topScore = await leaderboardByGame.max(ctx, {
      namespace: args.gameId,
    });

    return { count, topScore };
  },
});
```

### Statistical operations

```typescript
export const getLeaderboardStats = createPublicQuery()({
  args: {
    gameId: zid('games'),
  },
  returns: z.object({
    average: z.number(),
    p95Score: z.number().nullable(),
    userRank: z.number().nullable(),
  }),
  handler: async (ctx, args) => {
    // Average score
    const sum = await leaderboardByGame.sum(ctx, {
      namespace: args.gameId,
    });
    const count = await leaderboardByGame.count(ctx, {
      namespace: args.gameId,
    });
    const average = count > 0 ? sum / count : 0;

    // 95th percentile
    const p95Index = Math.floor(count * 0.95);
    const p95Result = await leaderboardByGame.at(ctx, p95Index, {
      namespace: args.gameId,
    });
    const p95Score = p95Result?.key ?? null;

    // User ranking for score of 100
    const userRank = await leaderboardByGame.indexOf(ctx, 100, {
      namespace: args.gameId,
    });

    return { average, p95Score, userRank };
  },
});
```

### Pagination with at()

```typescript
export const paginatedScores = createPublicPaginatedQuery()({
  args: {
    gameId: zid('games'),
    pageSize: z.number().min(1).max(100).default(50),
    page: z.number().min(0).default(0),
  },
  handler: async (ctx, args) => {
    const offset = args.page * args.pageSize;

    // Get the key at offset
    const { key } = await leaderboardByGame.at(ctx, offset, {
      namespace: args.gameId,
    });

    // Query documents starting from that key
    const scores = await ctx
      .table('scores', 'game_score', (q) =>
        q.eq('gameId', args.gameId).gte('score', key)
      )
      .take(args.pageSize);

    const totalCount = await leaderboardByGame.count(ctx, {
      namespace: args.gameId,
    });

    return {
      page: scores,
      isDone: offset + args.pageSize >= totalCount,
      continueCursor: null, // Not used in offset pagination
    };
  },
});
```

## Advanced patterns

### Random access

```typescript
const randomize = new TableAggregate<{
  Key: null;
  DataModel: DataModel;
  TableName: 'songs';
}>(components.randomize, {
  sortKey: (doc) => null, // No sorting, random by _id
});

export const getRandomSong = createPublicQuery()({
  returns: z
    .object({
      id: zid('songs'),
      title: z.string(),
    })
    .nullable(),
  handler: async (ctx) => {
    const count = await randomize.count(ctx);
    if (count === 0) return null;

    const randomIndex = Math.floor(Math.random() * count);
    const result = await randomize.at(ctx, randomIndex);

    if (!result) return null;

    const song = await ctx.table('songs').get(result.doc._id);
    return song ? { id: song._id, title: song.title } : null;
  },
});
```

### Multiple sort orders

```typescript
// Aggregate by score for rankings
const byScore = new TableAggregate<{
  Key: number;
  DataModel: DataModel;
  TableName: 'players';
}>(components.byScore, {
  sortKey: (doc) => doc.score,
});

// Aggregate by username for alphabetical listing
const byUsername = new TableAggregate<{
  Key: string;
  DataModel: DataModel;
  TableName: 'players';
}>(components.byUsername, {
  sortKey: (doc) => doc.username,
});

// Aggregate by last active for activity tracking
const byActivity = new TableAggregate<{
  Key: number;
  DataModel: DataModel;
  TableName: 'players';
}>(components.byActivity, {
  sortKey: (doc) => doc.lastActiveAt,
});
```

### Composite aggregation patterns

```typescript
// Leaderboard with multiple dimensions
const leaderboard = new TableAggregate<{
  Namespace: string; // game mode
  Key: [string, number, number]; // [region, score, timestamp]
  DataModel: DataModel;
  TableName: 'matches';
}>(components.leaderboard, {
  namespace: (doc) => doc.gameMode,
  sortKey: (doc) => [doc.region, doc.score, doc.timestamp],
});

// Regional high scores
const regionalHighScore = await leaderboard.max(ctx, {
  namespace: 'ranked',
  bounds: { prefix: ['us-west'] },
});

// Count players per region
const usWestCount = await leaderboard.count(ctx, {
  namespace: 'ranked',
  bounds: { prefix: ['us-west'] },
});
```

## DirectAggregate usage

### Setup

```typescript
import { DirectAggregate } from '@convex-dev/aggregate';

const aggregate = new DirectAggregate<{
  Key: number;
  Id: string;
}>(components.aggregate);
```

### Operations

```typescript
export const trackEvent = createAuthMutation()({
  args: {
    eventType: z.string(),
    value: z.number(),
  },
  returns: z.null(),
  handler: async (ctx, args) => {
    const id = `${ctx.userId}-${Date.now()}`;

    // Insert with sumValue for aggregation
    await aggregate.insert(ctx, {
      key: Date.now(),
      id,
      sumValue: args.value,
    });

    return null;
  },
});

export const updateEvent = createAuthMutation()({
  args: {
    eventId: z.string(),
    newValue: z.number(),
  },
  returns: z.null(),
  handler: async (ctx, args) => {
    // Replace existing entry
    await aggregate.replace(
      ctx,
      { key: oldTimestamp, id: args.eventId },
      { key: Date.now(), id: args.eventId, sumValue: args.newValue }
    );

    return null;
  },
});
```

## Migration and maintenance

### Initial backfill

```typescript
export const backfillAggregate = createInternalMutation()({
  args: {
    cursor: z.string().nullable().default(null),
    batchSize: z.number().default(100),
  },
  returns: z.object({
    done: z.boolean(),
    processed: z.number(),
    nextCursor: z.string().nullable(),
  }),
  handler: async (ctx, args) => {
    const results = await ctx
      .table('scores')
      .paginate({ numItems: args.batchSize, cursor: args.cursor });

    // Use insertIfDoesNotExist for idempotent backfill
    for (const doc of results.page) {
      await leaderboardByGame.insertIfDoesNotExist(ctx, doc);
    }

    return {
      done: results.isDone,
      processed: results.page.length,
      nextCursor: results.continueCursor,
    };
  },
});
```

### Repair operations

```typescript
export const repairAggregate = createInternalMutation()({
  args: {
    clear: z.boolean().default(false),
  },
  returns: z.null(),
  handler: async (ctx, args) => {
    if (args.clear) {
      // Clear and rebuild
      await leaderboardByGame.clear(ctx);

      // Rebuild from source of truth
      const scores = await ctx.table('scores');
      for (const score of scores) {
        await leaderboardByGame.insert(ctx, score);
      }
    } else {
      // Incremental repair
      const aggregateDocs = await leaderboardByGame.paginate(ctx, {
        numItems: 1000,
        cursor: null,
      });

      // Compare with source and fix discrepancies
      // Implementation depends on specific requirements
    }

    return null;
  },
});
```

### Trigger setup example

```typescript
// convex/triggers.ts
import { Triggers } from 'convex-helpers/server/triggers';
import {
  aggregateCharacterStars,
  aggregateUserFollowsByFollowing,
  aggregateUserFollowsByFollower,
  aggregateCharacters,
  // ... other aggregates
} from './aggregates';

export const triggers = new Triggers<DataModel>();

// Register all your aggregates
triggers.register('characterStars', aggregateCharacterStars.trigger());
triggers.register('follows', aggregateUserFollowsByFollowing.trigger());
triggers.register('follows', aggregateUserFollowsByFollower.trigger());
triggers.register('characters', aggregateCharacters.trigger());
// ... register other aggregates

// CASCADE DELETES - Triggers still work!
triggers.register('user', async (ctx, change) => {
  if (change.operation === 'delete') {
    // Just delete - aggregates update automatically
    const characters = await ctx.table('characters', 'userId', (q) =>
      q.eq('userId', change.id)
    );

    for (const char of characters) {
      await ctx.table('characters').getX(char._id).delete(); // Trigger fires here!
    }
  }
});
```

## Performance optimization

### Namespace vs prefix patterns

```typescript
// ‚úÖ GOOD: Namespace for complete isolation
const byUser = new TableAggregate<{
  Namespace: Id<'user'>;
  Key: number;
  DataModel: DataModel;
  TableName: 'activities';
}>(components.byUser, {
  namespace: (doc) => doc.userId,
  sortKey: (doc) => doc.timestamp,
});

// ‚ùå AVOID: Prefix without namespace causes contention
const byUserPrefix = new TableAggregate<{
  Key: [Id<'user'>, number];
  DataModel: DataModel;
  TableName: 'activities';
}>(components.byUserPrefix, {
  sortKey: (doc) => [doc.userId, doc.timestamp],
});
```

### Lazy aggregation configuration

```typescript
// Configure for high-write scenarios
await aggregate.clear(ctx, 32, true); // maxNodeSize: 32, rootLazy: true

// Configure for high-read scenarios
await aggregate.clear(ctx, 16, false); // maxNodeSize: 16, rootLazy: false
```

### Bounded queries for reduced conflicts

```typescript
// ‚úÖ GOOD: Bounded query reduces dependencies
const recentHighScores = await aggregate.count(ctx, {
  bounds: {
    lower: { key: Date.now() - 86400000, inclusive: true }, // Last 24h
  },
});

// ‚ùå AVOID: Unbounded queries cause more conflicts
const allHighScores = await aggregate.count(ctx);
```

## Common patterns

### Leaderboard with user stats

```typescript
export const getUserStats = createAuthQuery()({
  args: {
    gameId: zid('games'),
  },
  returns: z.object({
    highScore: z.number(),
    averageScore: z.number(),
    gamesPlayed: z.number(),
    globalRank: z.number().nullable(),
    percentile: z.number(),
  }),
  handler: async (ctx, args) => {
    // User's scores in this game
    const gameScores = await ctx.table('scores', 'user_game', (q) =>
      q.eq('userId', ctx.userId).eq('gameId', args.gameId)
    );

    const highScore = Math.max(...gameScores.map((s) => s.score));
    const averageScore =
      gameScores.reduce((sum, s) => sum + s.score, 0) / gameScores.length;

    // Global stats
    const globalRank = await leaderboardByGame.indexOf(ctx, highScore, {
      namespace: args.gameId,
    });

    const totalPlayers = await leaderboardByGame.count(ctx, {
      namespace: args.gameId,
    });

    const percentile =
      globalRank && totalPlayers > 0
        ? ((totalPlayers - globalRank) / totalPlayers) * 100
        : 0;

    return {
      highScore,
      averageScore,
      gamesPlayed: gameScores.length,
      globalRank,
      percentile,
    };
  },
});
```

### Time-based aggregations

```typescript
const activityByHour = new TableAggregate<{
  Key: [number, string]; // [hour, userId]
  DataModel: DataModel;
  TableName: 'activities';
}>(components.activityByHour, {
  sortKey: (doc) => [
    Math.floor(doc.timestamp / 3600000), // Hour bucket
    doc.userId,
  ],
});

export const getHourlyActivity = createPublicQuery()({
  args: {
    hoursAgo: z.number().min(1).max(24),
  },
  returns: z.array(
    z.object({
      hour: z.number(),
      count: z.number(),
    })
  ),
  handler: async (ctx, args) => {
    const now = Date.now();
    const results = [];

    for (let i = 0; i < args.hoursAgo; i++) {
      const hour = Math.floor((now - i * 3600000) / 3600000);
      const count = await activityByHour.count(ctx, {
        bounds: { prefix: [hour] },
      });
      results.push({ hour, count });
    }

    return results.reverse();
  },
});
```

## Testing patterns

```typescript
import { expect, test } from 'vitest';
import { ConvexTestingHelper } from 'convex-test';

test('aggregate maintains consistency', async () => {
  const t = new ConvexTestingHelper();

  // Insert test data
  const scoreId = await t.mutation(api.scores.addScore, {
    gameId: 'game1',
    score: 100,
  });

  // Verify aggregate
  const stats = await t.query(api.scores.getStats, {
    gameId: 'game1',
  });

  expect(stats.gameCount).toBe(1);
  expect(stats.totalCount).toBeGreaterThanOrEqual(1);

  // Update and verify
  await t.mutation(api.scores.updateScore, {
    scoreId,
    newScore: 200,
  });

  const newStats = await t.query(api.scores.getStats, {
    gameId: 'game1',
  });

  expect(newStats.gameCount).toBe(1); // Count unchanged
});
```

## Best practices

### Always use triggers for consistency

```typescript
// ‚úÖ BEST: Use triggers (automatic)
triggers.register('scores', scoresAggregate.trigger());
// Then in mutations:
await ctx.table('scores').insert(data); // That's it!

// ‚ùå AVOID: Manual updates (error-prone)
const id = await ctx.table('scores').insert(data);
const doc = await ctx.table('scores').get(id);
await aggregate.insert(ctx, doc!); // Easy to forget!

// ‚ùå WORST: Forgetting aggregate update
await ctx.table('scores').insert(data);
// Missing aggregate update - data inconsistency!
```

### Choose appropriate keys

```typescript
// ‚úÖ GOOD: Keys match query patterns
sortKey: (doc) => [doc.category, doc.priority, doc.createdAt];
// Allows: by category, by category+priority, full ordering

// ‚ùå BAD: Keys don't match access patterns
sortKey: (doc) => doc.internalId;
// Can't query by meaningful attributes
```

### Use namespaces for isolation

```typescript
// ‚úÖ GOOD: Namespace prevents interference
namespace: (doc) => doc.tenantId,
sortKey: (doc) => doc.score

// ‚ùå BAD: No namespace causes contention
sortKey: (doc) => [doc.tenantId, doc.score]
```

### Handle edge cases

```typescript
export const safeDivision = createPublicQuery()({
  returns: z.number(),
  handler: async (ctx) => {
    const sum = await aggregate.sum(ctx);
    const count = await aggregate.count(ctx);

    // ‚úÖ GOOD: Handle division by zero
    return count > 0 ? sum / count : 0;
  },
});
```

## Limitations and considerations

- **Document count**: Aggregates work best with millions of documents
- **Update frequency**: High-frequency updates to nearby keys cause contention
- **Key size**: Keep composite keys reasonable (3-4 components max)
- **Namespace count**: Each namespace has overhead, balance isolation vs resources
- **Query patterns**: Design keys based on actual query needs, not hypothetical ones

## Error handling

```typescript
export const robustAggregate = createAuthMutation()({
  args: {
    scoreId: zid('scores'),
  },
  returns: z.null(),
  handler: async (ctx, args) => {
    const doc = await ctx.table('scores').getX(args.scoreId);

    try {
      await aggregate.delete(ctx, doc);
    } catch (error) {
      // Handle aggregate-specific errors
      if (error.message.includes('not found in aggregate')) {
        // Document wasn't in aggregate, safe to continue
        console.warn('Document not in aggregate:', args.scoreId);
      } else {
        throw error;
      }
    }

    await ctx.table('scores').getX(args.scoreId).delete();
    return null;
  },
});
```
