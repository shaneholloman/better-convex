---
description: Polar payments with Better Auth for subscriptions and usage billing. Use for checkout flows, subscription management, webhooks, and usage metering.
globs: convex/polar*.ts,convex/auth.ts,src/**/*billing*.tsx,src/**/*checkout*.tsx
alwaysApply: false
---

# Convex Polar with Better Auth

## Architecture

**Integration:** Better Auth Polar plugin → Webhooks → Convex mutations → Database
**Key Files:** `convex/auth.ts`, `convex/polar/` directory with specialized modules

## File Structure

````
convex/polar/
├── polar.ts          # Polar client and core utilities
├── customer.ts       # Customer management
├── subscription.ts   # Subscription operations
├── credit.ts        # Organization credit management
├── product.ts       # Product configuration
├── helpers.ts       # Helper functions
└── polyfills.ts     # Required polyfills for Convex

## Schema Integration

**Edit:** `convex/schema.ts`

```typescript
// User table - Polar customer ID
user: defineEnt({
  // ... other fields ...
})
  .field('customerId', v.optional(v.string()), { index: true }), // Polar customer ID

// Organization table - Billing fields
organization: defineEnt({
  // ... other fields ...
  // Add your organization-specific billing fields here
})
  .edge('subscription', { to: 'subscriptions', ref: true }),

// Subscriptions table - Organization-based
subscriptions: defineEnt({
  createdAt: v.string(),
  status: v.string(),  // 'active', 'canceled', 'trialing', 'past_due'
  currentPeriodStart: v.string(),
  currentPeriodEnd: v.optional(v.union(v.string(), v.null())),
  cancelAtPeriodEnd: v.boolean(),
  productId: v.string(),
  metadata: v.record(v.string(), v.any()),
})
  .field('subscriptionId', v.string(), { unique: true })
  .field('organizationId', v.id('organization'))  // Organization-based subscriptions
  .edge('organization', { to: 'organization', field: 'organizationId' })
  .edge('user', { to: 'user', field: 'userId' })  // User who created subscription
  .index('organizationId_status', ['organizationId', 'status'])
````

## Better Auth Configuration

**Edit:** `convex/auth.ts`

```typescript
// Add polyfills for Convex environment
import "./polar/polyfills";

import {
  polar,
  checkout,
  portal,
  usage,
  webhooks,
} from "@polar-sh/better-auth";
import { Polar } from "@polar-sh/sdk";

// User creation trigger - Create Polar customer via scheduler
authClient = createClient({
  triggers: {
    user: {
      onCreate: async (ctx, user) => {
        // ... create main character and personal organization ...

        // Create Polar customer asynchronously
        await ctx.scheduler.runAfter(
          0,
          internal.polar.customer.createCustomer,
          {
            betterAuthUserId: user._id,
            email: user.email,
            name: user.name || user.username,
            userId: user._id,
          }
        );
      },
    },
  },
});

// Polar plugin configuration
plugins: [
  polar({
    client: new Polar({
      accessToken: process.env.POLAR_ACCESS_TOKEN!,
      server:
        process.env.POLAR_SERVER === "production" ? "production" : "sandbox",
    }),
    // NO createCustomerOnSignUp - handled via scheduler
    use: [
      checkout({
        authenticatedUsersOnly: true,
        products: [
          { productId: process.env.POLAR_PRODUCT_PREMIUM!, slug: "premium" },
          { productId: process.env.POLAR_PRODUCT_CREDITS!, slug: "credits" },
          // Team product commented out for now
          // { productId: process.env.POLAR_PRODUCT_TEAM!, slug: 'team' },
        ],
        successUrl: "/success?checkout_id={CHECKOUT_ID}",
        theme: "light",
      }),
      portal(), // Customer portal management
      usage(), // Usage-based billing
      webhooks({
        secret: process.env.POLAR_WEBHOOK_SECRET!,
        onCustomerCreated: async (payload) => {
          const userId = payload?.data.metadata.userId as
            | Id<"user">
            | undefined;
          if (!userId) return;

          await (ctx as ActionCtx).runMutation(
            internal.polar.customer.updateUserPolarCustomerId,
            {
              customerId: payload.data.id,
              userId,
            }
          );
        },
        onOrderPaid: async (payload) => {
          // Handle credit purchases
          if (payload.data.productId === process.env.POLAR_PRODUCT_CREDITS) {
            const amountInCents =
              payload.data.netAmount || payload.data.totalAmount || 0;
            const credits = amountInCents; // 1 cent = 1 credit
            const organizationId = payload.data.metadata?.referenceId as
              | Id<"organization">
              | undefined;

            if (credits > 0 && organizationId) {
              await (ctx as ActionCtx).runMutation(
                internal.polar.credit.addPurchasedCredits,
                { amount: credits, organizationId }
              );
            }
          }
        },
        onSubscriptionCreated: async (payload) => {
          if (!payload.data.customer.metadata.userId) return;

          await (ctx as ActionCtx).runMutation(
            internal.polar.subscription.createSubscription,
            { subscription: convertToDatabaseSubscription(payload.data) }
          );
        },
        onSubscriptionUpdated: async (payload) => {
          if (!payload.data.customer.metadata.userId) return;

          const updated = await (ctx as ActionCtx).runMutation(
            internal.polar.subscription.updateSubscription,
            { subscription: convertToDatabaseSubscription(payload.data) }
          );

          // Reset monthly credits on subscription renewal
          if (updated) {
            const organizationId = payload.data.metadata?.referenceId as
              | Id<"organization">
              | undefined;
            if (organizationId) {
              const product = getProduct(payload.data.productId);
              const monthlyPrice = product?.prices.find(
                (p) => p.recurringInterval === "month"
              );
              const monthlyCreditsInCents = monthlyPrice?.priceAmount ?? 0;

              if (monthlyCreditsInCents > 0) {
                await (ctx as ActionCtx).runMutation(
                  internal.polar.credit.resetMonthlyCredits,
                  { newAmount: monthlyCreditsInCents, organizationId }
                );
              }
            }
          }
        },
      }),
    ],
  }),
];
```

The `webhooks` plugin allows you to invoke handlers for all Polar webhook events:

- `onPayload` - Catch-all handler for any incoming Webhook event
- `onCheckoutCreated` - Triggered when a checkout is created
- `onCheckoutUpdated` - Triggered when a checkout is updated
- `onOrderCreated` - Triggered when an order is created
- `onOrderPaid` - Triggered when an order is paid
- `onOrderRefunded` - Triggered when an order is refunded
- `onRefundCreated` - Triggered when a refund is created
- `onRefundUpdated` - Triggered when a refund is updated
- `onSubscriptionCreated` - Triggered when a subscription is created
- `onSubscriptionUpdated` - Triggered when a subscription is updated
- `onSubscriptionActive` - Triggered when a subscription becomes active
- `onSubscriptionCanceled` - Triggered when a subscription is canceled
- `onSubscriptionRevoked` - Triggered when a subscription is revoked
- `onSubscriptionUncanceled` - Triggered when a subscription cancellation is reversed
- `onProductCreated` - Triggered when a product is created
- `onProductUpdated` - Triggered when a product is updated
- `onOrganizationUpdated` - Triggered when an organization is updated
- `onBenefitCreated` - Triggered when a benefit is created
- `onBenefitUpdated` - Triggered when a benefit is updated
- `onBenefitGrantCreated` - Triggered when a benefit grant is created
- `onBenefitGrantUpdated` - Triggered when a benefit grant is updated
- `onBenefitGrantRevoked` - Triggered when a benefit grant is revoked
- `onCustomerCreated` - Triggered when a customer is created
- `onCustomerUpdated` - Triggered when a customer is updated
- `onCustomerDeleted` - Triggered when a customer is deleted
- `onCustomerStateChanged` - Triggered when a customer state changes

## Customer State Changed Webhook

The `onCustomerStateChanged` webhook provides comprehensive customer state updates including subscriptions, benefits, and meter balances.

### Payload Structure (camelCase)

```typescript
interface CustomerStateChangedPayload {
  type: "customer.state_changed";
  data: {
    // Core customer fields
    id: string; // Polar customer ID
    createdAt: string; // ISO 8601 timestamp
    modifiedAt: string | null;
    deletedAt?: string | null; // If customer was deleted

    // Customer identification
    externalId?: string | null; // Your user ID (e.g., "usr_1337")
    email: string;
    emailVerified: boolean;
    name?: string | null;
    avatarUrl?: string | null; // Gravatar or custom avatar URL

    // Organization
    organizationId?: string; // Polar organization ID

    // Custom data
    metadata: Record<string, any>; // Custom metadata (e.g., { userId: "..." })

    // Billing information
    billingAddress?: {
      line1?: string;
      line2?: string;
      postalCode?: string;
      city?: string;
      state?: string;
      country?: string; // ISO 3166-1 alpha-2 code (e.g., "US")
    } | null;

    // Tax identification (array format: [id, type])
    taxId?: [string, string] | null; // e.g., ["911144442", "us_ein"]

    // Active subscriptions with meter details
    activeSubscriptions?: Array<{
      id: string;
      createdAt: string;
      modifiedAt: string | null;
      customFieldData?: Record<string, any>;
      metadata?: Record<string, any>;
      status: "active" | "trialing" | "past_due" | "canceled" | "unpaid";
      amount: number; // In smallest currency unit (cents)
      currency: string; // ISO 4217 code (e.g., "usd")
      recurringInterval: "month" | "year";
      currentPeriodStart: string;
      currentPeriodEnd: string;
      cancelAtPeriodEnd: boolean;
      canceledAt?: string | null;
      startedAt?: string | null;
      endsAt?: string | null;
      productId: string;
      discountId?: string | null;

      // Meter usage within subscription
      meters?: Array<{
        id: string;
        createdAt: string;
        modifiedAt: string | null;
        consumedUnits: number;
        creditedUnits: number;
        amount: number; // Cost for overage
        meterId: string;
      }>;
    }>;

    // Granted benefits
    grantedBenefits?: Array<{
      id: string;
      createdAt: string;
      modifiedAt: string | null;
      grantedAt: string;
      benefitId: string;
      benefitType:
        | "custom"
        | "articles"
        | "ads"
        | "discord"
        | "github_repository"
        | "downloadables";
      benefitMetadata?: Record<string, any>;
      properties?: {
        // Discord-specific
        guildId?: string;
        roleId?: string;
        // GitHub-specific
        repositoryId?: string;
        repositoryOwner?: string;
        repositoryName?: string;
        permission?: "pull" | "triage" | "push" | "maintain" | "admin";
        // Downloadables
        files?: Array<{ id: string; name: string }>;
        // Custom
        note?: string;
        [key: string]: any;
      };
    }>;

    // Active usage meters (aggregated across all subscriptions)
    activeMeters?: Array<{
      id: string;
      createdAt: string;
      modifiedAt: string | null;
      meterId: string;
      consumedUnits: number;
      creditedUnits: number;
      balance: number; // creditedUnits - consumedUnits
    }>;
  };
}
```

## Client Configuration

**Edit:** `src/lib/auth-client.ts`

```typescript
import { createAuthClient } from "better-auth/react";
import { polarClient } from "@polar-sh/better-auth";

export const authClient = createAuthClient({
  plugins: [polarClient()],
});
```

## API Usage Pattern

**IMPORTANT:** This integration primarily uses webhook handlers and internal mutations. Server-side `auth.api.*` calls are NOT used.

### Client-Side API (Used)

| Feature             | Client API (`authClient.*`)     | Usage          |
| ------------------- | ------------------------------- | -------------- |
| **Checkout**        | `authClient.checkout({ slug })` | Purchase flow  |
| **Customer Portal** | `authClient.customer.portal()`  | Manage billing |

### Webhook-Driven Operations (Primary Pattern)

All subscription and credit management happens via webhooks:

- `onCustomerCreated` - Link Polar customer to user
- `onOrderPaid` - Process credit purchases
- `onSubscriptionCreated` - Create subscription records
- `onSubscriptionUpdated` - Update subscriptions and reset monthly credits

## Client-Side API Pattern

### Subscription Checkout

**File:** `src/components/subscription/subscription-modal.tsx`

```typescript
// Premium subscription checkout
await authClient.checkout({
  slug: "premium", // Product slug from product config
  referenceId: activeOrganizationId, // Links subscription to organization
});

// Customer Portal - Manage existing subscription
await authClient.customer.portal(); // Opens Polar portal

// Usage in components
const handleSubscribe = async () => {
  const activeOrganizationId = user.activeOrganization?.id;

  if (!activeOrganizationId) {
    toast.error("Please select an organization");
    return;
  }

  try {
    if (currentUser.plan) {
      // User has plan - open portal
      await authClient.customer.portal();
    } else {
      // No plan - initiate checkout
      await authClient.checkout({
        slug: "premium",
        referenceId: activeOrganizationId,
      });
    }
  } catch (error) {
    console.error("Polar checkout error:", error);
    toast.error("Failed to open checkout");
  }
};
```

### Credit Purchase

**Using Convex action instead of direct client call:**

```typescript
// Purchase credits via Convex action (not authClient)
const { url } = await createCreditCheckout({ amount: 100 }); // $100 in credits
window.location.href = url; // Redirect to Polar checkout
```

## Product Configuration

**File:** `convex/polar/product.ts`

### Product Schema

```typescript
// Complete Polar product schema
export const polarProductSchema = z.object({
  attachedCustomFields: z.array(z.any()).optional(),
  benefits: z
    .array(
      z.object({
        id: z.string(),
        createdAt: z.string(),
        deletable: z.boolean(),
        description: z.string(),
        metadata: z.record(z.string(), z.any()).optional(),
        modifiedAt: z.string().nullish(),
        organizationId: z.string(),
        properties: z
          .object({
            meterId: z.string().optional(),
            rollover: z.boolean().optional(),
            units: z.number().optional(),
          })
          .optional(),
        selectable: z.boolean(),
        type: z.string(),
      })
    )
    .optional(),
  createdAt: z.string(),
  description: z.string().nullish(),
  isArchived: z.boolean(),
  isRecurring: z.boolean(),
  medias: z.array(
    z.object({
      id: z.string(),
      checksumEtag: z.string().nullable(),
      checksumSha256Base64: z.string().nullable(),
      checksumSha256Hex: z.string().nullable(),
      createdAt: z.string(),
      isUploaded: z.boolean(),
      lastModifiedAt: z.string().nullable(),
      mimeType: z.string(),
      name: z.string(),
      organizationId: z.string(),
      path: z.string(),
      publicUrl: z.string(),
      service: z.string().optional(),
      size: z.number(),
      sizeReadable: z.string(),
      storageVersion: z.string().nullable(),
      version: z.string().nullable(),
    })
  ),
  metadata: z.record(z.string(), z.any()).optional(),
  modifiedAt: z.string().nullish(),
  name: z.string(),
  organizationId: z.string(),
  prices: z.array(
    z.object({
      id: z.string(),
      amountType: z.string().optional(),
      createdAt: z.string(),
      isArchived: z.boolean(),
      maximumAmount: z.number().nullish(),
      minimumAmount: z.number().optional(),
      modifiedAt: z.string().nullable(),
      presetAmount: z.number().optional(),
      priceAmount: z.number().optional(),
      priceCurrency: z.string().optional(),
      productId: z.string(),
      recurringInterval: z.enum(["month", "year"]).nullish(),
      type: z.string().optional(),
    })
  ),
  productId: z.string(),
  recurringInterval: z.enum(["month", "year"]).nullish(),
});

export type PolarProduct = z.infer<typeof polarProductSchema>;
```

### Hardcoded Products

```typescript
// Product configuration
export const polarProducts: Record<string, PolarProduct> = {
  [env.POLAR_PRODUCT_PREMIUM]: {
    // ... Premium product config
  },
  [env.POLAR_PRODUCT_CREDITS]: {
    // ... Credits product config
  },
  // [env.POLAR_PRODUCT_TEAM]: { ... } // Commented out
};

// Product helpers
export function getProduct(productId: string): PolarProduct | null;
export function getProductSlug(productId: string): string | undefined;
export function productToCredits(productId: string): number;

// Subscription plan constants
export const SubscriptionPlan = {
  Free: 'free',
  Premium: 'premium',
  Team: 'team',
} as const;

export const productToPlan = (productId?: string) => {
  if (productId === env.POLAR_PRODUCT_PREMIUM) return 'premium';
  if (productId === env.POLAR_PRODUCT_TEAM) return 'team';
};

// UI-ready plan details
export type PlanDetails = {
  key: SubscriptionPlan;
  desc: string;
  earlyAccess: boolean;
  fullFeatures: { included: boolean; text: string; separator?: boolean; }[];
  name: string;
  price: { month: number; year?: number; };
  privacy: boolean;
  maxMembers?: number;
  popular?: boolean;
  productId?: string;
};

export const PLANS: Record<string, PlanDetails>;

// Credit purchase options
export const creditPurchaseOptions = [30, 60, 100, 250, 500];
export const calculateCreditsForAmount = (amountInDollars: number): number;
export const FREE_PLAN_CREDITS = 5; // For free tier if applicable
```

## Internal Mutations & Actions

### Customer Management

**File:** `convex/polar/customer.ts`

```typescript
// Create customer via scheduler (called after user signup)
export const createCustomer = createInternalAction()({
  args: {
    betterAuthUserId: z.string(),
    email: z.string().email(),
    name: z.string().optional(),
    userId: zid("user"),
  },
  handler: async (_, args) => {
    const polar = getPolarClient();
    await polar.customers.create({
      email: args.email,
      externalId: args.betterAuthUserId,
      metadata: { userId: args.userId },
      name: args.name,
    });
  },
});

// Link Polar customer ID to user
export const updateUserPolarCustomerId = createInternalMutation()({
  args: { customerId: z.string(), userId: zid("user") },
  handler: async (ctx, args) => {
    const user = await ctx.table("user").getX(args.userId);
    await user.patch({ customerId: args.customerId });
  },
});
```

### Subscription Management

**File:** `convex/polar/subscription.ts`

```typescript
// Create organization subscription
export const createSubscription = createInternalMutation()({
  args: { subscription: subscriptionSchema },
  handler: async (ctx, args) => {
    // Validate organizationId is provided
    if (!args.subscription.organizationId) {
      throw new ConvexError({
        code: "MISSING_ORGANIZATION",
        message: "All subscriptions must be tied to an organization",
      });
    }

    // Check for existing active subscription
    const existing = await ctx
      .table("subscriptions", "organizationId_status", (q) =>
        q
          .eq("organizationId", args.subscription.organizationId)
          .eq("status", "active")
      )
      .first();

    if (existing) {
      throw new ConvexError({
        code: "ORGANIZATION_SUBSCRIPTION_EXISTS",
        message: "Organization already has an active subscription",
      });
    }

    await ctx.table("subscriptions").insert(args.subscription);
  },
});

// Update subscription and handle billing period changes
export const updateSubscription = createInternalMutation()({
  args: { subscription: subscriptionSchema },
  handler: async (ctx, args) => {
    const existing = await ctx
      .table("subscriptions")
      .get("subscriptionId", args.subscription.subscriptionId);

    if (!existing) return { updated: false };

    // Check for billing period change
    const periodChanged =
      existing.currentPeriodEnd !== args.subscription.currentPeriodEnd;

    await existing.patch(args.subscription);

    return { updated: true, periodChanged };
  },
});
```

### Organization Billing Management

**File:** `convex/polar/credit.ts` (or your billing file)

```typescript
// Add organization-specific billing logic here
// For example: usage tracking, credit management, etc.
```

## Helper Functions

### Polar Client

**File:** `convex/polar/polar.ts`

```typescript
export const getPolarClient = () =>
  new Polar({
    accessToken: process.env.POLAR_ACCESS_TOKEN!,
    server:
      process.env.POLAR_SERVER === "production" ? "production" : "sandbox",
  });
```

### Subscription Conversion

**File:** `convex/polar/helpers.ts`

```typescript
// Convert Polar SDK subscription to database format
export const convertToDatabaseSubscription = (
  subscription: Subscription
): WithoutSystemFields<Doc<"subscriptions">> => {
  // Extract organizationId from subscription metadata (referenceId)
  const organizationId = subscription.metadata
    ?.referenceId as Id<"organization">;

  if (!organizationId) {
    throw new Error(
      "Subscription missing organizationId in metadata.referenceId"
    );
  }

  return {
    amount: subscription.amount,
    cancelAtPeriodEnd: subscription.cancelAtPeriodEnd,
    checkoutId: subscription.checkoutId,
    createdAt: subscription.createdAt.toISOString(),
    currency: subscription.currency,
    currentPeriodEnd: subscription.currentPeriodEnd?.toISOString() ?? null,
    currentPeriodStart: subscription.currentPeriodStart.toISOString(),
    customerCancellationComment: subscription.customerCancellationComment,
    customerCancellationReason: subscription.customerCancellationReason,
    endedAt: subscription.endedAt?.toISOString() ?? null,
    metadata: subscription.metadata,
    modifiedAt: subscription.modifiedAt?.toISOString() ?? null,
    organizationId,
    productId: subscription.productId,
    recurringInterval: subscription.recurringInterval as
      | "month"
      | "year"
      | null
      | undefined,
    startedAt: subscription.startedAt?.toISOString() ?? null,
    status: subscription.status,
    subscriptionId: subscription.id,
    userId: subscription.customer.metadata.userId as Id<"user">,
  };
};
```

### Polyfills

**File:** `convex/polar/polyfills.ts`

**⚠️ REQUIRED:** Install the `buffer` npm package (`pnpm add buffer`) for Polar SDK to work in Convex.

```typescript
import { Buffer as BufferPolyfill } from "buffer";

// Required for Polar SDK in Convex environment
globalThis.Buffer = BufferPolyfill;
```

## Common Patterns

### Check Organization Subscription Status

```typescript
// Via internal query (organization-based)
const subscription = await ctx
  .table("subscriptions", "organizationId_status", (q) =>
    q.eq("organizationId", organizationId).eq("status", "active")
  )
  .first();

const isActive = subscription?.status === "active";
```

### Cancel/Resume Subscription

```typescript
// User actions for subscription control
export const cancelSubscription = createAuthAction()({
  handler: async (ctx) => {
    const polar = getPolarClient();
    const subscription = await getActiveSubscription(ctx, {
      userId: ctx.userId,
    });

    if (!subscription) {
      throw new ConvexError({ code: "NO_SUBSCRIPTION" });
    }

    await polar.subscriptions.update({
      id: subscription.subscriptionId,
      subscriptionUpdate: { cancelAtPeriodEnd: true },
    });
  },
});
```

## Environment Variables

**Required in `convex/helpers/getEnv.ts`:**

```bash
# Polar API Configuration
POLAR_SERVER="production"         # 'production' | 'sandbox'
POLAR_ACCESS_TOKEN="polar_at_..." # Polar API access token
POLAR_WEBHOOK_SECRET="whsec_..."  # Webhook signature secret

# Polar Product IDs (from Polar dashboard)
POLAR_PRODUCT_PREMIUM="uuid-here" # Premium subscription product
POLAR_PRODUCT_CREDITS="uuid-here" # Credits purchase product

# Site Configuration
NEXT_PUBLIC_SITE_URL="https://your-site.com" # Used for redirects

# Note: POLAR_PRODUCT_TEAM not currently in env schema (commented out)
```

## API Quick Reference

### Customer Operations

**File:** `convex/polar/customer.ts`

- `createCustomer` (internal action): Create Polar customer on signup
- `updateUserPolarCustomerId` (internal mutation): Link customer to user
- `resetCustomer` (auth action, devOnly): Reset customer for development
- `deletePolarCustomers` (function): Delete all Polar customers (for reset)

### Subscription Operations

**File:** `convex/polar/subscription.ts`

- `createSubscription` (internal mutation): Create organization subscription
- `updateSubscription` (internal mutation): Update subscription status
- `getActiveSubscription` (internal query): Get user's active subscription
- `cancelSubscription` (auth action): Cancel subscription
- `resumeSubscription` (auth action): Resume cancelled subscription

### Credit Operations

**File:** `convex/polar/credit.ts`

- `getCredits` (auth query): Get organization credit balance
- `createCreditCheckout` (auth action): Create checkout for purchasing credits
- `getCreditContext` (auth query): Get credit context for organization/project
- `getOrganizationCredits` (internal mutation): Get specific org credits
- `addPurchasedCredits` (internal mutation): Add purchased credits to org
- `resetMonthlyCredits` (internal mutation): Reset monthly subscription credits
- `consumeCredits` (internal mutation): Consume credits from organization
- `hasCredits` (internal mutation): Check if org has sufficient credits

## Security

1. **Webhook Verification**: Always verify signatures via `POLAR_WEBHOOK_SECRET`
2. **Internal Mutations**: Only callable by Convex system
3. **Rate Limiting**: Applied to all user-facing mutations
4. **Customer Isolation**: Users can only access their own data

## Common Issues

**Customer ID Not Set:**

```typescript
// Check if user has Polar customer
if (!user.customerId) {
  // Customer is created via scheduler after user signup
  // Check internal.polar.customer.createCustomer is called in user.onCreate trigger
}
```

**Subscription Not Found:**

```typescript
// Organization-based subscriptions - check correct organizationId
const sub = await ctx
  .table("subscriptions", "organizationId_status", (q) =>
    q.eq("organizationId", organizationId).eq("status", "active")
  )
  .first();

if (!sub) {
  // Organization has no active subscription
}
```

**Polyfills Required:**

```typescript
// Required at top of convex/auth.ts and polar files
import "./polar/polyfills";
```
