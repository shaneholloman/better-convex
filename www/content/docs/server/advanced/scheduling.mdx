---
title: Scheduling
description: Cron jobs and scheduled functions for background processing.
links:
  doc: https://docs.convex.dev/scheduling/cron-jobs
---

import { InfoIcon } from "lucide-react"

In this guide, we'll explore scheduling in Convex. You'll learn to set up cron jobs for recurring tasks, schedule one-time delayed execution, cancel scheduled functions, and check job status.

## Overview

Convex provides two ways to run [functions](/docs/server/procedures) in the future:

| Type | Use For |
|------|---------|
| Cron jobs | Recurring tasks on a fixed schedule |
| Scheduled functions | One-time delayed execution |

View scheduled jobs in the [Dashboard](https://dashboard.convex.dev) under the **Schedules** tab.

## When to Use Scheduling

Here's a quick reference for choosing the right approach:

| Scenario | Cron Jobs | Scheduled Functions |
|----------|-----------|---------------------|
| Daily cleanup | ✅ Fixed schedule | ❌ |
| Send email after signup | ❌ | ✅ `runAfter(0)` |
| Subscription expiration | ❌ | ✅ `runAt(timestamp)` |
| Hourly analytics | ✅ Fixed schedule | ❌ |
| Reminder notifications | ❌ | ✅ User-defined time |
| Database maintenance | ✅ Off-peak hours | ❌ |
| Order processing delay | ❌ | ✅ `runAfter(5000)` |

<Callout icon={<InfoIcon />}>
**Tip:** Use `runAfter(0)` to trigger [actions](/docs/server/procedures#actions) immediately after a mutation commits - perfect for sending emails, webhooks, or other side effects.
</Callout>

Let's explore both approaches.

## Cron Jobs

Cron jobs run on a fixed schedule - hourly, daily, or using cron expressions.

### Setup

Create `convex/functions/crons.ts` to define recurring jobs:

```ts title="convex/functions/crons.ts" showLineNumbers {4,7-11,14-19}
import { cronJobs } from 'convex/server';
import { internal } from './_generated/api';

const crons = cronJobs();

// Run every 2 hours
crons.interval(
  'cleanup stale data',
  { hours: 2 },
  internal.crons.cleanupStaleData,
  {}
);

// Run at specific times using cron syntax
crons.cron(
  'daily report',
  '0 9 * * *', // Every day at 9 AM UTC
  internal.crons.generateDailyReport,
  {}
);

export default crons;
```

<Callout icon={<InfoIcon />}>
**Note:** Always import `internal` from `./_generated/api`, even for functions in the same file.
</Callout>

### Cron Expressions

Here are common cron patterns:

| Pattern | Description |
|---------|-------------|
| `* * * * *` | Every minute |
| `*/15 * * * *` | Every 15 minutes |
| `0 * * * *` | Every hour |
| `0 0 * * *` | Daily at midnight |
| `0 9 * * *` | Daily at 9 AM |
| `0 9 * * 1-5` | Weekdays at 9 AM |
| `0 0 1 * *` | First day of month |

Format: `minute hour day-of-month month day-of-week`

<Callout icon={<InfoIcon />}>
**Note:** Cron jobs run in **UTC timezone**. Minimum interval is 1 minute.
</Callout>

### Handler Implementation

Now let's define the handler functions that cron jobs call:

```ts title="convex/functions/crons.ts" showLineNumbers {5-13,15-25}
import { z } from 'zod';
import { privateMutation, privateAction } from '../lib/crpc';
import { internal } from './_generated/api';

export const cleanupStaleData = privateMutation
  .input(z.object({}))
  .output(z.object({ deletedCount: z.number() }))
  .mutation(async ({ ctx }) => {
    const thirtyDaysAgo = Date.now() - 30 * 24 * 60 * 60 * 1000;

    // Index session.lastActiveAt.
    const staleSessions = await ctx.orm.query.session.findMany({
      where: { lastActiveAt: { lt: thirtyDaysAgo } },
      limit: 1000,
    });

    for (const sessionRow of staleSessions) {
      await ctx.orm.delete(session).where(eq(session.id, sessionRow.id));
    }

    return { deletedCount: staleSessions.length };
  });

export const generateDailyReport = privateAction
  .input(z.object({}))
  .output(z.null())
  .action(async ({ ctx }) => {
    const stats = await ctx.runQuery(internal.analytics.getDailyStats, {});

    await ctx.runMutation(internal.reports.create, {
      type: 'daily',
      data: stats,
    });

    return null;
  });
```

## Scheduled Functions

Scheduled functions run once at a specific time or after a delay. Let's explore the key concepts.

### Key Concepts

| Concept | Description |
|---------|-------------|
| **Atomicity** | Scheduling from mutations is atomic - if mutation fails, nothing is scheduled |
| **Non-atomic in actions** | Scheduled functions from actions run even if the action fails |
| **Limits** | Single function can schedule up to 1000 functions with 8MB total argument size |
| **Auth not propagated** | Pass user info as arguments if needed |
| **Results retention** | Available for 7 days after completion |

<Callout icon={<InfoIcon />}>
**Warning:** Auth context is NOT available in scheduled functions. Pass `userId` or other auth data as arguments when scheduling.
</Callout>

### scheduler.runAfter

Use `runAfter` to schedule a function to run after a delay (in milliseconds):

```ts title="convex/functions/orders.ts" showLineNumbers {10-13}
import { z } from 'zod';
import { authMutation } from '../lib/crpc';
import { internal } from './_generated/api';

export const processOrder = authMutation
  .input(z.object({ orderId: z.string() }))
  .output(z.null())
  .mutation(async ({ ctx, input }) => {
    await ctx.orm
      .update(orders)
      .set({ status: 'processing' })
      .where(eq(orders.id, input.orderId));

    // Run after 5 seconds
    await ctx.scheduler.runAfter(5000, internal.orders.charge, {
      orderId: input.orderId,
    });

    return null;
  });
```

### Immediate Execution

Here's a powerful pattern: use `runAfter(0)` to trigger actions immediately after a mutation commits:

```ts title="convex/functions/items.ts" showLineNumbers {6-9}
export const createItem = authMutation
  .input(z.object({ name: z.string() }))
  .output(z.string())
  .mutation(async ({ ctx, input }) => {
    const [row] = await ctx.orm
      .insert(items)
      .values({ name: input.name })
      .returning({ id: items.id });
    const itemId = row.id;

    // Action runs immediately after mutation commits
    await ctx.scheduler.runAfter(0, internal.items.sendNotification, {
      itemId,
    });

    return itemId;
  });
```

This is perfect for sending emails, webhooks, or other side effects that shouldn't block the mutation.

### scheduler.runAt

Use `runAt` to schedule a function to run at a specific Unix timestamp:

```ts title="convex/functions/reminders.ts" showLineNumbers {8-13,15-17}
import { CRPCError } from 'better-convex/server';

export const scheduleReminder = authMutation
  .input(z.object({
    message: z.string(),
    sendAt: z.number(), // Unix timestamp in ms
  }))
  .output(z.null())
  .mutation(async ({ ctx, input }) => {
    if (input.sendAt <= Date.now()) {
      throw new CRPCError({
        code: 'BAD_REQUEST',
        message: 'Reminder time must be in the future',
      });
    }

    await ctx.scheduler.runAt(input.sendAt, internal.reminders.send, {
      message: input.message,
    });

    return null;
  });
```

### Canceling Scheduled Functions

Store the job ID to cancel later. Here's the pattern:

```ts title="convex/functions/subscriptions.ts" showLineNumbers {5-9,12-16}
export const createSubscription = authMutation
  .input(z.object({ planId: z.string() }))
  .output(z.string())
  .mutation(async ({ ctx, input }) => {
    // Schedule expiration in 30 days
    const expirationJobId = await ctx.scheduler.runAfter(
      30 * 24 * 60 * 60 * 1000,
      internal.subscriptions.expire,
      { userId: ctx.userId }
    );

    // Store job ID for cancellation
    const [row] = await ctx.orm
      .insert(subscriptions)
      .values({
        userId: ctx.userId,
        planId: input.planId,
        expirationJobId,
      })
      .returning({ id: subscriptions.id });
    return row.id;
  });
```

Then cancel using `ctx.scheduler.cancel()`:

```ts title="convex/functions/subscriptions.ts" showLineNumbers {11-14}
export const cancelSubscription = authMutation
  .input(z.object({ subscriptionId: z.string() }))
  .output(z.null())
  .mutation(async ({ ctx, input }) => {
    const subscription = await ctx.orm.query.subscriptions.findFirst({
      where: { id: input.subscriptionId },
    });

    if (!subscription) {
      throw new CRPCError({ code: 'NOT_FOUND', message: 'Subscription not found' });
    }

    // Cancel the scheduled expiration
    if (subscription.expirationJobId) {
      await ctx.scheduler.cancel(subscription.expirationJobId);
    }

    await ctx.orm
      .delete(subscriptions)
      .where(eq(subscriptions.id, subscription.id));

    return null;
  });
```

## Checking Status

You can query the `_scheduled_functions` system table to check job status:

```ts title="convex/functions/jobs.ts" showLineNumbers {3-12}
import { publicQuery } from '../lib/crpc';

export const getJobStatus = publicQuery
  .input(z.object({ jobId: z.string() }))
  .output(z.object({
    name: z.string(),
    scheduledTime: z.number(),
    completedTime: z.number().optional(),
    state: z.object({
      kind: z.enum(['pending', 'inProgress', 'success', 'failed', 'canceled']),
    }),
  }).nullable())
  .query(async ({ ctx, input }) => {
    return await ctx.orm.system.get(input.jobId);
  });
```

List all pending jobs:

```ts title="convex/functions/jobs.ts" showLineNumbers {3-12}
export const listPendingJobs = publicQuery
  .input(z.object({}))
  .output(z.array(z.object({
    id: z.string(),
    name: z.string(),
    scheduledTime: z.number(),
  })))
  .query(async ({ ctx }) => {
    const jobs = await ctx.orm.system
      .query('_scheduled_functions')
      .filter((q) => q.eq(q.field('state.kind'), 'pending'))
      .collect();

    return jobs.map(({ id, name, scheduledTime }) => ({
      id,
      name,
      scheduledTime,
    }));
  });
```

### Job States

| State | Description |
|-------|-------------|
| `pending` | Not started yet |
| `inProgress` | Currently running (actions only) |
| `success` | Completed successfully |
| `failed` | Hit an error |
| `canceled` | Canceled via dashboard or `ctx.scheduler.cancel()` |

## Error Handling

Understanding how scheduled functions handle errors is critical for reliable systems.

### Mutations

| Behavior | Description |
|----------|-------------|
| **Automatic retry** | Internal Convex errors are automatically retried |
| **Guaranteed execution** | Once scheduled, mutations execute exactly once |
| **Permanent failure** | Only fails on developer errors |

### Actions

| Behavior | Description |
|----------|-------------|
| **No automatic retry** | Actions may have side effects, so not retried |
| **At most once** | Actions execute at most once |
| **Manual retry** | Implement retry logic if needed |

<Callout icon={<InfoIcon />}>
**Warning:** For critical actions that must succeed, implement manual retry with exponential backoff. See [Error Handling](/docs/server/error-handling) for patterns.
</Callout>

## Best Practices

Here are key practices to follow when using scheduling:

1. **Use internal functions** - Prevent external access to scheduled work
2. **Store job IDs** - When you need to cancel scheduled functions
3. **Check conditions** - Target may be deleted before execution
4. **Consider idempotency** - Scheduled functions might run multiple times
5. **Pass auth info** - Auth not propagated, pass user data as arguments
6. **Use runAfter(0)** - Trigger actions after mutation commits

## Next Steps

<Cards>
  <Card title="Triggers" href="/docs/orm/triggers" />
  <Card title="Rate Limiting" href="/docs/server/advanced/rate-limiting" />
  <Card title="HTTP Router" href="/docs/server/http" />
  <Card title="Error Handling" href="/docs/server/error-handling" />
</Cards>
