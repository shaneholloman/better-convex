---
title: Middlewares
description: Add authorization, logging, and context transformations to procedures.
links:
  doc: https://docs.convex.dev/functions
---

import { InfoIcon } from "lucide-react"

In this guide, we'll master middleware - the secret sauce for reusable backend logic. You'll learn to check authentication, transform context, log requests, and chain multiple middleware together.

## Overview

Middleware wraps procedure invocation. It runs before (and optionally after) your handler, letting you:

| Use Case | What It Does |
|----------|--------------|
| Authentication | Check if user is logged in |
| Authorization | Check if user has permission |
| Context Extension | Add `user`, `userId` to context |
| Rate Limiting | Throttle requests |
| Logging | Track request duration |

The key rule: middleware must call `next()` and return its result.

## Authorization

Let's start with the most common use case - checking if a user is authorized before the procedure runs.

```ts title="convex/lib/crpc.ts" showLineNumbers {2-6,7-9}
export const authQuery = c.query.use(async ({ ctx, next }) => {
  const user = await getSessionUser(ctx);
  if (!user) {
    throw new CRPCError({ code: 'UNAUTHORIZED' });
  }
  return next({
    ctx: { ...ctx, user, userId: user.id },
  });
});
```

Now when you use `authQuery`, you're guaranteed to have `ctx.user` and `ctx.userId`:

```ts title="convex/functions/posts.ts" showLineNumbers {3-5}
export const myPosts = authQuery
  .query(async ({ ctx }) => {
    // ctx.user and ctx.userId are guaranteed to exist
    return ctx.orm.query.posts.findMany({
      where: { authorId: ctx.userId },
      limit: 50,
    });
  });
```

## Middleware Signature

Every middleware receives an object with these properties:

| Property | Description |
|----------|-------------|
| `ctx` | Current context |
| `meta` | Procedure metadata |
| `next` | Function to call next middleware/handler |
| `input` | Validated input (`unknown` before `.input()`, typed after) |
| `getRawInput` | Function to get raw input before validation |

Here's the basic pattern:

```ts showLineNumbers {2-5}
.use(async ({ ctx, meta, next, input }) => {
  // Do something before
  const result = await next({ ctx });
  // Do something after (optional)
  return result;
})
```

## Context Extension

Middleware can add or transform context properties. The new context is fully type-safe - TypeScript knows exactly what's available:

```ts title="convex/lib/crpc.ts" showLineNumbers {5-10}
export const authQuery = c.query.use(async ({ ctx, next }) => {
  const user = await getSessionUser(ctx);
  if (!user) throw new CRPCError({ code: 'UNAUTHORIZED' });

  // Add user and userId to context
  return next({
    ctx: {
      ...ctx,
      user,
      userId: user.id,
    },
  });
});

// In procedures, ctx.user is non-null and typed!
export const profile = authQuery
  .query(async ({ ctx }) => {
    return ctx.user; // Type: User, not User | null
  });
```

## Input Access

Middleware placed **after** `.input()` receives typed input. Use it to fetch related data:

```ts showLineNumbers {4-6}
export const queryWithProject = publicQuery
  .input(z.object({ projectId: z.string(), name: z.string() }))
  .use(async ({ ctx, input, next }) => {
    const project = await ctx.orm.query.projects.findFirst({
      where: { id: input.projectId },
    });
    // Add to context, enrich input, or override fields
    return next({ ctx: { ...ctx, project }, input: { ...input, name: input.name.trim() } });
  })
  .query(async ({ ctx, input }) => input.project); // both work
```

Before `.input()`, input is `unknown`. Use `getRawInput()` for raw input before validation.

## Using Meta

Sometimes different procedures need different behavior from the same middleware. That's where metadata comes in.

First, define your meta type when initializing cRPC:

```ts title="convex/lib/crpc.ts" showLineNumbers {1-5,9}
type Meta = {
  auth?: 'optional' | 'required';
  role?: 'admin';
  rateLimit?: string;
};

const c = initCRPC
  .dataModel<DataModel>()
  .meta<Meta>()
  .create();
```

Now middleware can read metadata and act accordingly:

```ts title="convex/lib/crpc.ts" showLineNumbers {2-5}
const roleMiddleware = c.middleware<{ user: { isAdmin: boolean } }>(
  ({ ctx, meta, next }) => {
    if (meta.role === 'admin' && !ctx.user.isAdmin) {
      throw new CRPCError({ code: 'FORBIDDEN' });
    }
    return next({ ctx });
  }
);

// Set metadata when building procedure variants
export const adminQuery = authQuery
  .meta({ role: 'admin' })
  .use(roleMiddleware);
```

## Chaining Middleware

Chain multiple `.use()` calls to compose behavior. They execute in order:

```ts title="convex/lib/crpc.ts" showLineNumbers {2-4}
export const authMutation = c.mutation
  .meta({ auth: 'required' })
  .use(authMiddleware)      // 1. Check auth, add user to ctx
  .use(roleMiddleware)      // 2. Check role if meta.role set
  .use(rateLimitMiddleware); // 3. Apply rate limiting
```

<Callout icon={<InfoIcon />}>
  **Important:** Order matters! Later middleware can access context from earlier middleware. Put auth first so role checks can access `ctx.user`.
</Callout>

## Sharing Middleware

Queries and mutations have different context types. To share middleware between them, use a loose type constraint:

```ts showLineNumbers {2-3,7}
// ✅ Use loose type constraint for shared middleware
const roleMiddleware = c.middleware<object>(({ ctx, meta, next }) => {
  // Access user via type assertion
  const user = (ctx as { user?: { isAdmin?: boolean } }).user;
  if (meta.role === 'admin' && !user?.isAdmin) {
    throw new CRPCError({ code: 'FORBIDDEN' });
  }
  return next({ ctx });
});

// Apply to both query and mutation chains
export const authQuery = c.query
  .use(authMiddleware)
  .use(roleMiddleware);

export const authMutation = c.mutation
  .use(authMiddleware)
  .use(roleMiddleware);
```

For middleware that needs ORM write methods, apply it directly to the mutation chain:

```ts showLineNumbers {2,7-9}
// ❌ Shared middleware loses mutation-specific methods
const writeMiddleware = c.middleware(async ({ ctx, next }) => {
  await ctx.orm.insert(logs).values({ ... }); // Error: insert doesn't exist
  return next({ ctx });
});

// ✅ Apply directly to mutation chain
export const authMutation = c.mutation.use(async ({ ctx, next }) => {
  await ctx.orm.insert(logs).values({ ... }); // Works!
  return next({ ctx });
});
```

## Reusable Middleware

Create standalone middleware with `c.middleware()` for reuse across your codebase:

```ts title="convex/lib/crpc.ts" showLineNumbers {2-6,9-15}
// Standalone middleware
const logMiddleware = c.middleware(async ({ ctx, next }) => {
  const start = Date.now();
  const result = await next({ ctx });
  console.log(`Request took ${Date.now() - start}ms`);
  return result;
});

// Type-constrained middleware
const rateLimitMiddleware = c.middleware<
  MutationCtx & { user?: { id: string; plan: string } | null }
>(async ({ ctx, meta, next }) => {
  await rateLimitGuard({
    ...ctx,
    rateLimitKey: meta.rateLimit ?? 'default',
    user: ctx.user ?? null,
  });
  return next({ ctx });
});
```

### Extending with `.pipe()`

Want to extend existing middleware? Use `.pipe()`:

```ts showLineNumbers {6-11}
const authMiddleware = c.middleware(async ({ ctx, next }) => {
  const user = await getSessionUser(ctx);
  if (!user) throw new CRPCError({ code: 'UNAUTHORIZED' });
  return next({ ctx: { ...ctx, user } });
});

// Extend auth with admin check
const adminMiddleware = authMiddleware.pipe(({ ctx, next }) => {
  if (!ctx.user.isAdmin) {
    throw new CRPCError({ code: 'FORBIDDEN' });
  }
  return next({ ctx });
});
```

## Common Patterns

Here are battle-tested middleware patterns you can copy into your project.

### Auth Required

With Better Auth, use `getSession()` to retrieve the session and fetch the user:

```ts showLineNumbers {4-6,8-11}
import { getSession } from 'better-convex/auth';
import { CRPCError } from 'better-convex/server';

export const authQuery = c.query.use(async ({ ctx, next }) => {
  const session = await getSession(ctx);
  if (!session) {
    throw new CRPCError({ code: 'UNAUTHORIZED', message: 'Not authenticated' });
  }

  const user = await ctx.orm.query.user.findFirst({
    where: { id: session.userId },
  });
  if (!user) {
    throw new CRPCError({ code: 'UNAUTHORIZED', message: 'User not found' });
  }

  return next({
    ctx: {
      ...ctx,
      user: { id: user.id, ...user },
      userId: user.id,
    },
  });
});
```

### Auth Optional

For queries that work with or without authentication:

```ts showLineNumbers {4-6,12-17}
export const optionalAuthQuery = c.query.use(async ({ ctx, next }) => {
  const session = await getSession(ctx);
  if (!session) {
    return next({ ctx: { ...ctx, user: null, userId: null } });
  }

  const user = await ctx.orm.query.user.findFirst({
    where: { id: session.userId },
  });
  if (!user) {
    return next({ ctx: { ...ctx, user: null, userId: null } });
  }

  return next({
    ctx: {
      ...ctx,
      user: { id: user.id, ...user },
      userId: user.id,
    },
  });
});
```

### Rate Limiting

```ts showLineNumbers {2-6}
const rateLimitMiddleware = c.middleware<MutationCtx>(
  async ({ ctx, meta, next }) => {
    await rateLimitGuard({
      ...ctx,
      rateLimitKey: meta.rateLimit ?? 'default',
    });
    return next({ ctx });
  }
);

export const publicMutation = c.mutation
  .use(rateLimitMiddleware);
```

### Logging

```ts showLineNumbers {2-5}
const logMiddleware = c.middleware(async ({ ctx, next }) => {
  const start = Date.now();
  const result = await next({ ctx });
  console.log(`Duration: ${Date.now() - start}ms`);
  return result;
});
```

## Migrate from Convex

If you're coming from convex-helpers, here's what changes.

### What stays the same

- Middleware runs before the handler
- Can transform context and add properties

### What's new

<Compare>
  <CompareItem title="Before (convex-helpers)">
    ```ts showLineNumbers
    import { customQuery, customCtx } from 'convex-helpers/server/customFunctions';

    const authQuery = customQuery(query,
      customCtx(async (ctx) => {
        const user = await getUser(ctx);
        if (!user) throw new Error('Unauthorized');
        return { user };
      })
    );
    ```
  </CompareItem>
  <CompareItem title="After (cRPC)">
    ```ts showLineNumbers {2-4}
    const authQuery = c.query.use(async ({ ctx, next }) => {
      const user = await getUser(ctx);
      if (!user) throw new CRPCError({ code: 'UNAUTHORIZED' });
      return next({ ctx: { ...ctx, user } });
    });
    ```
  </CompareItem>
</Compare>

Key differences:
- Call `next({ ctx })` instead of returning context directly
- Use `CRPCError` for typed errors with codes
- Chain multiple `.use()` calls for composable middleware
- Access `meta` for procedure-level configuration
- Use `c.middleware()` for standalone, reusable middleware

## Next Steps

<Cards>
  <Card title="Error Handling" href="/docs/server/error-handling" />
  <Card title="Context" href="/docs/server/context" />
  <Card title="Rate Limiting" href="/docs/server/advanced/rate-limiting" />
</Cards>
