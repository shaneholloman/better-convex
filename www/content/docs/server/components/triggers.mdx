---
title: Triggers
description: Database triggers for automatic side effects.
links:
  doc: https://github.com/get-convex/convex-helpers
---

import { InfoIcon } from "lucide-react"

In this guide, we'll explore database triggers in Convex. You'll learn to set up triggers that run automatically on insert/update/delete operations, wire them with cRPC, and implement common patterns like audit logging, cascade updates, and data synchronization.

## Overview

[Convex Helpers Triggers](https://github.com/get-convex/convex-helpers) provide database-level hooks that run automatically when data changes:

| Feature | Description |
|---------|-------------|
| Aggregate maintenance | Auto-update counts when rows change |
| Cascade updates | Update related records automatically |
| Activity tracking | Log changes or update timestamps |
| Data synchronization | Keep denormalized data in sync |
| Data validation | Reject invalid mutations at the database level |

Let's set them up.

## Installation

First, install the convex-helpers package:

```bash
bun add convex-helpers
```

## Setup

Now let's create a triggers registration file. This is where you'll define all your database hooks:

```ts title="convex/lib/triggers.ts" showLineNumbers {3-4,6-11}
import { Triggers } from 'convex-helpers/server/triggers';
import type { DataModel } from '../functions/_generated/dataModel';

export const registerTriggers = () => {
  const triggers = new Triggers<DataModel>();

  // Register triggers here
  triggers.register('user', async (ctx, change) => {
    if (change.operation === 'insert') {
      console.log('User created:', change.newDoc.name);
    }
  });

  return triggers;
};
```

## Wiring with cRPC

Here's where triggers shine. Pass `triggers` once in `.create(...)` and it applies to `mutation` + `internalMutation` automatically:

```ts title="convex/lib/crpc.ts" showLineNumbers {1,3,8-14,16-23}
import { withOrm } from './orm';
import { registerTriggers } from './triggers';

const triggers = registerTriggers();

const c = initCRPC
  .dataModel<DataModel>()
  .context({
    query: (ctx) => withOrm(ctx),
    mutation: (ctx) => withOrm(ctx),
  })
  .create({ triggers });
```

<Callout icon={<InfoIcon />}>
This removes manual `mutation: (handler: any) => ...` wrappers in app code.
</Callout>

## Trigger Types

The `change` object contains operation info. Let's explore what's available:

```ts title="convex/lib/triggers.ts" showLineNumbers {2-13,15-18}
triggers.register('user', async (ctx, change) => {
  switch (change.operation) {
    case 'insert':
      // change.newDoc is available
      // change.oldDoc is undefined
      break;
    case 'update':
      // Both change.oldDoc and change.newDoc available
      break;
    case 'delete':
      // change.oldDoc is available
      // change.newDoc is undefined
      break;
  }

  // Always available
  change.id;        // Document ID
  change.operation; // 'insert' | 'update' | 'delete'
});
```

### Change Object Type

Here's the full type definition for reference:

```ts showLineNumbers {2-5}
interface Change<TableName> {
  operation: 'insert' | 'update' | 'delete';
  id: Id<TableName>;
  newDoc: Doc<TableName> | undefined; // Present for insert/update
  oldDoc: Doc<TableName> | undefined; // Present for update/delete
}
```

## Common Patterns

Now let's look at battle-tested trigger patterns you can copy into your project.

### Audit Logging

Log all changes with user context:

```ts title="convex/lib/triggers.ts" showLineNumbers {3-12}
triggers.register('teams', async (ctx, change) => {
  const user = await getAuthUserId(ctx);

  await ctx.orm.insert(auditLog).values({
    table: 'teams',
    operation: change.operation,
    documentId: change.id,
    userId: user,
    timestamp: Date.now(),
    oldDoc: change.oldDoc,
    newDoc: change.newDoc,
  });
});
```

### Authorization Rules

Enforce ownership at the database level:

```ts title="convex/lib/triggers.ts" showLineNumbers {4-7}
triggers.register('messages', async (ctx, change) => {
  const userId = await getAuthUserId(ctx);

  const owner = change.oldDoc?.userId ?? change.newDoc?.userId;
  if (userId !== owner) {
    throw new Error(`User ${userId} cannot modify message owned by ${owner}`);
  }
});
```

### Activity Tracking

Track user activity when posts are created or updated:

```ts title="convex/lib/triggers.ts" showLineNumbers {2-6,12-13,15-21}
import { eq } from 'better-convex/orm';
import { userActivity } from '../functions/schema';

triggers.register('post', async (ctx, change) => {
  if (
    change.operation === 'insert' ||
    (change.operation === 'update' &&
      change.oldDoc?.updatedAt !== change.newDoc?.updatedAt)
  ) {
    const post = change.newDoc!;
    if (!post.authorId) return;

    const existing = await ctx.orm.query.userActivity.findFirst({
      where: { userId: post.authorId, postId: post.id },
    });

    if (existing) {
      await ctx.orm
        .update(userActivity)
        .set({ lastActivityAt: post.updatedAt })
        .where(eq(userActivity.id, existing.id));
      return;
    }

    await ctx.orm.insert(userActivity).values({
      postId: post.id,
      lastActivityAt: post.updatedAt,
      userId: post.authorId,
    });
  }
});
```

### Cascade Updates

Clear references when related documents are deleted:

```ts title="convex/lib/triggers.ts" showLineNumbers {2-4,8-11}
import { eq } from 'better-convex/orm';
import { user } from '../functions/schema';

// Clear reference when related document is deleted
triggers.register('organization', async (ctx, change) => {
  if (change.operation === 'delete') {
    const organizationId = change.id;

    // Clear activeOrganizationId from user records
    // Index user.activeOrganizationId.
    const usersWithThisOrg = await ctx.orm.query.user.findMany({
      where: { activeOrganizationId: organizationId },
      limit: 1000,
    });

    for (const userRow of usersWithThisOrg) {
      await ctx.orm
        .update(user)
        .set({ activeOrganizationId: null })
        .where(eq(user.id, userRow.id));
    }
  }
});
```

### Denormalized Data Sync

Keep denormalized data in sync with source of truth:

```ts title="convex/lib/triggers.ts" showLineNumbers {3-8,15-17,20-26}
import { eq } from 'better-convex/orm';
import { post, postTag, tag } from '../functions/schema';

// Keep tags array in sync with postTags junction table
triggers.register('postTag', async (ctx, change) => {
  if (
    change.operation === 'insert' ||
    change.operation === 'update' ||
    change.operation === 'delete'
  ) {
    const postId =
      change.operation === 'delete'
        ? change.oldDoc!.postId
        : change.newDoc!.postId;

    // Skip if nothing relevant changed
    if (change.operation === 'update') {
      if (change.oldDoc?.tagId === change.newDoc.tagId) {
        return;
      }
    }

    // Recalculate tags from all postTags
    // Index postTag.postId.
    const postTags = await ctx.orm.query.postTag.findMany({
      where: { postId },
      limit: 1000,
    });

    const tagIds = postTags.map((pt) => pt.tagId);
    const tags = await Promise.all(
      tagIds.map((id) => ctx.orm.query.tag.findFirst({ where: { id: id } }))
    );
    const tagNames = tags
      .filter((t) => t !== null)
      .map((t) => t!.name.toLowerCase())
      .sort();

    await ctx.orm.update(post).set({ tagNames }).where(eq(post.id, postId));
  }
});
```

### Data Validation

Throw errors to reject invalid mutations:

```ts title="convex/lib/triggers.ts" showLineNumbers {3-6}
triggers.register('user', async (ctx, change) => {
  if (change.newDoc) {
    const email = change.newDoc.email;
    if (!email.includes('@')) {
      throw new Error(`Invalid email: ${email}`);
    }
  }
});
```

### Async Processing

Schedule heavy work to run after the mutation:

```ts title="convex/lib/triggers.ts" showLineNumbers {2-5}
triggers.register('user', async (ctx, change) => {
  if (change.operation === 'insert') {
    // Schedule async processing
    await ctx.scheduler.runAfter(0, internal.user.sendWelcomeEmail, {
      userId: change.id,
    });
  }
});
```

### Async Debounced Processing

When a document changes multiple times in one mutation, only process the final state:

```ts title="convex/lib/triggers.ts" showLineNumbers {2,6-8,10-13}
// Track scheduled function within mutation scope
let scheduledSync: Id<'_scheduled_functions'> | null = null;

triggers.register('user', async (ctx, change) => {
  if (change.operation === 'delete') return;

  // Cancel previously scheduled sync from this mutation
  if (scheduledSync) {
    await ctx.scheduler.cancel(scheduledSync);
  }

  // Schedule new sync - only final state will be sent
  scheduledSync = await ctx.scheduler.runAfter(0, internal.sync.syncUser, {
    userId: change.id,
  });
});
```

Use this pattern when:
- Processing has side effects (external API calls)
- Document changes multiple times in one mutation
- You only care about final state

## Component Integration

Many Convex components provide trigger helpers for automatic maintenance. Let's see how to use them.

### Aggregates

Use with [Aggregates](/docs/server/components/aggregates) for efficient counts:

```ts title="convex/lib/triggers.ts" showLineNumbers {1,6-7,9-12}
import { aggregatePostLikes, aggregateTotalUsers } from '../aggregates';

export const registerTriggers = () => {
  const triggers = new Triggers<DataModel>();

  // Auto-maintain like counts
  triggers.register('postLikes', aggregatePostLikes.trigger());

  // Auto-maintain user counts
  triggers.register('user', aggregateTotalUsers.trigger());

  // Multiple triggers on same table
  triggers.register('follows', aggregateFollowerCount.trigger());
  triggers.register('follows', aggregateFollowingCount.trigger());

  return triggers;
};
```

### Sharded Counter

Use with [@convex-dev/sharded-counter](https://www.convex.dev/components/sharded-counter) for distributed counters:

```ts showLineNumbers {1,3,5-6}
import { ShardedCounter } from '@convex-dev/sharded-counter';

const counter = new ShardedCounter(components.shardedCounter);

// Auto-increment on insert, decrement on delete
triggers.register('votes', counter.trigger('voteCount'));
```

## Better Auth Integration

For auth operations to trigger side effects, pass your trigger registry directly:

```ts title="convex/functions/auth.ts" showLineNumbers {1,3-4,6-17,19-23}
import { registerTriggers } from './lib/triggers';
import { withOrm } from './lib/orm';

const dbTriggers = registerTriggers();

// Use in createClient and createApi
export const authClient = createClient({
  // ...
  dbTriggers,
  context: withOrm,
});

export const { create, findOne, ... } = createApi(schema, getAuth, {
  dbTriggers,
  context: withOrm,
});
```

## Best Practices

Here are key practices to follow when using triggers.

### Always Use Wrapped Mutations

Triggers only run when using wrapped mutations:

```ts showLineNumbers {1-2,4-5}
// ✅ CORRECT: Import from your functions file
import { mutation } from './lib/crpc';

// ❌ WRONG: Direct generic import bypasses triggers
import { mutation } from 'convex/server';
```

### When Triggers DON'T Run

<Callout icon={<InfoIcon />}>
**Warning:** Triggers will NOT execute when:
- Using unwrapped mutations (direct `convex/server` imports)
- Modifying data in the Convex dashboard
- Using `npx convex import`
- Using streaming import
</Callout>

### Avoid Infinite Recursion

Always check if an update is needed before patching:

```ts showLineNumbers {1-2,8-11}
import { eq } from 'better-convex/orm';
import { session } from '../functions/schema';

triggers.register('session', async (ctx, change) => {
  if (!change.newDoc) return;
  const isExpired = change.newDoc.expiresAt < Date.now();

  // Only update if different - prevents infinite loop
  if (change.newDoc.isExpired !== isExpired) {
    await ctx.orm
      .update(session)
      .set({ isExpired })
      .where(eq(session.id, change.id));
  }
});
```

### Error Handling Warning

<Callout icon={<InfoIcon />}>
**Important:** Caught errors don't roll back the mutation. Let trigger errors bubble up.
</Callout>

```ts showLineNumbers {1-2,4-11,14-18}
import { eq } from 'better-convex/orm';
import { session } from '../functions/schema';

// ❌ BAD: Mutation succeeds even if trigger fails
export const updateSession = authMutation
  .input(z.object({ id: zid('session'), token: z.string() }))
  .mutation(async ({ ctx, input }) => {
    try {
      await ctx.orm
        .update(session)
        .set({ token: input.token })
        .where(eq(session.id, input.id)); // Succeeds
    } catch (e) {
      console.error('failed'); // Trigger error caught
    }
    // Session is still updated!
  });

// ✅ GOOD: Let trigger errors bubble up
export const updateSession = authMutation
  .input(z.object({ id: zid('session'), token: z.string() }))
  .mutation(async ({ ctx, input }) => {
    await ctx.orm
      .update(session)
      .set({ token: input.token })
      .where(eq(session.id, input.id)); // Trigger errors will fail mutation
  });
```

### Atomic Execution

Triggers run within the same transaction as the mutation. Queries running in parallel will never see a state where the data changed but the trigger didn't run.

### Prefer Explicit Functions

Consider explicit wrapper functions over implicit triggers to avoid "spooky action at a distance":

```ts showLineNumbers {1,4-14,17-21}
import { profile, user } from '../functions/schema';

// ✅ Explicit and discoverable
async function createUser(ctx: MutationCtx, data: UserData) {
  const [row] = await ctx.orm
    .insert(user)
    .values(data)
    .returning({ id: user.id });

  await ctx.orm.insert(profile).values({ userId: row.id });
  return row.id;
}

// ❌ Hidden side effects - harder to trace
triggers.register('user', async (ctx, change) => {
  if (change.operation === 'insert') {
    await ctx.orm.insert(profile).values({ userId: change.id });
  }
});
```

## Next Steps

<Cards>
  <Card title="Templates" href="/docs/templates#triggersts" />
  <Card title="Aggregates" href="/docs/server/components/aggregates" />
  <Card title="convex-helpers" href="https://github.com/get-convex/convex-helpers" />
</Cards>
