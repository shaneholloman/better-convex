---
title: Setup
description: Initialize cRPC and create procedure builders.
links:
  doc: https://docs.convex.dev/functions
---

import { InfoIcon } from "lucide-react"

In this guide, we'll set up cRPC in your Convex backend. You'll learn to initialize cRPC, create procedure builders, add middleware, customize context, and organize your files.

## Overview

cRPC gives you a fluent, type-safe API for building Convex procedures. Instead of defining procedures with object config, you chain methods to build them. This makes it easy to add validation, middleware, and reusable patterns.

| Feature | Benefit |
|---------|---------|
| Fluent builder API | Chain `.input()`, `.output()`, `.use()` for readable code |
| Zod validation | Runtime type checking with great error messages |
| Middleware system | Reusable auth, rate limiting, logging |
| Procedure variants | `publicQuery`, `authMutation`, `adminQuery` patterns |

## Initialize cRPC

Let's start by creating the cRPC instance. You only need to do this **once** per backend.

Create a file at `convex/lib/crpc.ts`. This is where all your procedure builders will live.

```ts title="convex/lib/crpc.ts" showLineNumbers {12-22}
import { initCRPC } from 'better-convex/server';
import type { DataModel } from '../functions/_generated/dataModel';

const c = initCRPC
  .dataModel<DataModel>()
  .create();
```

<Callout icon={<InfoIcon />}>
These import paths assume `convex.json` has `"functions": "convex/functions"`. If using a different folder structure, adjust paths accordingly.
</Callout>

The `initCRPC` builder chains configuration methods:

1. **`.dataModel<DataModel>()`** - Enables type-safe data model types (table names, `Id<'table'>`) on `ctx`
2. **`.create()`** - Uses default Convex generic builders (override only when needed)

## Export Procedure Builders

Next, we'll export the procedure builders that you'll use throughout your codebase. These are the building blocks for all your queries, mutations, and actions.

```ts title="convex/lib/crpc.ts" showLineNumbers {1-6,8-10}
// Public procedures - accessible from client
export const publicQuery = c.query;
export const publicMutation = c.mutation;
export const publicAction = c.action;

// Internal procedures - only callable from other backend functions
export const privateQuery = c.query.internal();
export const privateMutation = c.mutation.internal();
export const privateAction = c.action.internal();

// HTTP route builders (for REST APIs)
export const publicRoute = c.httpAction;
export const router = c.router;
```

<Callout icon={<InfoIcon />}>
  **Note:** Internal procedures use `.internal()` which prevents them from being called directly from the client. Use these for scheduled functions, webhooks, and server-to-server calls.
</Callout>

That's it for the basic setup! You can now use `publicQuery`, `publicMutation`, etc. to define your procedures.

## Define Your Schema

Before creating procedures, you'll need a database schema. These docs assume the ORM (see [/docs/db/orm](/docs/db/orm)):

```ts title="convex/functions/schema.ts" showLineNumbers {1-7,9-29,31-42}
import {
  convexTable,
  defineRelations,
  defineSchema,
  id,
  index,
  integer,
  text,
} from 'better-convex/orm';

export const user = convexTable(
  'user',
  { name: text().notNull(), email: text().notNull() },
  (t) => [index('email').on(t.email)]
);

export const session = convexTable(
  'session',
  {
    token: text().notNull(),
    userId: id('user').notNull(),
    expiresAt: integer().notNull(),
  },
  (t) => [index('token').on(t.token), index('userId').on(t.userId)]
);

export const tables = { user, session };
export default defineSchema(tables, { strict: false });

export const relations = defineRelations(tables, (r) => ({
  user: { sessions: r.many.session({ from: r.user._id, to: r.session.userId }) },
  session: { user: r.one.user({ from: r.session.userId, to: r.user._id }) },
}));
```

Now attach the ORM to your context once. Create `convex/lib/orm.ts`:

```ts title="convex/lib/orm.ts" showLineNumbers {1-3,5-6,8-11}
import { createOrm } from 'better-convex/orm';
import type { MutationCtx, QueryCtx } from '../functions/_generated/server';
import { relations } from '../functions/schema';

export const orm = createOrm({ schema: relations });

export const withOrm = <Ctx extends QueryCtx | MutationCtx>(ctx: Ctx) => ({
  ...ctx,
  orm: orm.db(ctx),
});
```

## Your First Procedure

Now let's use our builders to create a simple query. Here's the before and after:

<Compare>
  <CompareItem title="Before (vanilla Convex)">
    ```ts title="convex/functions/user.ts" showLineNumbers
    import { query } from 'convex/server';
    import { v } from 'convex/values';
    import { orm } from '../lib/orm';

    export const list = query({
      args: { limit: v.number() },
      handler: async (ctx, args) => {
        const db = orm.db(ctx);
        return db.query.user.findMany({ limit: args.limit });
      },
    });
    ```
  </CompareItem>
  <CompareItem title="After (cRPC)">
    ```ts title="convex/functions/user.ts" showLineNumbers {4-7}
    import { z } from 'zod';
    import { publicQuery } from '../lib/crpc';

    export const list = publicQuery
      .input(z.object({ limit: z.number() }))
      .query(async ({ ctx, input }) => {
        return ctx.orm.query.user.findMany({ limit: input.limit });
      });
    ```
  </CompareItem>
</Compare>

The key differences:
- **Fluent API** - Chain `.input()` and `.query()` instead of object config
- **Zod validation** - Use `z.object()` instead of `v` validators for richer validation
- **Destructured params** - Access `{ ctx, input }` instead of separate `(ctx, args)`

## Procedure Types

cRPC provides builders for each Convex function type:

| Type | Builder | Use For |
|------|---------|---------|
| Query | `c.query` | Read-only operations, real-time subscriptions |
| Mutation | `c.mutation` | Write operations, transactional updates |
| Action | `c.action` | Side effects, external API calls |
| HTTP Action | `c.httpAction` | REST endpoints, webhooks |

## Adding Middleware

Middleware lets you add reusable logic to your procedures. Let's add authentication.

First, define a middleware that checks auth and adds the user to context:

```ts title="convex/lib/crpc.ts" showLineNumbers {1-12}
const authMiddleware = c.middleware(async ({ ctx, next }) => {
  const identity = await ctx.auth.getUserIdentity();

  if (!identity) {
    throw new CRPCError({ code: 'UNAUTHORIZED' });
  }

  const user = await ctx.orm.query.user.findFirst({
    where: { email: identity.email! },
  });
  if (!user) throw new CRPCError({ code: 'UNAUTHORIZED' });

  return next({ ctx: { ...ctx, user } });
});
```

Now create an authenticated procedure variant:

```ts title="convex/lib/crpc.ts" showLineNumbers {1-2}
export const authQuery = c.query.use(authMiddleware);
export const authMutation = c.mutation.use(authMiddleware);
```

When you use `authQuery`, the middleware runs first. If auth fails, it throws. If it succeeds, `ctx.user` is available in your handler:

```ts title="convex/functions/user.ts" showLineNumbers {4}
export const me = authQuery
  .output(userSchema)
  .query(async ({ ctx }) => {
    return ctx.user; // Typed! We know user exists
  });
```

## Adding Metadata

Sometimes you need procedure-level configuration that middleware can read. Define a meta type:

```ts title="convex/lib/crpc.ts" showLineNumbers {1-5,9}
type Meta = {
  auth?: 'optional' | 'required';
  role?: 'admin';
  rateLimit?: string;
};

const c = initCRPC
  .dataModel<DataModel>()
  .meta<Meta>()
  .create();
```

Now middleware can check metadata:

```ts title="convex/lib/crpc.ts" showLineNumbers {1-6}
const roleMiddleware = c.middleware(({ ctx, meta, next }) => {
  if (meta.role === 'admin' && !ctx.user?.isAdmin) {
    throw new CRPCError({ code: 'FORBIDDEN' });
  }
  return next({ ctx });
});

export const adminQuery = c.query
  .meta({ role: 'admin' })
  .use(authMiddleware)
  .use(roleMiddleware);
```

## Customizing Context

You can add custom properties to the base context. The most common is attaching the ORM as `ctx.orm`:

```ts title="convex/lib/crpc.ts" showLineNumbers {1,4-9}
import { withOrm } from './orm';

const c = initCRPC
  .dataModel<DataModel>()
  .context({
    query: (ctx) => withOrm(ctx),
    mutation: (ctx) => withOrm(ctx),
  })
  .create();
```

Now all your procedures have `ctx.orm` available automatically.

## Common Procedure Variants

Here's a summary of the procedure variants you'll typically create:

| Variant | Description | Middleware |
|---------|-------------|------------|
| `publicQuery` | No auth required | None |
| `optionalAuthQuery` | `ctx.user` may be null | Optional auth |
| `authQuery` | `ctx.user` guaranteed | Auth required |
| `authMutation` | Auth + rate limiting | Auth + rate limit |
| `adminQuery` | Auth + admin role | Auth + role check |

See [Templates](/docs/templates) for complete implementations with rate limiting, error handling, and more.

## File Organization

cRPC uses file-based organization. Each file in `convex/functions/` becomes a namespace:

```
convex/
├── functions/
│   ├── schema.ts     # Database schema
│   ├── user.ts       # → crpc.user.list, crpc.user.create
│   ├── session.ts    # → crpc.session.getByToken
│   └── account.ts    # → crpc.account.list, crpc.account.delete
├── lib/
│   ├── orm.ts        # Attach ORM once (ctx.orm)
│   └── crpc.ts       # Setup + procedure variants
└── shared/           # Client-importable
    └── meta.ts       # Generated procedure metadata
```

On the client, the proxy mirrors this structure:

```ts title="src/components/example.tsx" showLineNumbers
// File: convex/functions/user.ts, export: list
crpc.user.list.queryOptions({ limit: 10 })

// File: convex/functions/session.ts, export: getByToken
crpc.session.getByToken.queryOptions({ token: 'abc' })
```

## Migrate from Convex

If you're coming from vanilla Convex, here's what changes.

### What stays the same

- Import `query`, `mutation`, `action` from `convex/server`
- File-based organization in `convex/functions/`
- Export functions as named exports

### What's new

<Compare>
  <CompareItem title="Before (vanilla Convex)">
    ```ts title="convex/functions/user.ts" showLineNumbers
    import { query } from 'convex/server';
    import { v } from 'convex/values';
    import { orm } from '../lib/orm';

    export const list = query({
      args: { limit: v.number() },
      handler: async (ctx, args) => {
        const db = orm.db(ctx);
        return db.query.user.findMany({ limit: args.limit });
      },
    });
    ```
  </CompareItem>
  <CompareItem title="After (cRPC)">
    ```ts title="convex/functions/user.ts" showLineNumbers {4-7}
    import { publicQuery } from '../lib/crpc';
    import { z } from 'zod';

    export const list = publicQuery
      .input(z.object({ limit: z.number() }))
      .query(async ({ ctx, input }) => {
        return ctx.orm.query.user.findMany({ limit: input.limit });
      });
    ```
  </CompareItem>
</Compare>

Key differences:
- Fluent builder API instead of object config
- Zod validation instead of `v` validators
- `{ ctx, input }` destructured params
- Reusable procedure variants with built-in middleware

## Full Template

For the complete `crpc.ts` setup file with auth middleware, rate limiting, and procedure variants:

<Cards>
  <Card title="Templates" href="/docs/templates#crpcts" />
</Cards>

## Next Steps

<Cards>
  <Card title="Procedures" href="/docs/server/procedures" />
  <Card title="Context" href="/docs/server/context" />
  <Card title="Middleware" href="/docs/server/middlewares" />
  <Card title="HTTP Router" href="/docs/server/http" />
</Cards>
