---
title: Scheduling
description: Cron jobs and scheduled functions
---

## Overview

Convex provides two ways to run [functions](/docs/server/procedures) in the future:

- **Cron jobs**: Recurring tasks on a fixed schedule
- **Scheduled functions**: One-time delayed execution

View scheduled jobs in the [Dashboard](https://dashboard.convex.dev) under the **Schedules** tab.

## When to Use Scheduling

| Scenario | Cron Jobs | Scheduled Functions |
|----------|-----------|---------------------|
| Daily cleanup | ✅ Fixed schedule | ❌ |
| Send email after signup | ❌ | ✅ `runAfter(0)` |
| Subscription expiration | ❌ | ✅ `runAt(timestamp)` |
| Hourly analytics | ✅ Fixed schedule | ❌ |
| Reminder notifications | ❌ | ✅ User-defined time |
| Database maintenance | ✅ Off-peak hours | ❌ |
| Order processing delay | ❌ | ✅ `runAfter(5000)` |

<Callout type="info">
Use `runAfter(0)` to trigger [actions](/docs/server/procedures#actions) immediately after a mutation commits - perfect for sending emails, webhooks, or other side effects.
</Callout>

## Cron Jobs

### Setup

Create `convex/functions/crons.ts`:

```ts title="convex/functions/crons.ts"
import { cronJobs } from 'convex/server';
import { internal } from './_generated/api';

const crons = cronJobs();

// Run every 2 hours
crons.interval(
  'cleanup stale data',
  { hours: 2 },
  internal.crons.cleanupStaleData,
  {}
);

// Run at specific times using cron syntax
crons.cron(
  'daily report',
  '0 9 * * *', // Every day at 9 AM UTC
  internal.crons.generateDailyReport,
  {}
);

export default crons;
```

<Callout type="info">
Always import `internal` from `./_generated/api`, even for functions in the same file.
</Callout>

### Cron Expressions

| Pattern | Description |
|---------|-------------|
| `* * * * *` | Every minute |
| `*/15 * * * *` | Every 15 minutes |
| `0 * * * *` | Every hour |
| `0 0 * * *` | Daily at midnight |
| `0 9 * * *` | Daily at 9 AM |
| `0 9 * * 1-5` | Weekdays at 9 AM |
| `0 0 1 * *` | First day of month |

Format: `minute hour day-of-month month day-of-week`

<Callout>
Cron jobs run in **UTC timezone**. Minimum interval is 1 minute.
</Callout>

### Handler Implementation

```ts title="convex/functions/crons.ts"
import { z } from 'zod';
import { privateMutation, privateAction } from '../lib/crpc';
import { internal } from './_generated/api';

export const cleanupStaleData = privateMutation
  .input(z.object({}))
  .output(z.object({ deletedCount: z.number() }))
  .mutation(async ({ ctx }) => {
    const thirtyDaysAgo = Date.now() - 30 * 24 * 60 * 60 * 1000;

    const staleSessions = await ctx
      .table('session')
      .filter((q) => q.lt(q.field('lastActiveAt'), thirtyDaysAgo));

    for (const session of staleSessions) {
      await ctx.table('session').getX(session._id).delete();
    }

    return { deletedCount: staleSessions.length };
  });

export const generateDailyReport = privateAction
  .input(z.object({}))
  .output(z.null())
  .action(async ({ ctx }) => {
    const stats = await ctx.runQuery(internal.analytics.getDailyStats, {});

    await ctx.runMutation(internal.reports.create, {
      type: 'daily',
      data: stats,
    });

    return null;
  });
```

## Scheduled Functions

Schedule functions to run once at a specific time or after a delay.

### Key Concepts

| Concept | Description |
|---------|-------------|
| **Atomicity** | Scheduling from mutations is atomic - if mutation fails, nothing is scheduled |
| **Non-atomic in actions** | Scheduled functions from actions run even if the action fails |
| **Limits** | Single function can schedule up to 1000 functions with 8MB total argument size |
| **Auth not propagated** | Pass user info as arguments if needed |
| **Results retention** | Available for 7 days after completion |

<Callout type="warning">
Auth context is NOT available in scheduled functions. Pass `userId` or other auth data as arguments when scheduling.
</Callout>

### scheduler.runAfter

Schedule a function to run after a delay (in milliseconds):

```ts
import { z } from 'zod';
import { zid } from 'convex-helpers/server/zod4';
import { authMutation } from '../lib/crpc';
import { internal } from './_generated/api';

export const processOrder = authMutation
  .input(z.object({ orderId: zid('orders') }))
  .output(z.null())
  .mutation(async ({ ctx, input }) => {
    await ctx.table('orders').getX(input.orderId).patch({ status: 'processing' });

    // Run after 5 seconds
    await ctx.scheduler.runAfter(5000, internal.orders.charge, {
      orderId: input.orderId,
    });

    return null;
  });
```

**Immediate execution** with `runAfter(0)` - useful for triggering actions after mutation success:

```ts
export const createItem = authMutation
  .input(z.object({ name: z.string() }))
  .output(zid('items'))
  .mutation(async ({ ctx, input }) => {
    const itemId = await ctx.table('items').insert({ name: input.name });

    // Action runs immediately after mutation commits
    await ctx.scheduler.runAfter(0, internal.items.sendNotification, {
      itemId,
    });

    return itemId;
  });
```

### scheduler.runAt

Schedule a function to run at a specific Unix timestamp:

```ts
import { CRPCError } from 'better-convex/server';

export const scheduleReminder = authMutation
  .input(z.object({
    message: z.string(),
    sendAt: z.number(), // Unix timestamp in ms
  }))
  .output(z.null())
  .mutation(async ({ ctx, input }) => {
    if (input.sendAt <= Date.now()) {
      throw new CRPCError({
        code: 'BAD_REQUEST',
        message: 'Reminder time must be in the future',
      });
    }

    await ctx.scheduler.runAt(input.sendAt, internal.reminders.send, {
      message: input.message,
    });

    return null;
  });
```

### Canceling Scheduled Functions

Store the job ID to cancel later:

```ts
export const createSubscription = authMutation
  .input(z.object({ planId: zid('plans') }))
  .output(zid('subscriptions'))
  .mutation(async ({ ctx, input }) => {
    // Schedule expiration in 30 days
    const expirationJobId = await ctx.scheduler.runAfter(
      30 * 24 * 60 * 60 * 1000,
      internal.subscriptions.expire,
      { userId: ctx.userId }
    );

    // Store job ID for cancellation
    return await ctx.table('subscriptions').insert({
      userId: ctx.userId,
      planId: input.planId,
      expirationJobId,
    });
  });

export const cancelSubscription = authMutation
  .input(z.object({ subscriptionId: zid('subscriptions') }))
  .output(z.null())
  .mutation(async ({ ctx, input }) => {
    const subscription = await ctx.table('subscriptions').get(input.subscriptionId);

    if (!subscription) {
      throw new CRPCError({
        code: 'NOT_FOUND',
        message: 'Subscription not found',
      });
    }

    // Cancel the scheduled expiration
    if (subscription.expirationJobId) {
      await ctx.scheduler.cancel(subscription.expirationJobId);
    }

    await ctx.table('subscriptions').getX(subscription._id).delete();

    return null;
  });
```

## Checking Status

Query the `_scheduled_functions` system table:

```ts
import { publicQuery } from '../lib/crpc';

export const getJobStatus = publicQuery
  .input(z.object({ jobId: zid('_scheduled_functions') }))
  .output(z.object({
    name: z.string(),
    scheduledTime: z.number(),
    completedTime: z.number().optional(),
    state: z.object({
      kind: z.enum(['pending', 'inProgress', 'success', 'failed', 'canceled']),
    }),
  }).nullable())
  .query(async ({ ctx, input }) => {
    return await ctx.table.system('_scheduled_functions').get(input.jobId);
  });

export const listPendingJobs = publicQuery
  .input(z.object({}))
  .output(z.array(z.object({
    _id: zid('_scheduled_functions'),
    name: z.string(),
    scheduledTime: z.number(),
  })))
  .query(async ({ ctx }) => {
    const jobs = await ctx.table
      .system('_scheduled_functions')
      .filter((q) => q.eq(q.field('state.kind'), 'pending'));

    return jobs.map(({ _id, name, scheduledTime }) => ({
      _id,
      name,
      scheduledTime,
    }));
  });
```

### Job States

| State | Description |
|-------|-------------|
| `pending` | Not started yet |
| `inProgress` | Currently running (actions only) |
| `success` | Completed successfully |
| `failed` | Hit an error |
| `canceled` | Canceled via dashboard or `ctx.scheduler.cancel()` |

## Error Handling

Understanding how scheduled functions handle errors is critical for reliable systems.

### Mutations


| Behavior | Description |
|----------|-------------|
| **Automatic retry** | Internal Convex errors are automatically retried |
| **Guaranteed execution** | Once scheduled, mutations execute exactly once |
| **Permanent failure** | Only fails on developer errors |

### Actions

| Behavior | Description |
|----------|-------------|
| **No automatic retry** | Actions may have side effects, so not retried |
| **At most once** | Actions execute at most once |
| **Manual retry** | Implement retry logic if needed |

<Callout type="warning">
For critical actions that must succeed, implement manual retry with exponential backoff. See [Error Handling](/docs/server/error-handling) for patterns.
</Callout>

## Best Practices

1. **Use internal functions** - Prevent external access to scheduled work
2. **Store job IDs** - When you need to cancel scheduled functions
3. **Check conditions** - Target may be deleted before execution
4. **Consider idempotency** - Scheduled functions might run multiple times
5. **Pass auth info** - Auth not propagated, pass user data as arguments
6. **Use runAfter(0)** - Trigger actions after mutation commits

## Next Steps

<Cards>
  <Card title="Triggers" href="/docs/db/triggers" />
  <Card title="Rate Limiting" href="/docs/server/rate-limiting" />
  <Card title="HTTP Endpoints" href="/docs/server/http" />
  <Card title="Error Handling" href="/docs/server/error-handling" />
</Cards>
