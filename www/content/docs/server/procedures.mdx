---
title: Procedures
description: Define inputs, outputs, and handlers with the fluent API.
links:
  doc: https://docs.convex.dev/functions
---

import { InfoIcon } from "lucide-react"

In this guide, we'll learn how to define cRPC procedures. You'll master input validation with Zod, output schemas, handler methods, and pagination - the building blocks for all your backend logic.

## Overview

Procedures are the core building blocks of cRPC. Each procedure chains together:

| Component | Method | Purpose |
|-----------|--------|---------|
| Input | `.input()` | Validate arguments with Zod |
| Output | `.output()` | Validate return values (optional) |
| Handler | `.query()` / `.mutation()` / `.action()` | Execute server logic |

Let's explore each component.

## Input Validation

Use `.input()` to define and validate procedure arguments. The schema runs before your handler, catching invalid data early.

```ts title="convex/functions/user.ts" showLineNumbers {2-3}
export const getById = publicQuery
  .input(z.object({ id: z.string() }))
  .query(async ({ ctx, input }) => {
    return ctx.orm.query.user.findFirst({ where: { id: input.id } });
  });
```

### Schema Format

Pass a `z.object()` schema directly. You get all of Zod's validation power - string lengths, email formats, optional fields, and more:

```ts showLineNumbers {2-5}
.input(z.object({
  name: z.string().min(1).max(100),
  email: z.string().email(),
  emailVerified: z.boolean().optional(),
}))
```

<Callout icon={<InfoIcon />}>
  **Note:** Convex requires `z.object()` at the root level. You can't use primitive types like `z.string()` directly.
</Callout>

### No Input

For procedures that take no arguments, simply omit `.input()`:

```ts showLineNumbers
export const list = publicQuery
  .query(async ({ ctx }) => {
    return ctx.orm.query.user.findMany({ limit: 100 });
  });
```

### Input Merging

Here's where cRPC gets powerful. You can stack `.input()` calls to build complex types. This is especially useful when middleware needs to validate its own input:

First, define a procedure that validates and fetches a target user:

```ts title="convex/lib/crpc.ts" showLineNumbers {2-10}
const userProcedure = authQuery
  .input(z.object({ userId: z.string() }))
  .use(async ({ ctx, input, next }) => {
    const targetUser = await ctx.orm.query.user.findFirst({
      where: { id: input.userId },
    });
    if (!targetUser) throw new CRPCError({ code: 'NOT_FOUND' });
    return next({ ctx: { ...ctx, targetUser } });
  });
```

Now when you extend this procedure, inputs are merged automatically:

```ts title="convex/functions/session.ts" showLineNumbers {2,5}
export const list = userProcedure
  .input(z.object({ limit: z.number().default(10) }))
  .query(async ({ ctx, input }) => {
    // input.userId + input.limit both available!
    return ctx.orm.query.session.findMany({
      where: { userId: input.userId },
      limit: input.limit,
    });
  });
```

## Output Validation

Use `.output()` to validate return values. This catches bugs where your handler returns unexpected data.

```ts showLineNumbers {3-7}
export const getById = publicQuery
  .input(z.object({ id: z.string() }))
  .output(
    z.object({
      id: z.string(),
      name: z.string(),
      email: z.string(),
    })
  )
  .query(async ({ ctx, input }) => {
    const user = await ctx.orm.query.user.findFirst({ where: { id: input.id } });
    if (!user) throw new CRPCError({ code: 'NOT_FOUND' });
    return user;
  });
```

<Callout icon={<InfoIcon />}>
  **Note:** `z.void()` is not supported by Convex. For mutations that don't return a value, use `.output(z.null())`. Convex returns `null` by default, so an explicit `return null` is not required.
</Callout>

Output validation is recommended when using [static code generation](https://docs.convex.dev/production/project-configuration#using-static-code-generation-beta).

## Handler Methods

Now let's look at the three handler types. Each serves a different purpose.

### Queries

Use `.query()` for read-only operations. Queries are cached and support real-time subscriptions - when data changes, clients update automatically.

```ts showLineNumbers {3-5}
export const list = publicQuery
  .input(z.object({ limit: z.number().default(10) }))
  .query(async ({ ctx, input }) => {
    return ctx.orm.query.user.findMany({ limit: input.limit });
  });
```

### Mutations

Use `.mutation()` for write operations. Mutations are transactional - if any part fails, the entire operation rolls back.

```ts showLineNumbers {1-4,6-17}
import { z } from 'zod';
import { eq } from 'better-convex/orm';
import { user } from './schema';

export const create = publicMutation
  .input(z.object({ name: z.string(), email: z.string().email() }))
  .mutation(async ({ ctx, input }) => {
    await ctx.orm.insert(user).values(input);
  });

export const remove = publicMutation
  .input(z.object({ id: z.string() }))
  .mutation(async ({ ctx, input }) => {
    await ctx.orm.delete(user).where(eq(user.id, input.id));
  });
```

### Actions

Use `.action()` for side effects and external API calls. Actions can call queries and mutations via `ctx.runQuery` and `ctx.runMutation`.

```ts showLineNumbers {3-6}
export const sendWelcomeEmail = publicAction
  .input(z.object({ to: z.string().email(), name: z.string() }))
  .action(async ({ ctx, input }) => {
    await sendEmail({ to: input.to, subject: `Welcome, ${input.name}!` });
    return { sent: true };
  });
```

### Paginated Queries

For large datasets, use `.paginated()` for cursor-based pagination. It automatically adds `cursor` and `limit` to your input, and wraps output with pagination metadata.

```ts showLineNumbers {7-8,14}
const SessionSchema = z.object({
  id: z.string(),
  userId: z.string(),
  token: z.string(),
});

export const list = publicQuery
  .input(z.object({ userId: z.string().optional() }))
  .paginated({ limit: 20, item: SessionSchema })
  .query(async ({ ctx, input }) => {
	    return ctx.orm.query.session.findMany({
	      where: input.userId ? { userId: input.userId } : {},
	      orderBy: { createdAt: 'desc' },
	      cursor: input.cursor,
	      limit: input.limit,
	    });
	  });
```

The handler receives flat `input.cursor` and `input.limit`. Pass them to `findMany({ cursor, limit })`. The output is automatically typed as `{ continueCursor: string, isDone: boolean, page: T[] }`.

See [Infinite Queries](/docs/react/infinite-queries) for client-side usage with `useInfiniteQuery`.

## Internal Procedures

Use `privateMutation`, `privateQuery`, or `privateAction` for procedures only callable from other Convex functions. These are perfect for scheduled jobs, background processing, and server-to-server calls.

```ts showLineNumbers {1,7}
export const processJob = privateMutation
  .input(z.object({ data: z.string() }))
  .mutation(async ({ ctx, input }) => {
    // Only callable via ctx.runMutation(internal.jobs.processJob, {...})
  });

export const backfillData = privateMutation
  .input(z.object({ cursor: z.string().nullable() }))
  .mutation(async ({ ctx, input }) => {
    // Background job for data migration
  });
```

<Callout icon={<InfoIcon />}>
  **Note:** These builders use `.internal()` under the hood. You can also call `.internal()` on any builder if needed.
</Callout>

## Complete Example

Here's a full CRUD example showing all the patterns together:

```ts title="convex/functions/user.ts" showLineNumbers
import { z } from 'zod';
import { eq } from 'better-convex/orm';
import { publicQuery, publicMutation } from '../lib/crpc';
import { user } from './schema';

// Define reusable schema
const userSchema = z.object({
  name: z.string().min(1),
  email: z.string().email(),
});

export const list = publicQuery.query(async ({ ctx }) => {
  return ctx.orm.query.user.findMany({ limit: 100 });
});

export const getById = publicQuery
  .input(z.object({ id: z.string() }))
  .query(async ({ ctx, input }) => {
    return ctx.orm.query.user.findFirst({ where: { id: input.id } });
  });

export const create = publicMutation
  .input(userSchema)
  .output(z.string())
  .mutation(async ({ ctx, input }) => {
    const [row] = await ctx.orm
      .insert(user)
      .values(input)
      .returning({ id: user.id });
    return row.id;
  });

export const update = publicMutation
  .input(userSchema.partial().extend({ id: z.string() }))
  .mutation(async ({ ctx, input }) => {
    const { id, ...data } = input;
    await ctx.orm.update(user).set(data).where(eq(user.id, id));
  });
```

## Zod vs Convex Validators

cRPC uses Zod for validation instead of Convex's `v` validators. Here's a quick reference:

| Zod | Convex `v` |
|-----|------------|
| `z.string()` | `v.string()` |
| `z.number()` | `v.number()` |
| `z.boolean()` | `v.boolean()` |
| `z.array(z.string())` | `v.array(v.string())` |
| `z.object({...})` | `v.object({...})` |
| `z.string().optional()` | `v.optional(v.string())` |
| `zid('tablename')` | `v.id('tablename')` |

## Migrate from Convex

If you're coming from vanilla Convex, here's what changes.

### What stays the same

- Export functions as named exports
- Queries for reads, mutations for writes, actions for side effects

### What's new

<Compare>
  <CompareItem title="Before (vanilla Convex)">
    ```ts showLineNumbers
    import { query } from 'convex/server';
    import { v } from 'convex/values';
    import { orm } from '../lib/orm';

    export const getById = query({
      args: { id: v.id('user') },
      handler: async (ctx, args) => {
        const db = orm.db(ctx);
        return db.query.user.findFirst({ where: { id: args.id } });
      },
    });
    ```
  </CompareItem>
  <CompareItem title="After (cRPC)">
    ```ts showLineNumbers {5-7}
    import { z } from 'zod';
    import { publicQuery } from '../lib/crpc';

    export const getById = publicQuery
      .input(z.object({ id: z.string() }))
      .query(async ({ ctx, input }) => {
        return ctx.orm.query.user.findFirst({ where: { id: input.id } });
      });
    ```
  </CompareItem>
</Compare>

Key differences:
- Fluent builder API instead of object config
- Zod validation instead of `v` validators
- `{ ctx, input }` destructured params instead of `(ctx, args)`
- Use `z.string()` for IDs at procedure boundaries (`zid()` only for explicit schema `id()` column mapping)

## Next Steps

<Cards>
  <Card title="Context" href="/docs/server/context" />
  <Card title="Middleware" href="/docs/server/middlewares" />
  <Card title="HTTP Router" href="/docs/server/http" />
</Cards>
