---
title: Concepts
description: Architecture and vocabulary for Better Convex.
links:
  doc: https://docs.convex.dev
---

import { InfoIcon } from "lucide-react"

## Overview

| Concept | What It Does |
|---------|--------------|
| **cRPC Builder** | tRPC-style fluent API for defining procedures |
| **Real-time First** | WebSocket subscriptions flow into TanStack Query |
| **Context & Middleware** | Composable layers for auth, rate limiting, custom logic |
| **Database Layer** | ORM relations, triggers, aggregates |
| **File Structure** | Organized `functions/`, `lib/`, `shared/` directories |

Let's explore each concept.

## The Problem

You know how Convex works: you write functions, the database is reactive, and everything syncs in real-time. It's powerful. But as your application grows, you start noticing friction.

Let's say you want to use TanStack Query. You'll need to manually wire up hooks for each function, and you'll lose Convex's real-time subscriptions - or spend time implementing them yourself. Want to add authentication checks? You'll copy the same auth logic into every function. Need rate limiting? That's more boilerplate.

Before you know it, the elegant simplicity that drew you to Convex gets buried under repetitive code.

**This is what Better Convex solves.** It brings together the best of both worlds: Convex's reactive database with TanStack Query's developer experience. Here's what you get:

- **tRPC-style API:** A fluent builder pattern for defining procedures with full type inference.
- **TanStack Query Native:** First-class integration with `useQuery`, `useMutation`, and React Query DevTools.
- **Real-time by Default:** Queries subscribe to WebSocket updates automatically - no extra setup.
- **End-to-end Type Safety:** From your schema to your React components, everything is typed.
- **Middleware Chains:** Composable layers for auth, rate limiting, and custom context.

## cRPC Builder

Better Convex introduces a tRPC-style builder for defining procedures. Instead of writing standalone functions, you chain methods to build queries and mutations with validation, middleware, and type inference.

<Compare>
  <CompareItem title="Before (vanilla Convex)">
    ```ts showLineNumbers
    export const list = query({
      args: { limit: v.optional(v.number()) },
      handler: async (ctx, args) => {
        const user = await getUser(ctx); // repeated everywhere
        if (!user) throw new Error('Unauthorized');
        const { db } = ctx;
        return db.query('todos').take(args.limit ?? 10).collect();
      },
    });
    ```
  </CompareItem>
  <CompareItem title="After (cRPC)">
    ```ts showLineNumbers
    export const list = authQuery
      .input(z.object({ limit: z.number().optional() }))
      .query(async ({ ctx, input }) => {
        // ctx.user is already available from middleware
        return ctx.orm.query.todos.findMany({ limit: input.limit ?? 10 });
      });
    ```
  </CompareItem>
</Compare>

_The auth middleware runs once, adds `user` to context, and every procedure that uses `authQuery` gets it automatically. No more copy-pasting auth checks._

## Real-time First

Convex queries are reactive - when data changes, subscribers get updates. Better Convex preserves this while giving you TanStack Query's API:

```tsx showLineNumbers {1}
const { data, isPending } = useQuery(crpc.todos.list.queryOptions({}));
```

This single line does three things:

1. **Fetches** the initial data from Convex
2. **Subscribes** to real-time updates via WebSocket
3. **Caches** the result in TanStack Query's cache

| Behavior | TanStack Query Alone | Better Convex |
|----------|---------------------|---------------|
| Initial fetch | ✅ | ✅ |
| Real-time updates | ❌ (polling) | ✅ (WebSocket) |
| Optimistic updates | ✅ | ✅ |
| DevTools | ✅ | ✅ |

_When another user creates a todo, your list updates instantly. No polling, no manual refetching. The reactive database and TanStack Query work together._

## Context & Middleware

Every procedure receives a `ctx` object containing database access and any data added by middleware. Middleware chains let you compose reusable logic:

```ts showLineNumbers {7-8}
// Base context from cRPC setup
ctx.orm       // ORM (queries + mutations)
ctx.auth      // Convex auth object

// Added by auth middleware
ctx.user      // The authenticated user document
ctx.userId    // User's ID for quick access
```

Middleware runs before your handler and can transform context:

```ts showLineNumbers {1-2,8}
import type { GenericId } from 'convex/values';
import { CRPCError } from 'better-convex/server';

const authQuery = c.query.use(async ({ ctx, next }) => {
  const identity = await ctx.auth.getUserIdentity();
  if (!identity) throw new CRPCError({ code: 'UNAUTHORIZED' });

  const userId = identity.subject as GenericId<'user'>;
  const user = await ctx.orm.query.user.findFirst({ where: { _id: userId } });
  if (!user) throw new CRPCError({ code: 'UNAUTHORIZED' });
  return next({ ctx: { ...ctx, user, userId: user._id } });
});
```

_Define the middleware once, use it everywhere. When you need admin-only access, create `adminQuery` that extends `authQuery` with a role check._

## Database Layer

Better Convex uses the ORM for Drizzle-style queries, relations, and runtime enforcement.

### ORM Relations

Define relations with `defineRelations()` and load them with `with:`:

```ts showLineNumbers
const user = await ctx.orm.query.user.findFirst({
  where: { _id: userId },
  with: { posts: { limit: 10, orderBy: { _creationTime: 'desc' } } },
});
```

### Triggers

Automatic side effects when data changes. Use [convex-helpers](https://github.com/get-convex/convex-helpers) triggers for:

- Maintaining denormalized counts
- Cascade deletes
- Audit logging
- Syncing to external systems

```ts showLineNumbers {1-2,4-8}
import { eq } from 'better-convex/orm';
import { post } from './schema';

triggers.register('user', async (ctx, change) => {
  if (change.operation === 'delete') {
    // Cascade delete user's posts
    // Index post.authorId.
    const posts = await ctx.orm.query.post.findMany({
      where: { authorId: change.id },
      limit: 100,
    });
    for (const postRow of posts) {
      await ctx.orm.delete(post).where(eq(post._id, postRow._id));
    }
  }
});
```

### Aggregates

O(log n) operations for counts, sums, and rankings. Essential for dashboards and leaderboards at scale:

```ts showLineNumbers {5-6}
// Slow: Counting all rows (O(n))
const count = (await ctx.orm.query.user.findMany({ limit: 10_000 })).length;

// Fast: Using aggregates (O(log n))
const count = await userAggregate.count(ctx);
const topUsers = await userAggregate.rank(ctx, { limit: 10 });
```

_Aggregates are critical when you have thousands of records. A naive count query scans every row; aggregates use tree structures for constant-time lookups._

## File Structure

Better Convex follows a consistent organization pattern:

```plaintext showLineNumbers {2-6,7-11,12-14}
convex/
├── functions/           # Convex functions (deployed)
│   ├── _generated/      # api.ts, dataModel.ts (auto-generated)
│   ├── schema.ts        # Database schema definition
│   ├── user.ts          # User procedures
│   └── todos.ts         # Todo procedures
├── lib/                 # Shared helpers (not deployed)
│   ├── crpc.ts          # cRPC builder and middleware
│   ├── orm.ts           # ORM context attachment
│   ├── triggers.ts      # Database triggers
│   └── rate-limiter.ts  # Rate limiting logic
└── shared/              # Client-importable code
    ├── types.ts         # Shared TypeScript types
    └── meta.ts          # Generated procedure metadata
```

The `functions/` directory contains your deployed Convex code. The `lib/` directory holds configuration that's imported by functions but not deployed directly. The `shared/` directory contains code that's safe to import on both client and server.

## Configuration

Your `convex.json` configures Convex codegen:

```json title="convex.json" showLineNumbers {2,4-5,7}
{
  "functions": "convex/functions",
  "codegen": {
    "staticApi": true,
    "staticDataModel": true
  },
  "typescriptCompiler": "tsgo"
}
```

| Option | Purpose |
|--------|---------|
| `functions` | Directory containing your Convex functions |
| `codegen.staticApi` | Generate static API types for better inference |
| `codegen.staticDataModel` | Generate static data model types |
| `typescriptCompiler` | Use `"tsgo"` for native TypeScript 7 support |

_Static codegen improves type inference and IDE performance. The `tsgo` compiler is significantly faster for large codebases._

## Next Steps

<Cards>
  <Card title="Server Setup" href="/docs/server/setup" />
  <Card title="React Setup" href="/docs/react" />
  <Card title="Auth Server" href="/docs/auth/server" />
</Cards>
