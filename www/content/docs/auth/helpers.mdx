---
title: Helpers
description: Server and client utilities for authentication
---

## Overview

Authentication helpers provide utilities for both server and client code. Server helpers extract user identity and session data from context. Client hooks manage auth state in React components.

## Server Helpers

### getAuthUserIdentity

Get the full user identity from context:

```ts
import { getAuthUserIdentity } from 'better-convex/auth';

const identity = await getAuthUserIdentity(ctx);

if (identity) {
  identity.userId;    // Id<'user'>
  identity.sessionId; // Id<'session'>
  identity.subject;   // string (user ID as string)
}
```

### getAuthUserId

Get just the user ID:

<Tabs groupId="db" items={["ctx.db", "ctx.table"]} persist>
  <Tab value="ctx.db">
    ```ts
    import { getAuthUserId } from 'better-convex/auth';

    const userId = await getAuthUserId(ctx);

    if (!userId) {
      throw new CRPCError({ code: 'UNAUTHORIZED' });
    }

    // userId is Id<'user'>
    const user = await ctx.db.get(userId);
    ```
  </Tab>
  <Tab value="ctx.table">
    ```ts
    import { getAuthUserId } from 'better-convex/auth';

    const userId = await getAuthUserId(ctx);

    if (!userId) {
      throw new CRPCError({ code: 'UNAUTHORIZED' });
    }

    // userId is Id<'user'>
    const user = await ctx.table('user').get(userId);
    ```
  </Tab>
</Tabs>

### getSession

Get the current session document:

```ts
import { getSession } from 'better-convex/auth';

const session = await getSession(ctx);

if (session) {
  session._id;                  // Id<'session'>
  session.userId;               // Id<'user'>
  session.activeOrganizationId; // Id<'organization'> | null
  session.expiresAt;            // number
}
```

### getHeaders

Build headers from session for external API calls:

```ts
import { getHeaders } from 'better-convex/auth';

const headers = await getHeaders(ctx);
// Headers { authorization: 'Bearer ...', x-forwarded-for: '...' }

// Use with fetch
const response = await fetch('https://api.example.com', {
  headers,
});
```

## Client Hooks

### useAuth

Get comprehensive auth state:

```tsx title="src/components/auth-status.tsx"
import { useAuth } from 'better-convex/auth-client';

function AuthStatus() {
  const { hasSession, isAuthenticated, isLoading } = useAuth();

  if (isLoading) return <Spinner />;

  return (
    <div>
      {isAuthenticated ? 'Logged in' : 'Logged out'}
    </div>
  );
}
```

| Property | Description |
|----------|-------------|
| `hasSession` | Has a session token (may not be verified) |
| `isAuthenticated` | Token exists AND Convex auth verified |
| `isLoading` | Convex auth is still loading |

### useMaybeAuth

Check if user maybe has auth (optimistic, has token):

```tsx title="src/components/example.tsx"
import { useMaybeAuth } from 'better-convex/auth-client';

function Component() {
  const isAuth = useMaybeAuth();
  return isAuth ? <LoggedInUI /> : <LoginButton />;
}
```

### useIsAuth

Check if user is authenticated (server-verified):

```tsx title="src/components/example.tsx"
import { useIsAuth } from 'better-convex/auth-client';

function SecureComponent() {
  const isAuth = useIsAuth();
  return isAuth ? <SensitiveData /> : <Loading />;
}
```

### useAuthGuard

Guard mutations that require authentication:

```tsx title="src/components/create-user.tsx"
import { useAuthGuard } from 'better-convex/auth-client';
import { useMutation } from '@tanstack/react-query';

function CreateUserButton() {
  const guard = useAuthGuard();
  const createUser = useMutation(crpc.user.create.mutationOptions());

  const handleClick = () => {
    // Returns true if blocked (not authenticated)
    if (guard()) return;

    // User is authenticated, safe to mutate
    createUser.mutate({ name: 'New User', email: 'user@example.com' });
  };

  return <button onClick={handleClick}>Create User</button>;
}
```

With callback:

```tsx title="src/components/create-user.tsx"
const handleClick = () => {
  guard(async () => {
    // Only runs if authenticated
    await createUser.mutateAsync({ name: 'New User', email: 'user@example.com' });
    toast.success('User created!');
  });
};
```

## Conditional Rendering

### MaybeAuthenticated

Render children only when has session (optimistic):

```tsx title="src/app.tsx"
import { MaybeAuthenticated } from 'better-convex/auth-client';

function App() {
  return (
    <MaybeAuthenticated>
      <Dashboard />
    </MaybeAuthenticated>
  );
}
```

### Authenticated

Render children only when server-verified:

```tsx title="src/app.tsx"
import { Authenticated } from 'better-convex/auth-client';

function App() {
  return (
    <Authenticated>
      <SensitiveData />
    </Authenticated>
  );
}
```

### MaybeUnauthenticated

Render children only when no session (optimistic):

```tsx title="src/app.tsx"
import { MaybeAuthenticated, MaybeUnauthenticated } from 'better-convex/auth-client';

function App() {
  return (
    <>
      <MaybeAuthenticated>
        <Dashboard />
      </MaybeAuthenticated>
      <MaybeUnauthenticated>
        <LoginPage />
      </MaybeUnauthenticated>
    </>
  );
}
```

### Unauthenticated

Render children only when not server-verified (waits for loading):

```tsx title="src/app.tsx"
import { Unauthenticated } from 'better-convex/auth-client';

function App() {
  return (
    <Unauthenticated>
      <LoginPage />
    </Unauthenticated>
  );
}
```

## Provider Configuration

Configure auth callbacks in the provider:

```tsx title="src/app.tsx"
import { ConvexAuthProvider } from 'better-convex/auth-client';

function App() {
  return (
    <ConvexAuthProvider
      client={convexClient}
      authClient={authClient}
      initialToken={serverToken}
      onMutationUnauthorized={() => {
        // Custom handler for unauthorized mutations
        openLoginModal();
      }}
      onQueryUnauthorized={({ queryName }) => {
        // Custom handler for unauthorized queries
        console.log(`Unauthorized query: ${queryName}`);
      }}
    >
      {children}
    </ConvexAuthProvider>
  );
}
```

### Props

| Prop | Type | Description |
|------|------|-------------|
| `client` | `ConvexReactClient` | Convex client instance |
| `authClient` | `AuthClient` | Better Auth client instance |
| `initialToken` | `string?` | Initial session token (from SSR) |
| `onMutationUnauthorized` | `() => void` | Called when mutation is blocked |
| `onQueryUnauthorized` | `({ queryName }) => void` | Called when query is blocked |

## Logout

Use `createAuthMutations` to generate TanStack Query mutation hooks that handle auth queries cleanup automatically.

### Setup

```ts title="src/lib/auth-client.ts"
import { createAuthClient } from 'better-auth/react';
import { createAuthMutations } from 'better-convex/react';

export const authClient = createAuthClient({...});

// Export hooks from the auth client
export const {
  signIn,
  signUp,
  useActiveOrganization,
  useListOrganizations,
  useSession,
} = authClient;

// Export mutation hooks
export const {
  useSignOutMutationOptions,
  useSignInSocialMutationOptions,
  useSignInMutationOptions,
  useSignUpMutationOptions,
} = createAuthMutations(authClient);
```

### Logout Button

```tsx title="src/components/header.tsx"
import { useMutation } from '@tanstack/react-query';
import { useRouter } from 'next/navigation';
import { toast } from 'sonner';
import { useSignOutMutationOptions } from '@/lib/auth-client';

function LogoutButton() {
  const router = useRouter();
  const signOutMutation = useMutation(
    useSignOutMutationOptions({
      onSuccess: () => router.push('/login'),
      onError: () => toast.error('Failed to sign out'),
    })
  );

  return (
    <button
      disabled={signOutMutation.isPending}
      onClick={() => signOutMutation.mutate()}
    >
      {signOutMutation.isPending ? 'Logging out...' : 'Sign out'}
    </button>
  );
}
```

### Why createAuthMutations?

The hook provides two key features:

1. **Auth query cleanup**: `useSignOutMutationOptions` automatically calls `unsubscribeAuthQueries()` before `signOut()` to prevent `UNAUTHORIZED` errors from subscribed queries during logout.

2. **Proper loading state**: The mutation's `isPending` stays `true` until the auth token is actually cleared (not just when the API call completes). This prevents UI flicker where the button shows "Sign out" briefly before redirecting.

## Next Steps

<Cards>
  <Card title="Triggers" href="/docs/auth/triggers" />
</Cards>
