---
title: API Reference
description: Complete API reference for Better-Convex ORM with functions, operators, and types
links:
  doc: https://orm.drizzle.team/docs/overview
---

import { InfoIcon, CheckCircle, Code } from "lucide-react"

This is the full API surface for Better‑Convex ORM. The goal is to match Drizzle v1’s relational query builder while adapting to Convex’s document model.

## Schema

### `convexTable()`

```ts
convexTable<TName extends string, TColumns>(
  name: TName,
  columns: TColumns,
  extraConfig?: (t) => [
    index('by_field').on(t.someField),
    uniqueIndex('by_unique').on(t.someField),
    check('check_name', gt(t.someField, 0)),
    searchIndex('by_text').on(t.title),
    vectorIndex('embedding_vec').on(t.embedding).dimensions(1536),
  ]
): ConvexTable<TableConfig<TName, TColumns>>
```

**Example**
```ts
const users = convexTable('users', {
  name: text().notNull(),
  email: text().notNull(),
  age: integer(),
});
```

**Auto‑generated fields**
- `_id: Id<TName>`
- `_creationTime: number`

### `convexTable.withRLS()`

```ts
convexTable.withRLS(name, columns, (t) => [
  rlsPolicy('policy_name', {
    for: 'select',
    using: (ctx) => eq(t.ownerId, ctx.viewerId),
  }),
])
```

Enables RLS for the table. If RLS is enabled and no permissive policies apply,
access is denied by default.

### `index()` / `uniqueIndex()`

```ts
import { index, uniqueIndex } from 'better-convex/orm';

const posts = convexTable(
  'posts',
  {
    title: text().notNull(),
    authorId: id('users'),
  },
  (t) => [
    index('by_author').on(t.authorId),
    uniqueIndex('by_title').on(t.title),
  ]
);
```

### `unique()`

```ts
import { unique } from 'better-convex/orm';

const users = convexTable(
  'users',
  {
    firstName: text(),
    lastName: text(),
  },
  (t) => [unique('full_name').on(t.firstName, t.lastName)]
);
```

Use `.nullsNotDistinct()` to treat `null` as a value (PG parity).

### `foreignKey()`

```ts
import { foreignKey } from 'better-convex/orm';

const memberships = convexTable(
  'memberships',
  {
    userSlug: text().notNull(),
  },
  (t) => [foreignKey({ columns: [t.userSlug], foreignColumns: [users.slug] })]
);
```

Use `.onUpdate()` / `.onDelete()` to configure foreign key actions.
Actions are enforced at runtime by Better-Convex ORM mutations.

For `cascade` / `set null` / `set default`, add an index on the referencing columns.
Without an index, Better-Convex will throw when it detects referencing rows.

### `check()`

```ts
import { check, convexTable, gt, integer } from 'better-convex/orm';

const users = convexTable(
  'users',
  {
    age: integer(),
  },
  (t) => [check('adult_age', gt(t.age, 18))]
);
```

Checks are enforced at runtime by Better-Convex ORM mutations and follow SQL-like NULL semantics (the check fails only when the expression is `false`).

### `searchIndex()`

```ts
import { searchIndex } from 'better-convex/orm';

const posts = convexTable(
  'posts',
  {
    title: text().notNull(),
    authorId: id('users'),
  },
  (t) => [searchIndex('by_title').on(t.title).filter(t.authorId)]
);
```

Use `.staged()` to stage a search index for later activation.

### `vectorIndex()`

```ts
import { vector, vectorIndex } from 'better-convex/orm';

const posts = convexTable(
  'posts',
  {
    authorId: id('users'),
    embedding: vector(1536).notNull(),
  },
  (t) => [
    vectorIndex('embedding_vec')
      .on(t.embedding)
      .dimensions(1536)
      .filter(t.authorId),
  ]
);
```

Vector indexes require `.dimensions(n)` and can be staged with `.staged()`.

### `vector()`

```ts
vector(1536)
vector('embedding', 768)
```

### Column Modifiers

```ts
const users = convexTable('users', {
  slug: text().notNull(),
});

text().notNull()
text().default('member')
text().$type<'admin' | 'member'>()
number().$defaultFn(() => Date.now())
number().$onUpdateFn(() => Date.now())
text().unique()
text().unique('handle_unique', { nulls: 'not distinct' })
id('users').references(() => users._id)
text().references(() => users.slug, { onDelete: 'cascade' })
```

### `rlsPolicy()`

```ts
rlsPolicy(name, {
  as: 'permissive' | 'restrictive',
  for: 'all' | 'select' | 'insert' | 'update' | 'delete',
  to: 'public' | 'current_user' | RlsRole | string | Array<...>,
  using: (ctx, t) => FilterExpression<boolean>,
  withCheck: (ctx, t) => FilterExpression<boolean>,
})
```

`using` controls read/update/delete visibility. `withCheck` controls insert/update
values. When omitted, `withCheck` falls back to `using`.

### `rlsRole()`

```ts
rlsRole('admin', { createRole: true }).existing();
```

### `defineRelations()`

```ts
defineRelations(schema, (r) => ({
  users: { posts: r.many.posts() },
  posts: {
    author: r.one.users({ from: r.posts.authorId, to: r.users._id }),
  },
}))
```

### `extractRelationsConfig()`

```ts
const ormEdges = extractRelationsConfig(ormSchema);
```

### `buildSchema()`

```ts
const ormSchema = buildSchema({ users, posts });
```

Builds a schema config without relations. Use this when you don’t need `with` loading.

## Database

### `createDatabase()`

```ts
createDatabase(db, ormSchema, ormEdges)
```

Creates a typed query/mutation client. If `db` is a writer context, mutation methods are available.

<Callout icon={<InfoIcon />}>
Recommended: call `createDatabase` once in your context layer and attach the result to `ctx.table`.
</Callout>

**RLS options**

```ts
createDatabase(db, ormSchema, ormEdges, {
  rls: {
    ctx,
    roleResolver: (ctx) => ctx.roles ?? [],
  },
})
```

Use `ctx.skipRules.table` (or `db.skipRules.table`) for an explicit bypass of RLS.

## Query Builder

### `findMany()`

```ts
await db.query.users.findMany({
  where: { role: 'admin' },
  orderBy: { _creationTime: 'desc' },
  limit: 10,
  offset: 0,
  with: { posts: true },
  columns: { name: true },
});
```

**Options**
- `where`: object filter (Drizzle v1 shape) or predicate function
- `search`: `{ index, query, filters? }` (full‑text search mode; only on tables with search indexes)
- `index`: required when `where` is a function (`{ name, range? }`)
- `orderBy`: `{ field: 'asc' | 'desc' }`
- `limit`, `offset`
- `paginate`: `{ cursor, numItems, maximumRowsRead? }` (cursor pagination)
- `allowFullScan`: opt‑in for object-filter full scans when no index is available (not used with predicate `where` or `search`)
- `with`: relation loading
- `columns`: post‑fetch projection
- `extras`: post‑fetch computed fields

**Sizing rules (non-paginated)**
- Provide `limit`, or
- Use `paginate`, or
- Configure `defineSchema(..., { defaults: { defaultLimit } })`, or
- Use `allowFullScan: true` to opt into unbounded collection.

For `with` + `many()` relations, set relation `limit` or `defaults.defaultLimit`; otherwise use `allowFullScan: true`.

**Search mode constraints**
- `orderBy` is not allowed (results stay in Convex relevance order)
- predicate `where` is not allowed
- relation-based `where` is not allowed
- object `where` on base table fields is allowed (post-search filter)
- `with` is allowed

### `findMany({ search })`

```ts
await db.query.posts.findMany({
  search: {
    index: 'text_search',
    query: 'galaxy',
    filters: { type: 'news' },
  },
  paginate: { cursor: null, numItems: 20 },
});
```

### `findFirst()`

```ts
await db.query.users.findFirst({ where: { email: 'a@b.com' } });
await db.query.posts.findFirst({
  search: { index: 'text_search', query: 'galaxy' },
});
```

### `findMany({ paginate })`

```ts
await db.query.posts.findMany({
  where: { published: true },
  orderBy: { _creationTime: 'desc' },
  paginate: { cursor: null, numItems: 20 },
});
```

### `db.stream()` (advanced)

```ts
const rows = await db.stream().query('users').take(1);
```

`db.stream()` returns a stream reader bound to your schema. Use it for advanced stream operations.
Most queries should use `findMany()` / `findFirst()`.

## Query Filters (object `where`)

**Core operators**
- `eq`, `ne`, `gt`, `gte`, `lt`, `lte`
- `in`, `notIn`
- `isNull`, `isNotNull`
- `AND`, `OR`, `NOT`

**String operators (post‑fetch)**
- `like`, `ilike`, `notLike`, `notIlike`
- `startsWith`, `endsWith`, `contains`

**Index compilation**
- Index-backed by default when possible.
- Currently index-compiled: `eq`, `ne`, `gt`, `gte`, `lt`, `lte`, `in`, `notIn`, `isNull`, `isNotNull`, `startsWith`, `like('prefix%')`, and same-field equality `OR`.
- Remaining operators still require `.allowFullScan()` when no indexable path exists.

**Workarounds for remaining full-scan operators**
- `arrayContains` / `arrayContained` / `arrayOverlaps`: use an inverted/join table indexed by element.
- `contains`: use a search index or tokenized denormalized field.
- `endsWith`: store and index a reversed-string column, then use `startsWith`.
- `ilike` / `notIlike`: normalize to lowercase in a dedicated indexed field.
- `notLike`: index a positive pre-filter, then post-filter with `notLike`.
- `RAW`: keep explicit full-scan opt-in and narrow with indexed filters first.
- Predicate `where`: provide `index: { name, range? }` and use `paginate.maximumRowsRead` for bounded scans.

## Mutations

### `insert()`

```ts
await db.insert(users).values({ name: 'Ada', email: 'ada@example.com' });
```

### `update()`

```ts
await db
  .update(users)
  .set({ name: 'Ada Lovelace' })
  .where(eq(users._id, userId));
```

**Full-scan guardrail**
- `update()` without `where()` throws unless you call `.allowFullScan()`.
- Non‑`_id` filters require `.allowFullScan()` only when no index is available.
- Matched rows are capped by `mutationMaxRows` (default `1000`), collected in `mutationBatchSize` pages (default `100`).
- Override caps via `defineSchema(..., { defaults: { mutationMaxRows, mutationBatchSize } })`.
- For large workloads, use `.paginate({ cursor, numItems })` to execute one batch per mutation call.
- Paged mode returns `{ continueCursor, isDone, numAffected }` (+ `page` when using `.returning()`).
- Paged mode currently supports single-range index plans only.

```ts
await db
  .update(users)
  .set({ name: 'Ada Lovelace' })
  .where(eq(users.email, email));
// If email is not indexed:
// .allowFullScan();
```

### `delete()`

```ts
await db.delete(users).where(eq(users._id, userId));
```

**Full-scan guardrail**
- `delete()` without `where()` throws unless you call `.allowFullScan()`.
- Non‑`_id` filters require `.allowFullScan()` only when no index is available.
- Matched rows are capped by `mutationMaxRows` (default `1000`), collected in `mutationBatchSize` pages (default `100`).
- Override caps via `defineSchema(..., { defaults: { mutationMaxRows, mutationBatchSize } })`.
- For large workloads, use `.paginate({ cursor, numItems })` to execute one batch per mutation call.
- Paged mode returns `{ continueCursor, isDone, numAffected }` (+ `page` when using `.returning()`).
- Paged mode currently supports single-range index plans only.

```ts
await db
  .delete(users)
  .where(eq(users.email, email));
// If email is not indexed:
// .allowFullScan();
```

**Delete helpers**
```ts
// Soft delete (sets deletionTime)
await db.delete(users).where(eq(users._id, userId)).soft();

// Cascade behavior for FK actions
await db.delete(users).where(eq(users._id, userId)).cascade({ mode: 'hard' });

// Scheduled delete (soft now, hard later)
await db
  .delete(users)
  .where(eq(users._id, userId))
  .scheduled({ delayMs: 60_000 });
```

Scheduled deletes require passing `{ scheduler, scheduledDelete }` when building `ctx.table`
and exposing `scheduledDeleteFactory(schema, edges)` as an internal mutation.

### `returning()`

```ts
const [user] = await db
  .insert(users)
  .values({ name: 'Ada', email: 'ada@example.com' })
  .returning({ id: users._id, email: users.email });
```

### `onConflictDoUpdate()`

```ts
await db
  .insert(users)
  .values({ email: 'ada@example.com', name: 'Ada' })
  .onConflictDoUpdate({
    target: users.email,
    set: { name: 'Ada Lovelace' },
  });
```

If the conflict target has no index, call `.allowFullScan()` to opt in:

```ts
await db
  .insert(users)
  .values({ email: 'ada@example.com', name: 'Ada' })
  .onConflictDoUpdate({ target: users.email, set: { name: 'Ada' } })
  .allowFullScan();
```

## Filter Expression Helpers

Use these in mutation `where(...)` clauses:

```ts
eq(field, value)
ne(field, value)
gt(field, value)
gte(field, value)
lt(field, value)
lte(field, value)
inArray(field, values)
notInArray(field, values)
and(...filters)
or(...filters)
not(filter)
isNull(field)
isNotNull(field)
```

## Type Helpers

```ts
InferSelectModel<typeof users>
InferInsertModel<typeof users>
users.$inferSelect
users.$inferInsert
```

## Introspection Helpers

```ts
getTableColumns(users) // includes _id/_creationTime
getTableConfig(users)  // indexes/unique/fks/rls/checks
```

## Notes

- `columns` projection is post‑fetch
- String operators are post‑fetch
- `extras` are computed post‑fetch
- `findMany({ paginate })` uses the first `orderBy` field for cursor ordering
