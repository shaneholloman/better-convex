---
title: API Reference
description: Complete API reference for Better-Convex ORM with functions, operators, and types
links:
  doc: https://orm.drizzle.team/docs/overview
---

import { InfoIcon, CheckCircle, Code } from "lucide-react"

This is the full API surface for Better‑Convex ORM. The goal is to match Drizzle v1’s relational query builder while adapting to Convex’s document model.

## Schema

### `convexTable()`

```ts
convexTable<TName extends string, TColumns>(
  name: TName,
  columns: TColumns,
  extraConfig?: (t) => [
    index('by_field').on(t.someField),
  ]
): ConvexTable<TableConfig<TName, TColumns>>
```

**Example**
```ts
const users = convexTable('users', {
  name: text().notNull(),
  email: text().notNull(),
  age: integer(),
});
```

**Auto‑generated fields**
- `_id: Id<TName>`
- `_creationTime: number`

### `index()` / `uniqueIndex()`

```ts
import { index, uniqueIndex } from 'better-convex/orm';

const posts = convexTable(
  'posts',
  {
    title: text().notNull(),
    authorId: id('users'),
  },
  (t) => [
    index('by_author').on(t.authorId),
    uniqueIndex('by_title').on(t.title),
  ]
);
```

### `table.index()` (legacy)

```ts
table.index(name: string, fields: string[]): table
```

### `table.searchIndex()`

```ts
table.searchIndex(name: string, config: {
  searchField: string;
  filterFields?: string[];
  staged?: boolean;
}): table
```

### `table.vectorIndex()` (wip)

```ts
table.vectorIndex(name: string, config: {
  vectorField: string;
  dimensions: number;
  filterFields?: string[];
  staged?: boolean;
}): table
```

### `defineRelations()`

```ts
defineRelations(schema, (r) => ({
  users: { posts: r.many.posts() },
  posts: {
    author: r.one.users({ from: r.posts.authorId, to: r.users._id }),
  },
}))
```

### `extractRelationsConfig()`

```ts
const ormEdges = extractRelationsConfig(ormSchema);
```

### `buildSchema()`

```ts
const ormSchema = buildSchema({ users, posts });
```

Builds a schema config without relations. Use this when you don’t need `with` loading.

## Database

### `createDatabase()`

```ts
createDatabase(db, ormSchema, ormEdges)
```

Creates a typed query/mutation client. If `db` is a writer context, mutation methods are available.

## Query Builder

### `findMany()`

```ts
await db.query.users.findMany({
  where: { role: 'admin' },
  orderBy: { _creationTime: 'desc' },
  limit: 10,
  offset: 0,
  with: { posts: true },
  columns: { name: true },
});
```

**Options**
- `where`: object filter (Drizzle v1 shape)
- `orderBy`: `{ field: 'asc' | 'desc' }`
- `limit`, `offset`
- `with`: relation loading
- `columns`: post‑fetch projection

### `findFirst()`

```ts
await db.query.users.findFirst({ where: { email: 'a@b.com' } });
```

### `paginate()`

```ts
await db.query.posts.paginate(
  { where: { published: true }, orderBy: { _creationTime: 'desc' } },
  { cursor: null, numItems: 20 }
);
```

## Query Filters (object `where`)

**Core operators**
- `eq`, `ne`, `gt`, `gte`, `lt`, `lte`
- `in`, `notIn`
- `isNull`, `isNotNull`
- `AND`, `OR`, `NOT`

**String operators (post‑fetch)**
- `like`, `ilike`, `notLike`, `notIlike`
- `startsWith`, `endsWith`, `contains`

## Mutations

### `insert()`

```ts
await db.insert(users).values({ name: 'Ada', email: 'ada@example.com' });
```

### `update()`

```ts
await db
  .update(users)
  .set({ name: 'Ada Lovelace' })
  .where(eq(users._id, userId));
```

### `delete()`

```ts
await db.delete(users).where(eq(users._id, userId));
```

### `returning()`

```ts
const [user] = await db
  .insert(users)
  .values({ name: 'Ada', email: 'ada@example.com' })
  .returning({ id: users._id, email: users.email });
```

### `onConflictDoUpdate()`

```ts
await db
  .insert(users)
  .values({ email: 'ada@example.com', name: 'Ada' })
  .onConflictDoUpdate({
    target: users.email,
    set: { name: 'Ada Lovelace' },
  });
```

## Filter Expression Helpers

Use these in mutation `where(...)` clauses:

```ts
eq(field, value)
ne(field, value)
gt(field, value)
gte(field, value)
lt(field, value)
lte(field, value)
inArray(field, values)
notInArray(field, values)
and(...filters)
or(...filters)
not(filter)
isNull(field)
isNotNull(field)
```

## Type Helpers

```ts
InferSelectModel<typeof users>
InferInsertModel<typeof users>
users.$inferSelect
users.$inferInsert
```

## Notes

- `columns` projection is post‑fetch
- String operators are post‑fetch
- `paginate()` uses the first `orderBy` field for cursor ordering
