---
title: Querying Data
description: Query tables with findMany, findFirst, filtering, and relation loading
links:
  doc: https://orm.drizzle.team/docs/rqb
---

import { InfoIcon, CheckCircle, AlertTriangle } from "lucide-react"

Query your Convex database using Drizzle v1’s relational query builder API. Better‑Convex keeps the syntax familiar while adapting to Convex’s document model.

## Setup

```ts title="convex/queries.ts"
import { createDatabase } from 'better-convex/orm';
import { ormSchema, ormEdges } from './schema';

const db = createDatabase(ctx.db, ormSchema, ormEdges);
```

## Basic Queries

### findMany

```ts title="convex/queries.ts"
export const getAllUsers = query({
  handler: async (ctx) => {
    const db = createDatabase(ctx.db, ormSchema, ormEdges);
    return db.query.users.findMany();
  },
});
```

### findFirst

```ts title="convex/queries.ts"
export const getFirstUser = query({
  handler: async (ctx) => {
    const db = createDatabase(ctx.db, ormSchema, ormEdges);
    return db.query.users.findFirst({
      where: { email: 'alice@example.com' },
    });
  },
});
```

## Filtering With `where`

Use object filters (Drizzle v1 style). The shape mirrors Drizzle but is executed in Convex.

```ts
const admins = await db.query.users.findMany({
  where: {
    role: 'admin',
    lastSeen: { gt: Date.now() - 86_400_000 },
  },
});
```

### Core Operators

| Operator | Example | Description |
|---|---|---|
| `eq` | `{ role: 'admin' }` or `{ role: { eq: 'admin' } }` | Equals |
| `ne` | `{ status: { ne: 'banned' } }` | Not equal |
| `gt` | `{ age: { gt: 18 } }` | Greater than |
| `gte` | `{ credits: { gte: 100 } }` | Greater than or equal |
| `lt` | `{ age: { lt: 65 } }` | Less than |
| `lte` | `{ loginCount: { lte: 10 } }` | Less than or equal |
| `in` | `{ status: { in: ['active', 'pending'] } }` | Value in array |
| `notIn` | `{ status: { notIn: ['deleted'] } }` | Value not in array |
| `isNull` | `{ deletedAt: { isNull: true } }` | Null/undefined |
| `isNotNull` | `{ email: { isNotNull: true } }` | Not null/undefined |
| `AND` | `{ AND: [ ... ] }` | Logical AND |
| `OR` | `{ OR: [ ... ] }` | Logical OR |
| `NOT` | `{ NOT: { ... } }` | Logical NOT |

### String Operators (post‑fetch)

| Operator | Example | Notes |
|---|---|---|
| `like` | `{ title: { like: '%JavaScript%' } }` | Post‑fetch |
| `ilike` | `{ title: { ilike: '%javascript%' } }` | Post‑fetch |
| `notLike` | `{ title: { notLike: '%draft%' } }` | Post‑fetch |
| `notIlike` | `{ title: { notIlike: '%draft%' } }` | Post‑fetch |
| `startsWith` | `{ title: { startsWith: 'Intro' } }` | Post‑fetch |
| `endsWith` | `{ title: { endsWith: 'Guide' } }` | Post‑fetch |
| `contains` | `{ title: { contains: 'ORM' } }` | Post‑fetch |

<Callout icon={<InfoIcon />}>
String operators run after data is fetched. For large datasets, filter by indexed fields first or use search indexes.
</Callout>

### Logical Filters

```ts
const users = await db.query.users.findMany({
  where: {
    OR: [{ role: 'admin' }, { role: 'premium' }],
    NOT: { status: 'banned' },
  },
});
```

## Ordering

```ts
const posts = await db.query.posts.findMany({
  orderBy: { _creationTime: 'desc', title: 'asc' },
});
```

**Notes:**
- The first `orderBy` field should have an index for stable ordering
- Secondary sort fields are applied post‑fetch
- `paginate()` uses only the first `orderBy` field for cursor ordering

## Pagination

### Limit / Offset

```ts
const posts = await db.query.posts.findMany({
  limit: 10,
  offset: 20,
});
```

### Cursor Pagination

```ts
return db.query.posts.paginate(
  { where: { published: true }, orderBy: { _creationTime: 'desc' } },
  { cursor: args.cursor ?? null, numItems: 20 }
);
```

## Relation Loading With `with`

```ts
const users = await db.query.users.findMany({
  with: {
    posts: {
      limit: 5,
      orderBy: { _creationTime: 'desc' },
    },
  },
});
```

<Callout icon={<InfoIcon />}>
Relation filters for `many()` are applied post‑fetch. Nested `with` has a depth limit to prevent infinite recursion.
</Callout>

## Column Selection

```ts
const users = await db.query.users.findMany({
  columns: { name: true, email: true },
});
```

<Callout icon={<AlertTriangle />}>
`columns` is a post‑fetch projection. Convex still reads full documents.
</Callout>

## Performance Tips

- Add `.index()` for fields used in filters or primary ordering
- Use `paginate()` for large lists
- Prefer `with` over per‑row queries to avoid N+1

## Common Gotchas

| Issue | Fix |
|---|---|
| `where` expects an object | Use `where: { field: value }` |
| `eq(field, null)` | Use `{ isNull: true }` |
| Slow ordering | Add an index on the primary `orderBy` field |
| `columns` doesn’t reduce reads | Projection is post‑fetch |
| Relations not loading | Pass `ormEdges` to `createDatabase` |
