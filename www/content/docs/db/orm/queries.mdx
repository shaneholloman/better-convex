---
title: Querying Data
description: Query tables with findMany, findFirst, filtering, and relation loading
links:
  doc: https://orm.drizzle.team/docs/rqb
---

import { InfoIcon, CheckCircle, AlertTriangle } from "lucide-react"

Query your Convex database using Drizzle's familiar relational query API. Better-Convex ORM provides full type safety and automatic real-time subscriptions.

## Overview

**Category**: ‚úÖ Drizzle-Compatible (Core Queries) | ‚ö†Ô∏è Coming Soon (Relations)

| Feature | Drizzle | Better-Convex (M1-M5) | Status |
|---------|---------|---------------|--------|
| `findMany()` | ‚úÖ | ‚úÖ | Fully implemented |
| `findFirst()` | ‚úÖ | ‚úÖ | Fully implemented |
| `where` filtering | ‚úÖ | ‚úÖ | All operators working |
| `limit` / `offset` | ‚úÖ | ‚úÖ | Pagination supported |
| `orderBy` | ‚úÖ | ‚úÖ | Fully implemented |
| String operators | ‚úÖ | ‚úÖ | Post-fetch filtering |
| `with` relations | ‚úÖ | üöß | Planned for M6 |
| `columns` selection | ‚úÖ | ‚ùå | Not applicable - Convex returns full documents |

## Basic Queries

### findMany - Query Multiple Records

```ts title="convex/queries.ts" showLineNumbers {6-8}
import { query } from './_generated/server';
import { db } from 'better-convex/orm';

export const getAllUsers = query({
  handler: async (ctx) => {
    const users = await db(ctx).query.users.findMany();

    return users;
  },
});
```

**Generated Convex Query:**
```ts
// Behind the scenes:
ctx.db.query("users").collect()
```

**Type Inference:**
```ts
// Return type:
Array<{
  _id: Id<'users'>,
  name: string,
  email: string,
  _creationTime: number
}>
```

### findFirst - Query Single Record

```ts title="convex/queries.ts" showLineNumbers
export const getFirstUser = query({
  handler: async (ctx) => {
    const user = await db(ctx).query.users.findFirst();

    return user; // null if no users exist
  },
});
```

**Type Inference:**
```ts
// Return type:
{
  _id: Id<'users'>,
  name: string,
  email: string,
  _creationTime: number
} | null
```

## Filtering with `where`

### Basic Filtering

Use Drizzle's filter operators:

```ts title="convex/queries.ts" showLineNumbers {1,7-11}
import { eq, gt, and } from 'better-convex/orm';

export const getActiveAdmins = query({
  handler: async (ctx) => {
    const admins = await db(ctx).query.users.findMany({
      where: and(
        eq(users.role, 'admin'),
        gt(users.lastSeen, Date.now() - 86400000) // Active in last 24h
      ),
    });

    return admins;
  },
});
```

**Generated Convex Query:**
```ts
// Behind the scenes:
ctx.db.query("users")
  .withIndex("role", q => q.eq("role", "admin"))
  .filter(q => q.gt(q.field("lastSeen"), Date.now() - 86400000))
  .collect()
```

### Available Operators

**Category 1: ‚úÖ 100% Compatible**

| Operator | Example | Description |
|----------|---------|-------------|
| `eq(field, value)` | `eq(users.role, 'admin')` | Equal to |
| `ne(field, value)` | `ne(users.status, 'banned')` | Not equal to |
| `gt(field, value)` | `gt(users.age, 18)` | Greater than |
| `gte(field, value)` | `gte(users.credits, 100)` | Greater than or equal |
| `lt(field, value)` | `lt(users.age, 65)` | Less than |
| `lte(field, value)` | `lte(users.loginCount, 10)` | Less than or equal |
| `and(...)` | `and(eq(...), gt(...))` | Logical AND |
| `or(...)` | `or(eq(...), eq(...))` | Logical OR |
| `not(...)` | `not(eq(...))` | Logical NOT |
| `isNull(field)` | `isNull(users.deletedAt)` | Is undefined/null |
| `isNotNull(field)` | `isNotNull(users.email)` | Is not undefined/null |

**Category 2: ‚úÖ String Operators (Post-Fetch)**

| Operator | Example | Description | Notes |
|----------|---------|-------------|-------|
| `like(field, pattern)` | `like(posts.title, '%JavaScript%')` | SQL LIKE pattern matching | Post-fetch filter |
| `ilike(field, pattern)` | `ilike(posts.title, '%javascript%')` | Case-insensitive LIKE | Post-fetch filter |
| `startsWith(field, prefix)` | `startsWith(posts.title, 'Java')` | Prefix matching | Post-fetch filter |
| `endsWith(field, suffix)` | `endsWith(posts.title, 'Guide')` | Suffix matching | Post-fetch filter |
| `contains(field, substring)` | `contains(posts.title, 'Script')` | Substring matching | Post-fetch filter |

**Category 3: ‚ö†Ô∏è Limited Support**

| Operator | Drizzle | Better-Convex | Workaround |
|----------|---------|---------------|------------|
| `inArray(field, values)` | ‚úÖ | ‚úÖ | Fully supported |

<Callout icon={<InfoIcon />}>
**String Operators**: Implemented as post-fetch filters using JavaScript string methods. For large datasets, combine with `where` filtering on indexed fields first to reduce the dataset before string matching.
</Callout>

### Complex Filtering

```ts title="convex/queries.ts" showLineNumbers
import { eq, gt, lt, and, or } from 'better-convex/orm';

export const getEligibleUsers = query({
  handler: async (ctx) => {
    const users = await db(ctx).query.users.findMany({
      where: and(
        or(
          eq(users.role, 'premium'),
          eq(users.role, 'admin')
        ),
        gt(users.credits, 0),
        lt(users.loginCount, 100)
      ),
    });

    return users;
  },
});
```

### Negative Examples

```ts
// ‚ùå WRONG: Using null instead of undefined
const users = await db(ctx).query.users.findMany({
  where: eq(users.deletedAt, null), // Type error!
});

// ‚úÖ CORRECT: Convex uses undefined
const users = await db(ctx).query.users.findMany({
  where: isNull(users.deletedAt), // Checks for undefined
});

// ‚ùå WRONG: SQL LIKE operator
const users = await db(ctx).query.users.findMany({
  where: like(users.name, '%alice%'), // Not supported!
});

// ‚úÖ CORRECT: Use Convex search index or post-filter
const users = await db(ctx).query.users.findMany();
const filtered = users.filter(u => u.name.toLowerCase().includes('alice'));
```

## Pagination

### Limit

Limit the number of results returned:

```ts title="convex/queries.ts" showLineNumbers {6}
import { query } from './_generated/server';
import { db } from 'better-convex/orm';

export const getRecentPosts = query({
  handler: async (ctx) => {
    const posts = await db(ctx).query.posts.findMany({
      limit: 10,
    });

    return posts;
  },
});
```

### Offset

Skip the first N results:

```ts title="convex/queries.ts" showLineNumbers {7-8}
import { query } from './_generated/server';
import { db } from 'better-convex/orm';

export const getPostsPage = query({
  args: { page: v.number() },
  handler: async (ctx, args) => {
    const posts = await db(ctx).query.posts.findMany({
      limit: 10,
      offset: (args.page - 1) * 10,
    });

    return posts;
  },
});
```

### Combined with Filtering

```ts title="convex/queries.ts" showLineNumbers
export const getPublishedPostsPage = query({
  args: { page: v.number() },
  handler: async (ctx, args) => {
    const posts = await db(ctx).query.posts.findMany({
      where: eq(posts.published, true),
      limit: 10,
      offset: (args.page - 1) * 10,
    });

    return posts;
  },
});
```

<Callout icon={<InfoIcon />}>
**Pagination**: `limit` and `offset` work for simple pagination. For better performance with large datasets, consider using Convex's native cursor pagination (see Limitations page).
</Callout>

## Ordering Results with `orderBy`

Sort query results using `asc()` and `desc()` helpers.

### Basic Ordering

**Ascending Order:**
```ts title="convex/queries.ts" showLineNumbers {1,8}
import { asc } from 'better-convex/orm';

export const getOldestPosts = query({
  handler: async (ctx) => {
    const posts = await db(ctx).query.posts.findMany({
      orderBy: asc(posts._creationTime),
    });

    return posts; // Oldest first
  },
});
```

**Descending Order:**
```ts title="convex/queries.ts" showLineNumbers {1,8}
import { desc } from 'better-convex/orm';

export const getLatestPosts = query({
  handler: async (ctx) => {
    const posts = await db(ctx).query.posts.findMany({
      orderBy: desc(posts._creationTime),
    });

    return posts; // Newest first
  },
});
```

### Index-Aware Optimization

OrderBy automatically uses Convex indexes when available for optimal performance:

```ts
// ‚úÖ FAST: Uses default _creationTime index
const posts = await db(ctx).query.posts.findMany({
  orderBy: desc(posts._creationTime),
});

// ‚ö†Ô∏è SLOWER: No index on 'title' - uses post-fetch Array.sort()
const posts = await db(ctx).query.posts.findMany({
  orderBy: asc(posts.title),
});
```

**Performance Tip:** Create indexes for frequently sorted fields:
```ts title="convex/schema.ts"
import { convexTable, text, number } from 'better-convex/orm';

const posts = convexTable('posts', {
  title: text().notNull(),
  createdAt: number().notNull(),
}).index('by_createdAt', ['createdAt']); // Now orderBy(posts.createdAt) uses index!
```

### Combined with Filtering and Pagination

```ts title="convex/queries.ts" showLineNumbers
import { eq, desc } from 'better-convex/orm';

export const getPublishedPostsPage = query({
  args: { page: v.number() },
  handler: async (ctx, args) => {
    const posts = await db(ctx).query.posts.findMany({
      where: eq(posts.published, true),
      orderBy: desc(posts._creationTime),
      limit: 10,
      offset: (args.page - 1) * 10,
    });

    return posts;
  },
});
```

**Execution Order:**
1. WHERE filtering (uses Convex index if available)
2. OrderBy sorting (uses index or post-fetch sort)
3. Offset/Limit pagination (post-fetch slicing)

### System Fields for Ordering

Convex provides built-in system fields perfect for ordering:

```ts
// Order by creation time (every document has this)
const recentUsers = await db(ctx).query.users.findMany({
  orderBy: desc(users._creationTime),
});

// Order by document ID (stable, unique sort)
const usersById = await db(ctx).query.users.findMany({
  orderBy: asc(users._id),
});
```

**System fields available:**
- `_id: Id<TableName>` - Convex document ID
- `_creationTime: number` - Unix timestamp (milliseconds)

### Limitations

<Callout icon={<AlertTriangle />}>
**‚ö†Ô∏è Single-Field Ordering Only** - Convex's API only supports ordering by one field. For multi-field sorts, use post-fetch Array.sort():

```ts
const posts = await db(ctx).query.posts.findMany();
const sorted = posts.sort((a, b) => {
  // Sort by published first, then by createdAt
  if (a.published !== b.published) return a.published ? -1 : 1;
  return b.createdAt - a.createdAt;
});
```
</Callout>

## String Operators

Search and filter text fields using SQL-like operators. These are implemented as post-fetch filters (JavaScript string methods) since Convex doesn't support SQL LIKE natively.

### LIKE Pattern Matching

SQL-style LIKE with `%` wildcards:

```ts title="convex/queries.ts" showLineNumbers {1,8}
import { like } from 'better-convex/orm';

export const searchPosts = query({
  args: { keyword: v.string() },
  handler: async (ctx, args) => {
    const posts = await db(ctx).query.posts.findMany({
      where: like(posts.title, `%${args.keyword}%`),
    });

    return posts;
  },
});
```

**Pattern syntax:**
- `%text%` - Contains substring (anywhere)
- `text%` - Starts with prefix
- `%text` - Ends with suffix
- `text` - Exact match

**Examples:**
```ts
// Find posts with 'JavaScript' in title
like(posts.title, '%JavaScript%')

// Find posts starting with 'How to'
like(posts.title, 'How to%')

// Find posts ending with 'Guide'
like(posts.title, '%Guide')
```

### Case-Insensitive ILIKE

Case-insensitive version of LIKE:

```ts title="convex/queries.ts" showLineNumbers {1,8}
import { ilike } from 'better-convex/orm';

export const searchPostsCaseInsensitive = query({
  args: { keyword: v.string() },
  handler: async (ctx, args) => {
    const posts = await db(ctx).query.posts.findMany({
      where: ilike(posts.title, `%${args.keyword}%`),
    });

    return posts; // Matches 'JavaScript', 'javascript', 'JAVASCRIPT', etc.
  },
});
```

### Direct String Operators

For more explicit matching, use dedicated operators:

**startsWith:**
```ts
import { startsWith } from 'better-convex/orm';

const posts = await db(ctx).query.posts.findMany({
  where: startsWith(posts.title, 'How to'),
});
```

**endsWith:**
```ts
import { endsWith } from 'better-convex/orm';

const posts = await db(ctx).query.posts.findMany({
  where: endsWith(posts.title, 'Guide'),
});
```

**contains:**
```ts
import { contains } from 'better-convex/orm';

const posts = await db(ctx).query.posts.findMany({
  where: contains(posts.title, 'JavaScript'),
});
```

### Performance Considerations

<Callout icon={<InfoIcon />}>
**Post-Fetch Filtering** - String operators are applied AFTER fetching rows from Convex. For large tables, consider these strategies:

1. **Use WHERE first to reduce dataset:**
   ```ts
   // ‚úÖ GOOD: Filter by indexed field first
   const posts = await db(ctx).query.posts.findMany({
     where: and(
       eq(posts.published, true),  // Index filter (fast)
       contains(posts.title, 'JavaScript')  // Post-fetch filter
     ),
   });
   ```

2. **Use Convex search indexes for full-text search:**
   ```ts title="convex/schema.ts"
   const posts = convexTable('posts', {
     title: text().notNull(),
     content: text().notNull(),
   }).searchIndex('search_posts', {
     searchField: 'title',
     filterFields: ['published'],
   });
   ```

3. **Combine with limit to reduce post-fetch work:**
   ```ts
   const recentPosts = await db(ctx).query.posts.findMany({
     where: contains(posts.title, 'JavaScript'),
     orderBy: desc(posts._creationTime),
     limit: 20,  // Only filter first 20 results
   });
   ```
</Callout>

### Case Sensitivity

All string operators except `ilike` are **case-sensitive**:

```ts
// ‚úÖ Matches "JavaScript Guide"
contains(posts.title, 'JavaScript')

// ‚ùå Does NOT match "javascript guide"
contains(posts.title, 'JavaScript')

// ‚úÖ Matches both "JavaScript" and "javascript"
ilike(posts.title, '%javascript%')
```

## Relation Loading (Coming Soon)

### Loading with `with:`

The `with:` option for loading related data is planned for M6:

```ts
// üöß NOT YET IMPLEMENTED - Coming in M6
const usersWithPosts = await db(ctx).query.users.findMany({
  with: {
    posts: true, // Will load related posts
  },
});
```

## Column Selection (Not Supported)

<Callout icon={<AlertTriangle />}>
**‚ö†Ô∏è Category 2: Limitation** - Convex always returns full documents. You cannot select specific columns like in SQL.
</Callout>

```ts
// ‚ùå NOT SUPPORTED: Column selection
const users = await db(ctx).query.users.findMany({
  columns: {
    name: true,
    email: true,
  },
});

// ‚úÖ WORKAROUND: Map after fetching
const users = await db(ctx).query.users.findMany();
const nameAndEmail = users.map(u => ({
  name: u.name,
  email: u.email,
}));
```

**Why this limitation?**

Convex is document-oriented, not column-oriented like SQL. Every query returns the full document for performance and consistency. The workaround (mapping after fetch) is negligible overhead since Convex queries are already fast.

## Performance Considerations

### Use Indexes for Filtering

Convex automatically creates indexes for relation fields, but you should create indexes for commonly filtered fields:

```ts title="convex/schema.ts"
import { convexTable, text, integer } from 'better-convex/orm';

const users = convexTable('users', {
  name: text().notNull(),
  role: text().notNull(),
  createdAt: integer(),
});
// Add indexes via convex.index() in schema definition
```

**Query with index:**
```ts
const admins = await db(ctx).query.users.findMany({
  where: eq(users.role, 'admin'), // Uses 'role' index!
});
```

### Avoid N+1 Queries

Use `with` to load relations in a single query:

```ts
// ‚ùå BAD: N+1 query (slow)
const users = await db(ctx).query.users.findMany();
for (const user of users) {
  user.posts = await db(ctx).query.posts.findMany({
    where: eq(posts.userId, user._id),
  });
}

// ‚úÖ GOOD: Load relations with `with` (fast)
const users = await db(ctx).query.users.findMany({
  with: {
    posts: true,
  },
});
```

<Callout icon={<InfoIcon />}>
**Performance Tip**: Convex's edge-based relations are faster than SQL joins. The `with` option loads relations efficiently using indexed queries.
</Callout>

## Common Gotchas

| Issue | Solution |
|-------|----------|
| **`where: eq(field, null)` type error** | Use `isNull(field)` instead - Convex uses `undefined` |
| **`like()` operator not working** | Use Convex search indexes or post-filter results |
| **Slow queries without indexes** | Create indexes for filtered fields |
| **Can't select specific columns** | Map results after fetching - Convex returns full documents |
| **`with:` not working** | Relation loading not yet implemented (M5) |

## Next Steps

<Cards>
  <Card title="Relations" href="/docs/db/orm/relations">
    Learn how to define one-to-one, one-to-many, and many-to-many relations
  </Card>
  <Card title="Schema Definition" href="/docs/db/orm/schema">
    Deep dive into tables and type inference
  </Card>
  <Card title="API Reference" href="/docs/db/orm/api-reference">
    Complete operator and API reference
  </Card>
  <Card title="Limitations" href="/docs/db/orm/limitations">
    Understand current limitations and planned features
  </Card>
</Cards>
