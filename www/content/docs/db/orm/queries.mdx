---
title: Querying Data
description: Query tables with findMany, findFirst, filtering, and relation loading
links:
  doc: https://orm.drizzle.team/docs/rqb-v2
---

import { InfoIcon, CheckCircle, AlertTriangle } from "lucide-react"

Query your Convex database using Drizzle v1’s relational query builder API. Better‑Convex keeps the syntax familiar while adapting to Convex’s document model.

## Setup

These examples assume you attached ORM to `ctx.table` once in your context (see Quickstart).

```ts title="convex/queries.ts"
const db = ctx.table;
```

## Basic Queries

### findMany

```ts title="convex/queries.ts"
export const getAllUsers = query({
  handler: async (ctx) => {
    const db = ctx.table;
    return db.query.users.findMany({ limit: 50 });
  },
});
```

<Callout icon={<InfoIcon />}>
Non-paginated `findMany()` requires explicit sizing: provide `limit`, use `paginate`, set `allowFullScan: true`, or configure `defineSchema(..., { defaults: { defaultLimit } })`.
</Callout>

### findFirst

```ts title="convex/queries.ts"
export const getFirstUser = query({
  handler: async (ctx) => {
    const db = ctx.table;
    return db.query.users.findFirst({
      where: { email: 'alice@example.com' },
    });
  },
});
```

## Filtering With `where`

Use object filters (Drizzle v1 style). The shape mirrors Drizzle but is executed in Convex.

```ts
const admins = await db.query.users.findMany({
  where: {
    role: 'admin',
    lastSeen: { gt: Date.now() - 86_400_000 },
  },
});
```

<Callout icon={<AlertTriangle />}>
SQL-only RQB features like `RAW` filters and `sql.placeholder(...)` are not supported in Convex. `extras` is supported, but computed post-fetch (no SQL computed fields).
</Callout>

<Callout icon={<AlertTriangle />}>
Predicate `where` (function form) runs via stream filtering and requires an explicit `index: { name, range? }` config. There is no implicit full-scan fallback.
</Callout>

### Core Operators

| Operator | Example | Description |
|---|---|---|
| `eq` | `{ role: 'admin' }` or `{ role: { eq: 'admin' } }` | Equals |
| `ne` | `{ status: { ne: 'banned' } }` | Not equal (index-compiled when indexed) |
| `gt` | `{ age: { gt: 18 } }` | Greater than |
| `gte` | `{ credits: { gte: 100 } }` | Greater than or equal |
| `lt` | `{ age: { lt: 65 } }` | Less than |
| `lte` | `{ loginCount: { lte: 10 } }` | Less than or equal |
| `in` | `{ status: { in: ['active', 'pending'] } }` | Value in array (index-compiled when indexed) |
| `notIn` | `{ status: { notIn: ['deleted'] } }` | Value not in array (index-compiled when indexed) |
| `isNull` | `{ deletedAt: { isNull: true } }` | Null/undefined (index-compiled when indexed) |
| `isNotNull` | `{ email: { isNotNull: true } }` | Not null/undefined (index-compiled when indexed) |
| `AND` | `{ AND: [ ... ] }` | Logical AND |
| `OR` | `{ OR: [ ... ] }` | Logical OR (same-field equality OR is index-compiled) |
| `NOT` | `{ NOT: { ... } }` | Logical NOT |

### String Operators

| Operator | Example | Notes |
|---|---|---|
| `like` | `{ title: { like: '%JavaScript%' } }` | Post‑fetch, except `'prefix%'` is index-compiled when indexed |
| `ilike` | `{ title: { ilike: '%javascript%' } }` | Post‑fetch |
| `notLike` | `{ title: { notLike: '%draft%' } }` | Post‑fetch |
| `notIlike` | `{ title: { notIlike: '%draft%' } }` | Post‑fetch |
| `startsWith` | `{ title: { startsWith: 'Intro' } }` | Index range when indexed |
| `endsWith` | `{ title: { endsWith: 'Guide' } }` | Post‑fetch |
| `contains` | `{ title: { contains: 'ORM' } }` | Post‑fetch |

<Callout icon={<InfoIcon />}>
Most string operators run post-fetch. For large datasets, prefer indexed filters first.
`startsWith` and `like('prefix%')` use index ranges when the field is indexed.
</Callout>

### Full-Scan Operators and Workarounds

These operators are still non-index-compiled and require `allowFullScan: true` unless paired with another indexable pre-filter.

| Operator | Scalable workaround |
|---|---|
| `arrayContains`, `arrayContained`, `arrayOverlaps` | Use an inverted/join table keyed by each element and query that index first |
| `contains` | Use `withSearchIndex` or maintain a tokenized denormalized field/table |
| `endsWith` | Store a reversed value column (for example `reversedEmail`) and use `startsWith` on that indexed column |
| `ilike`, `notIlike` | Store a normalized lowercase column and query with `startsWith`/`like('prefix%')` where possible |
| `notLike` | Use an indexed positive pre-filter, then apply `notLike` post-fetch |
| `NOT` (general) | Rewrite to positive indexable predicates when possible; otherwise explicit full-scan opt-in |
| predicate `where: (row) => ...` | Use `index: { name, range? }`; add `paginate.maximumRowsRead` to cap scan cost |

### Logical Filters

```ts
const users = await db.query.users.findMany({
  where: {
    OR: [{ role: 'admin' }, { role: 'premium' }],
    NOT: { status: 'banned' },
  },
});
```

### Relation Filters

You can filter by relation existence or by nested relation conditions.

```ts
// Users with at least one post
const users = await db.query.users.findMany({
  where: { posts: true },
});

// Users with posts whose title starts with "A"
const users2 = await db.query.users.findMany({
  where: { posts: { title: { like: 'A%' } } },
});
```

## Ordering

```ts
const posts = await db.query.posts.findMany({
  orderBy: { _creationTime: 'desc', title: 'asc' },
});
```

You can also use callback syntax (Drizzle-style) with `asc`/`desc` helpers:

```ts
const posts2 = await db.query.posts.findMany({
  orderBy: (posts, { desc, asc }) => [
    desc(posts._creationTime),
    asc(posts.title),
  ],
});
```

**Notes:**
- The first `orderBy` field should have an index for stable ordering
- Secondary sort fields are applied post‑fetch
- When post-fetch sorting is required (multi-field or non-indexable sort), Better-Convex sorts before applying `offset`/`limit`, which requires reading the full filtered candidate set first
- `findMany({ paginate })` uses only the first `orderBy` field for cursor ordering

## Pagination

### Limit / Offset

```ts
const posts = await db.query.posts.findMany({
  limit: 10,
  offset: 20,
});
```

### Cursor Pagination

```ts
return db.query.posts.findMany({
  where: { published: true },
  orderBy: { _creationTime: 'desc' },
  paginate: { cursor: args.cursor ?? null, numItems: 20 },
});
```

## Full-Text Search

Use `search` on `findMany()` / `findFirst()` when your table defines a `searchIndex`.

```ts
const posts = await db.query.posts.findMany({
  search: {
    index: 'text_search',
    query: 'galaxy',
    filters: { type: 'news' },
  },
  paginate: { cursor: null, numItems: 20 },
});
```

`search.filters` is typed from the selected index `filterFields`.
`search` is only available on tables that declare at least one `searchIndex`.

**Search mode constraints**
- `orderBy` is not allowed (Convex relevance ordering is used)
- `where: (row) => ...` is not allowed
- relation-based `where` is not allowed
- object `where` on base table fields is allowed (post-search filter)
- `with` is allowed for eager loading

## Choosing Filter vs Paginate

Use this decision matrix to avoid accidental full scans.

| Goal | Recommended Tool | Notes |
|---|---|---|
| Simple filters, no pagination | `db.query.*.findMany({ where, limit })` | Uses index compilation when possible; non-paginated reads must be sized |
| Complex JS predicate, no pagination | `db.query.*.findMany({ where: (row) => ..., index: { name: 'by_field' }, limit: 100 })` | Explicit index required; non-paginated reads must be sized |
| Complex JS predicate + pagination | `db.query.*.findMany({ where: (row) => ..., index: { name: 'by_field' }, paginate: { cursor, numItems, maximumRowsRead } })` | Explicit index + bounded scan |
| Large lists | `db.query.*.findMany({ paginate })` | First `orderBy` field should be indexed |
| Search + equality filters | `db.query.*.findMany({ search: { index, query, filters? } })` | `filters` must be in search index `filterFields` |

## Relation Loading With `with`

```ts
const users = await db.query.users.findMany({
  with: {
    posts: {
      limit: 5,
      offset: 2,
      orderBy: { _creationTime: 'desc' },
    },
  },
});
```

<Callout icon={<InfoIcon />}>
Relation filters for `many()` are applied post‑fetch. Nested `with` has a depth limit to prevent infinite recursion.
</Callout>

<Callout icon={<InfoIcon />}>
`limit` and `offset` in `with` apply per parent relation, not globally.
</Callout>

<Callout icon={<InfoIcon />}>
For `many()` relations, provide `with.<relation>.limit` or set `defineSchema(..., { defaults: { defaultLimit } })`. Otherwise, use `allowFullScan: true` on the parent query.
</Callout>

## Column Selection

```ts
const users = await db.query.users.findMany({
  columns: { name: true, email: true },
});
```

<Callout icon={<AlertTriangle />}>
`columns` is a post‑fetch projection. Convex still reads full documents.
</Callout>

## Extras (Computed Fields)

`extras` lets you attach computed properties to rows at query time.

```ts
const users = await db.query.users.findMany({
  extras: {
    emailDomain: (row) => row.email.split('@')[1]!,
  },
});
```

Extras are computed in JavaScript after fetching documents (and after `with` relations are loaded). They can’t be used in `where`/`orderBy` and should be treated as post-fetch helpers.

## Performance Tips

- Add `index('...').on(t.field)` for fields used in filters or primary ordering
- Use `findMany({ paginate })` for large lists
- Prefer `with` over per‑row queries to avoid N+1

## Common Gotchas

| Issue | Fix |
|---|---|
| `where` expects an object | Use `where: { field: value }` |
| `eq(field, null)` | Use `{ isNull: true }` |
| Slow ordering | Add an index on the primary `orderBy` field |
| `columns` doesn’t reduce reads | Projection is post‑fetch |
| Relations not loading | Ensure `ormEdges` are used when building `ctx.table` |
