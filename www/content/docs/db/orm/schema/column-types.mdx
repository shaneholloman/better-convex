---
title: Columns
description: ORM column builders (Drizzle-style) and their TypeScript types
---

import { InfoIcon, AlertTriangle } from "lucide-react"

In this guide, we'll learn how to define document fields using Drizzle-style column builders. You'll master string, number, boolean, and reference fields, column hooks like `$defaultFn`, and advanced types like `custom()` and `json<T>()`.

<Callout icon={<AlertTriangle />}>
The ORM documents a **Convex subset** of Drizzle's PostgreSQL column types. SQL-specific types (timestamps, decimals, database enums, etc.) are not available. For Convex-native arbitrary values, use `custom()` / `json()` and validate shape with `convex/values` validators.
</Callout>

## Column Names

In Drizzle, you can optionally provide a database column name (`text('email')`) that can differ from the TypeScript key. In the ORM, the **TypeScript key is the document field name**.

Here's how to define a simple table with a required email field:

```ts showLineNumbers
import { convexTable, text } from 'better-convex/orm';

export const users = convexTable('users', {
  email: text().notNull(),
});
```

<Callout icon={<InfoIcon />}>
**Note:** Column builders still accept an optional `name` parameter for Drizzle parity, but it's usually unnecessary in Convex schemas.
</Callout>

## Type Rules (Select vs Insert)

The ORM mirrors Drizzle's core inference rules:

- **Select** (`$inferSelect`, `InferSelectModel`): fields are `T | null` unless `.notNull()` is set
- **Insert** (`$inferInsert`, `InferInsertModel`): required if `.notNull()` and **no** `.default()`, `$defaultFn()`, or `$onUpdateFn()`, otherwise optional

Let's see how these rules work in practice:

```ts showLineNumbers {3-5}
import { convexTable, text, integer, InferInsertModel, InferSelectModel } from 'better-convex/orm';

const posts = convexTable('posts', {
  title: text().notNull(),
  status: text().notNull().default('draft'),
  viewCount: integer(),
});

type Post = InferSelectModel<typeof posts>;
//   ^? { id, _creationTime, title: string, status: string, viewCount: number | null }

type NewPost = InferInsertModel<typeof posts>;
//   ^? { title: string; status?: string | undefined; viewCount?: number | undefined }
```

<Callout icon={<InfoIcon />}>
**Tip:** Fields are nullable by default. Use `.notNull()` to make a field required on select, and add `.default()` to make it optional on insert.
</Callout>

## Column Hooks (Defaults and Type Overrides)

The ORM supports Drizzle-style column hooks for common patterns like timestamps and JSON blobs.

Here's how to use `$defaultFn`, `$onUpdateFn`, and `json<T>()` together:

```ts showLineNumbers {4-6}
import { convexTable, integer, json, text } from 'better-convex/orm';

const users = convexTable('users', {
  email: text().notNull(),
  createdAt: integer().notNull().$defaultFn(() => Date.now()),
  updatedAt: integer().notNull().$onUpdateFn(() => Date.now()),
  metadata: json<Record<string, unknown>>(),
});
```

The available hooks are:

- `$type<T>()` -- a type-only override (no runtime validation)
- `$defaultFn(fn)` / `$default(fn)` -- runs on insert when the value is omitted
- `$onUpdateFn(fn)` / `$onUpdate(fn)` -- runs on update when the field is not explicitly set (and can also fill missing values on insert)

<Callout icon={<AlertTriangle />}>
**Important:** These hooks run only through ORM mutations. Direct `ctx.db` writes bypass them.
</Callout>

## Builder Reference

### `text()`

Represents a string field.

```ts showLineNumbers
import { convexTable, text } from 'better-convex/orm';

const users = convexTable('users', {
  name: text().notNull(), // string
  bio: text(),            // string | null
});
```

### `textEnum(values)`

Defines an enum-like string field, validated at runtime and inferred as a string union in TypeScript.

```ts showLineNumbers
import { convexTable, textEnum } from 'better-convex/orm';

const users = convexTable('users', {
  role: textEnum(['admin', 'member'] as const).notNull(),
});
```

### `integer()`

Represents a numeric field. In Convex, `integer()` maps to `v.number()` (Float64).

```ts showLineNumbers
import { convexTable, integer } from 'better-convex/orm';

const events = convexTable('events', {
  retries: integer().notNull(),
  score: integer(),
});
```

### `boolean()`

Represents a boolean field.

```ts showLineNumbers
import { convexTable, boolean } from 'better-convex/orm';

const flags = convexTable('flags', {
  enabled: boolean().notNull(),
  beta: boolean(),
});
```

### `bigint()`

Represents a 64-bit integer field. In Convex, `bigint()` maps to `v.int64()` and uses JavaScript `bigint`.

```ts showLineNumbers
import { convexTable, bigint } from 'better-convex/orm';

const ledger = convexTable('ledger', {
  balance: bigint().notNull(),
});
```

### `bytes()`

Represents a binary field (`ArrayBuffer`).

```ts showLineNumbers
import { bytes, convexTable } from 'better-convex/orm';

const files = convexTable('files', {
  data: bytes().notNull(),
});
```

### `id('table')`

Represents a reference to another table (`Id<'table'>`).

```ts showLineNumbers
import { convexTable, id, text } from 'better-convex/orm';

const posts = convexTable('posts', {
  title: text().notNull(),
  authorId: id('users').notNull(),
});
```

<Callout icon={<InfoIcon />}>
**Note:** `id('users')` is a typed reference. It does **not** create a SQL foreign key constraint. Use `.references()` or `foreignKey()` for ORM-enforced foreign keys.
</Callout>

### `vector(dimensions)`

Represents an embedding vector (`number[]`) and is used with `vectorIndex()`.

```ts showLineNumbers
import { convexTable, vector } from 'better-convex/orm';

const posts = convexTable('posts', {
  embedding: vector(1536).notNull(),
});
```

### `custom(validator)`

Use `custom()` to wrap any Convex validator and get end-to-end TypeScript inference.

```ts showLineNumbers
import { convexTable, custom } from 'better-convex/orm';
import { v } from 'convex/values';

const events = convexTable('events', {
  payload: custom(
    v.object({
      type: v.string(),
      data: v.any(),
    })
  ),
});
```

### `json<T>()`

`json<T>()` is a convenience wrapper around `custom(v.any()).$type<T>()`.

```ts showLineNumbers
import { convexTable, json } from 'better-convex/orm';

const posts = convexTable('posts', {
  metadata: json<{ tags: string[] }>(),
});
```

<Callout icon={<InfoIcon />}>
**Note:** `json()` is **not** SQL `jsonb`. It's a Convex `v.any()` value with a TypeScript type annotation.
</Callout>

## Not Supported

These Drizzle (SQL) column type categories don't map to Convex documents and are not supported:

- SQL timestamps/dates and database-side timezone semantics
- SQL decimals/numerics
- SQL database enums (use `textEnum(...)`)
- SQL arrays (beyond `vector(...)` embeddings)
- Custom SQL types

You now know every column builder available in the ORM. From basic primitives to typed references and custom validators, these builders give you full control over your document shape with end-to-end TypeScript inference.

## Next Steps

<Cards>
  <Card title="Indexes & Constraints" href="/docs/db/orm/schema/indexes-constraints" />
  <Card title="Operators (Filters)" href="/docs/db/orm/queries/operators" />
  <Card title="Schema" href="/docs/db/orm/schema" />
</Cards>
