---
title: Update
description: Update rows with Drizzle-style builders (Better-Convex ORM)
links:
  doc: https://orm.drizzle.team/docs/update
---

import { InfoIcon, AlertTriangle } from "lucide-react"

Better-Convex ORM provides a Drizzle-style `update()` builder for Convex mutations.

<Callout icon={<AlertTriangle />}>
`update()` without `.where(...)` throws unless you call `.allowFullScan()`.  
`strict` controls warning behavior, not whether full scans are allowed.
</Callout>

## Basic Update

```ts title="convex/mutations.ts"
import { mutation } from './_generated/server';
import { v } from 'convex/values';
import { eq } from 'better-convex/orm';
import { users } from './schema';

export const renameUser = mutation({
  args: { userId: v.id('users'), name: v.string() },
  handler: async (ctx, args) => {
    const db = ctx.table;

    await db
      .update(users)
      .set({ name: args.name })
      .where(eq(users._id, args.userId));
  },
});
```

## Returning

```ts
const updated = await db
  .update(users)
  .set({ name: 'Mr. Dan' })
  .where(eq(users.email, 'dan@example.com'))
  .returning();

const ids = await db
  .update(users)
  .set({ name: 'Mr. Dan' })
  .where(eq(users.email, 'dan@example.com'))
  .returning({ id: users._id });
```

## Safety Limits

`update()` collects matching rows in bounded pages before applying writes:

- `mutationBatchSize`: defaults to `100`
- `mutationMaxRows`: defaults to `1000`

If matched rows exceed `mutationMaxRows`, update throws.

```ts
export default defineSchema({ users, posts }, {
  defaults: {
    mutationBatchSize: 200,
    mutationMaxRows: 5000,
  },
});
```

## Paginated Update Execution

For large workloads, process updates page-by-page with `paginate({ cursor, numItems })`.
This follows Convexâ€™s batching pattern and avoids one large transaction.

```ts
const page1 = await db
  .update(users)
  .set({ role: 'member' })
  .where(eq(users.status, 'pending'))
  .paginate({ cursor: null, numItems: 100 });

if (!page1.isDone) {
  const page2 = await db
    .update(users)
    .set({ role: 'member' })
    .where(eq(users.status, 'pending'))
    .paginate({ cursor: page1.continueCursor, numItems: 100 });
}
```

Paged update result:
- `continueCursor`: cursor for the next batch
- `isDone`: `true` when no more pages remain
- `numAffected`: rows updated in this page
- `page`: returned rows for this page (only when `.returning()` is used)

<Callout icon={<InfoIcon />}>
`paginate()` currently supports single-range index plans. Multi-probe filters (`inArray`, some `OR` patterns, complement ranges) are not yet supported in paged mutation mode.
</Callout>

## Drizzle Differences

<Callout icon={<AlertTriangle />}>
- SQL-only features like `limit`, `orderBy`, `UPDATE ... FROM`, and `WITH` clauses are not applicable
- Values of `undefined` are not supported by Convex documents; omit keys instead
</Callout>

<Callout icon={<InfoIcon />}>
Unique constraints, foreign keys, and RLS policies are enforced at runtime for ORM mutations. Direct `ctx.db.patch(...)` bypasses these checks.
</Callout>
