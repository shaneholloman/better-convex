---
title: Update
description: Update rows with Drizzle-style builders (Better-Convex ORM)
links:
  doc: https://orm.drizzle.team/docs/update
---

import { InfoIcon, AlertTriangle } from "lucide-react"

Better-Convex ORM provides a Drizzle-style `update()` builder for Convex mutations.

<Callout icon={<AlertTriangle />}>
`update()` without `.where(...)` throws unless you call `.allowFullScan()`.  
`strict` controls warning behavior, not whether full scans are allowed.
</Callout>

## Basic Update

```ts title="convex/mutations.ts"
import { mutation } from './_generated/server';
import { v } from 'convex/values';
import { eq } from 'better-convex/orm';
import { users } from './schema';

export const renameUser = mutation({
  args: { userId: v.id('users'), name: v.string() },
  handler: async (ctx, args) => {
    const db = ctx.orm;

    await db
      .update(users)
      .set({ name: args.name })
      .where(eq(users._id, args.userId));
  },
});
```

## Returning

```ts
const updated = await db
  .update(users)
  .set({ name: 'Mr. Dan' })
  .where(eq(users.email, 'dan@example.com'))
  .returning();

const ids = await db
  .update(users)
  .set({ name: 'Mr. Dan' })
  .where(eq(users.email, 'dan@example.com'))
  .returning({ id: users._id });
```

## Safety Limits

`update()` collects matching rows in bounded pages before applying writes:

- `mutationBatchSize`: defaults to `100`
- `mutationLeafBatchSize`: defaults to `900` (async FK fan-out batch size)
- `mutationMaxRows`: defaults to `1000`
- `mutationMaxBytesPerBatch`: defaults to `2_097_152` (async measured-byte budget)
- `mutationScheduleCallCap`: defaults to `100` (async schedule calls per mutation)

If matched rows exceed `mutationMaxRows`, update throws.

```ts
export default defineSchema({ users, posts }, {
  defaults: {
    mutationBatchSize: 200,
    mutationMaxRows: 5000,
  },
});
```

## Paginated Update Execution

For large workloads, process updates page-by-page with `paginate({ cursor, numItems })`.
This follows Convex’s batching pattern and avoids one large transaction.

```ts
const page1 = await db
  .update(users)
  .set({ role: 'member' })
  .where(eq(users.status, 'pending'))
  .paginate({ cursor: null, numItems: 100 });

if (!page1.isDone) {
  const page2 = await db
    .update(users)
    .set({ role: 'member' })
    .where(eq(users.status, 'pending'))
    .paginate({ cursor: page1.continueCursor, numItems: 100 });
}
```

Paged update result:
- `continueCursor`: cursor for the next batch
- `isDone`: `true` when no more pages remain
- `numAffected`: rows updated in this page
- `page`: returned rows for this page (only when `.returning()` is used)

<Callout icon={<InfoIcon />}>
`paginate()` currently supports single-range index plans. Multi-probe filters (`inArray`, some `OR` patterns, complement ranges) are not yet supported in paged mutation mode.
</Callout>

## Async Batched Update

Use async mode when a mutation can affect large sets.

- Per call: `execute({ mode: 'async' })`
- Convenience alias: `executeAsync(...)`
- Global default: `defineSchema(..., { defaults: { mutationExecutionMode: 'async' } })`

Async mode runs the first update batch in the current mutation, then schedules remaining batches through Convex scheduler.

```ts
const firstBatch = await db
  .update(users)
  .set({ role: 'member' })
  .where(eq(users.status, 'pending'))
  .returning({ id: users._id })
  .execute({ mode: 'async', batchSize: 200, delayMs: 0 });
```

Important behavior:
- `execute()` in async mode returns the same type shape as sync `execute()` (with `.returning()`, rows from the first batch only).
- Remaining batches are scheduled asynchronously.
- Explicit async APIs (`execute({ mode: 'async' })` / `executeAsync()`) cannot be combined with `.paginate()`.
- `.paginate()` remains the caller-controlled execution path.
- `batchSize` resolves as: per-call `batchSize` → `defaults.mutationBatchSize` → `100`.
- `delayMs` resolves as: per-call `delayMs` → `defaults.mutationAsyncDelayMs` → `0`.
- Async FK update fan-out (`onUpdate: 'cascade'`, `set null`, `set default`) uses `mutationLeafBatchSize`.
- Async fan-out stops at `mutationMaxBytesPerBatch` and may throw after `mutationScheduleCallCap` schedule calls in one mutation invocation.

Async execution requires wiring `scheduler` + `scheduledMutationBatch` when building `ctx.orm`.

## Drizzle Differences

<Callout icon={<AlertTriangle />}>
- SQL-only features like `limit`, `orderBy`, `UPDATE ... FROM`, and `WITH` clauses are not applicable
- Values of `undefined` are not supported by Convex documents; omit keys instead
</Callout>

<Callout icon={<InfoIcon />}>
Unique constraints, foreign keys, and RLS policies are enforced at runtime for ORM mutations. Direct `ctx.db.patch(...)` bypasses these checks.
</Callout>
