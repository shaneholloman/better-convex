---
title: Migrate from native Convex
description: Move from ctx.db queries/mutations to Better-Convex ORM + cRPC
---

import { InfoIcon, AlertTriangle } from "lucide-react"

This guide maps native Convex database access (`ctx.db`) to Better-Convex ORM (`ctx.orm`).
The "after" snippets use better-convex cRPC procedures.

<Callout icon={<InfoIcon />}>
If you're new to cRPC, start with [/docs/server/procedures](/docs/server/procedures).
</Callout>

## Migration Checklist

- Define tables with `convexTable()` (and indexes you query on)
- Define relations with `defineRelations()`
- Attach ORM to `ctx.orm` once in your context (see [/docs/db/orm/quickstart](/docs/db/orm/quickstart))
- Replace `ctx.db.get/query/...` reads with `ctx.orm.query.*.findMany/findFirst`
- Replace `ctx.db.insert/patch/replace/delete` writes with ORM mutation builders
- Keep `ctx.db.system` for system tables (or use ORM passthrough `ctx.orm.system`)

## Reading A Single Document

<Compare>
  <CompareItem title="Before (native Convex `db.get`)">
    ```ts title="convex/functions/users.ts" showLineNumbers
    import { query } from './_generated/server';
    import { v } from 'convex/values';

    export const getById = query({
      args: { userId: v.id('users') },
      handler: async (ctx, args) => {
        return ctx.db.get('users', args.userId);
      },
    });
    ```
  </CompareItem>
  <CompareItem title="After (ORM + cRPC)">
    ```ts title="convex/functions/users.ts" showLineNumbers {2-4,7-11}
    import { z } from 'zod';
    import { zid } from 'convex-helpers/server/zod4';
    import { publicQuery } from '../lib/crpc';

    export const getById = publicQuery
      .input(z.object({ userId: zid('users') }))
      .query(async ({ ctx, input }) => {
        return ctx.orm.query.users.findFirst({ where: { _id: input.userId } });
      });
    ```
  </CompareItem>
</Compare>

## Querying Documents

### Basic List

<Compare>
  <CompareItem title="Before (`db.query(...).collect()`)">
    ```ts showLineNumbers
    const users = await ctx.db.query('users').collect();
    ```
  </CompareItem>
  <CompareItem title="After (`findMany`)">
    ```ts showLineNumbers
    const users = await ctx.orm.query.users.findMany({ limit: 50 });
    ```
  </CompareItem>
</Compare>

<Callout icon={<AlertTriangle />}>
ORM `findMany()` must be explicitly sized: use `limit`, use cursor pagination (`cursor` + `limit`), set a schema `defaultLimit`, or opt in with `allowFullScan`.
</Callout>

<Callout icon={<InfoIcon />}>
Nullable columns in ORM come back as `null` (SQL-style). In native Convex, optional fields are often missing (`undefined`).
If your API schema uses Zod `.optional()`, normalize with `field: row.field ?? undefined` (or use `.nullish()`).
</Callout>

### Filtering (`filter(...)` → `where`)

<Compare>
  <CompareItem title="Before (FilterBuilder)">
    ```ts showLineNumbers
    const adults = await ctx.db
      .query('users')
      .filter((q) => q.gte(q.field('age'), 18))
      .collect();
    ```
  </CompareItem>
  <CompareItem title="After (object `where`)">
    ```ts showLineNumbers {3-6}
    const adults = await ctx.orm.query.users.findMany({
      where: { age: { gte: 18 } },
      limit: 50,
    });
    ```
  </CompareItem>
</Compare>

For complex JavaScript predicates, Better-Convex supports predicate `where`, but it requires an explicit `index: { name, range? }` plan and should be bounded with `maxScan` (cursor pagination only).
See [/docs/db/orm/queries#filtering-with-where](/docs/db/orm/queries#filtering-with-where).

### Indexes (`withIndex`) and Ordering

<Compare>
  <CompareItem title="Before (`withIndex`)">
    ```ts showLineNumbers {4}
    const posts = await ctx.db
      .query('posts')
      .withIndex('by_user', (q) => q.eq('userId', args.userId))
      .order('desc')
      .take(20);
    ```
  </CompareItem>
  <CompareItem title="After (`findMany`)">
    ```ts showLineNumbers {2-5}
    const posts = await ctx.orm.query.posts.findMany({
      where: { userId: input.userId },
      orderBy: { _creationTime: 'desc' },
      limit: 20,
    });
    ```
  </CompareItem>
</Compare>

In native Convex you must explicitly choose `.withIndex(...)`. In ORM, queries are index-backed when possible based on your `where`/`orderBy` and schema indexes.

## ORM to native Convex parity (manual joins)

Better-Convex ORM gives you Drizzle-style relation loading with `with:` and nested `with:`. Native Convex doesn't have joins, so you manually load related documents and assemble the shape in JavaScript.

The patterns below are the native equivalents for common ORM queries (including nested joins). These snippets can be used inside vanilla Convex procedures **or** inside cRPC handlers.

### Eager-load a `one()` relation (`with: { author: true }`)

<Compare>
  <CompareItem title="ORM (`ctx.orm` + `with:`)">
    ```ts showLineNumbers {2-7}
    const posts = await ctx.orm.query.posts.findMany({
      orderBy: { _creationTime: 'desc' },
      limit: 20,
      with: { author: true },
    });
    ```
  </CompareItem>
  <CompareItem title="Native Convex (`ctx.db`)">
    ```ts showLineNumbers {1,7-11,13-16}
    const posts = await ctx.db.query('posts').order('desc').take(20);

    const authorIds = [...new Set(posts.map((p) => p.userId))];
    const authors = await Promise.all(
      authorIds.map((id) => ctx.db.get('users', id))
    );
    const authorById = new Map(
      authors.filter(Boolean).map((u) => [u._id, u])
    );

    const postsWithAuthor = posts.map((p) => ({
      ...p,
      author: authorById.get(p.userId) ?? null,
    }));
    ```
  </CompareItem>
</Compare>

This is the general pattern for "many-to-one": load base rows, dedupe foreign keys, `db.get(...)` the referenced docs, then attach.

### Eager-load a `many()` relation (`with: { posts: { ... } }`)

<Compare>
  <CompareItem title="ORM (`with: { posts: { limit, orderBy } }`)">
    ```ts showLineNumbers {2-8}
    const users = await ctx.orm.query.users.findMany({
      limit: 10,
      with: {
        posts: { limit: 5, orderBy: { _creationTime: 'desc' } },
      },
    });
    ```
  </CompareItem>
  <CompareItem title="Native Convex (index query per parent)">
    ```ts showLineNumbers {1-3,7-16}
    // Schema: index('by_user').on(t.userId) on posts table
    const users = await ctx.db.query('users').take(10);

    const postsByUserId = new Map(
      await Promise.all(
        users.map(async (u) => [
          u._id,
          await ctx.db
            .query('posts')
            .withIndex('by_user', (q) => q.eq('userId', u._id))
            .order('desc')
            .take(5),
        ])
      )
    );

    const usersWithPosts = users.map((u) => ({
      ...u,
      posts: postsByUserId.get(u._id) ?? [],
    }));
    ```
  </CompareItem>
</Compare>

Native Convex can do this efficiently when the child table is indexed by the FK (`posts.userId`). The tradeoff is N queries (one per parent) unless you denormalize or restructure.

### Nested joins (many-to-many join table + payload)

This mirrors ORM nested `with:` like: `users -> memberships -> group`.

<Compare>
  <CompareItem title="ORM (nested `with:`)">
    ```ts showLineNumbers {2-10}
    const usersWithGroups = await ctx.orm.query.users.findMany({
      limit: 10,
      with: {
        memberships: {
          columns: { role: true, joinedAt: true },
          with: { group: true },
        },
      },
    });
    ```
  </CompareItem>
  <CompareItem title="Native Convex (manual join)">
    ```ts showLineNumbers {1-2,6-18,20-27,29-35}
    // Schema:
    // - memberships: index('by_user').on(t.userId)
    // - groups: primary key lookup via db.get('groups', id)
    const users = await ctx.db.query('users').take(10);

    const membershipsByUserId = new Map();
    const allMemberships = [];
    for (const u of users) {
      const rows = await ctx.db
        .query('memberships')
        .withIndex('by_user', (q) => q.eq('userId', u._id))
        .collect();
      membershipsByUserId.set(u._id, rows);
      allMemberships.push(...rows);
    }

    const groupIds = [...new Set(allMemberships.map((m) => m.groupId))];
    const groups = await Promise.all(groupIds.map((id) => ctx.db.get('groups', id)));
    const groupById = new Map(groups.filter(Boolean).map((g) => [g._id, g]));

    const usersWithGroups = users.map((u) => ({
      ...u,
      memberships: (membershipsByUserId.get(u._id) ?? []).map((m) => ({
        role: m.role,
        joinedAt: m.joinedAt,
        group: groupById.get(m.groupId) ?? null,
      })),
    }));
    ```
  </CompareItem>
</Compare>

This is what "nested `with:`" looks like without ORM: join-table lookup(s) plus a second hop to fetch referenced rows.

### Relation existence filters (`where: { posts: true }`)

ORM supports relation existence filters:

```ts showLineNumbers
await ctx.orm.query.users.findMany({
  where: { posts: true },
  limit: 50,
});
```

Native Convex can't filter one table by "has related rows" without either:
- **Denormalization** (recommended): maintain a `postCount` / `hasPosts` field on `users` and index it.
- **Per-row checks** (ok for a single user, not for lists): query the child table with `.take(1)`.

Example: **single user** "has posts?" check:

```ts showLineNumbers {2-5}
const hasPosts =
  (await ctx.db
    .query('posts')
    .withIndex('by_user', (q) => q.eq('userId', userId))
    .take(1)).length > 0;
```

Example: **denormalize** `hasPosts` on create/delete:

```ts showLineNumbers {5,12}
// When creating a post:
await ctx.db.insert('posts', { userId, title, body });
await ctx.db.patch('users', userId, { hasPosts: true });

// When deleting the last post:
const remaining = await ctx.db
  .query('posts')
  .withIndex('by_user', (q) => q.eq('userId', userId))
  .take(1);
if (remaining.length === 0) {
  await ctx.db.patch('users', userId, { hasPosts: false });
}
```

### Cross-table filters (relation-based `where`)

ORM can filter a parent table based on child conditions (example: "users who have at least one published post"):

```ts showLineNumbers
await ctx.orm.query.users.findMany({
  where: { posts: { published: true } },
  limit: 50,
});
```

Native Convex has no join / `exists` operator, so your options are:
- **Denormalize** (recommended): store `hasPublishedPosts` (or a counter) on `users` and index it.
- **Two-phase query** (ok when the candidate set is naturally small): query `posts`, dedupe `userId`s, then `db.get('users', id)` those users.

Two-phase example:

```ts showLineNumbers {1-2,4-9}
// Requires: index('by_published').on(t.published) on posts
const posts = await ctx.db
  .query('posts')
  .withIndex('by_published', (q) => q.eq('published', true))
  .take(200);

const userIds = [...new Set(posts.map((p) => p.userId))].slice(0, 50);
const users = (await Promise.all(userIds.map((id) => ctx.db.get('users', id)))).filter(Boolean);
```

### `columns` and `extras` (projection + computed fields)

`columns` and `extras` are post-fetch helpers in ORM. In native Convex, you do the same projection in JavaScript:

<Compare>
  <CompareItem title="ORM (`columns` + `extras`)">
    ```ts showLineNumbers {2-7}
    const users = await ctx.orm.query.users.findMany({
      columns: { name: true, email: true },
      extras: {
        emailDomain: (row) => row.email.split('@')[1]!,
      },
    });
    ```
  </CompareItem>
  <CompareItem title="Native Convex (map)">
    ```ts showLineNumbers {2-6}
    const users = await ctx.db.query('users').take(50);
    const projected = users.map((u) => ({
      name: u.name,
      email: u.email,
      emailDomain: u.email.split('@')[1]!,
    }));
    ```
  </CompareItem>
</Compare>

### ORM-only guarantees (constraints, defaults, RLS)

These are ORM features with no native `ctx.db` equivalent:
- **RLS policies** (`rlsPolicy(...)`) — native Convex requires manual authorization checks in every query/mutation.
- **Runtime constraints & defaults** (unique/FK/check/defaults) — direct `ctx.db` writes bypass all ORM enforcement.

If you want to stay on native Convex but approximate ORM constraints, the usual pattern is:
1. Define an index for the constraint (example: `uniqueIndex('by_username').on(t.username)`),
2. Check the index in the mutation, then
3. Insert/patch, and be prepared to handle races under concurrency.

#### Upsert by unique field

<Compare>
  <CompareItem title="ORM (`onConflictDoUpdate`)">
    ```ts showLineNumbers {1-7}
    const [row] = await ctx.orm
      .insert(users)
      .values({ email: input.email, name: input.name })
      .onConflictDoUpdate({
        target: users.email,
        set: { name: input.name },
      })
      .returning({ id: users._id });
    ```
  </CompareItem>
  <CompareItem title="Native Convex (manual)">
    ```ts showLineNumbers {1-4,6-11}
    // Schema: index('by_email').on(t.email) on users
    const existing = await ctx.db
      .query('users')
      .withIndex('by_email', (q) => q.eq('email', input.email))
      .unique();

    if (existing) {
      await ctx.db.patch('users', existing._id, { name: input.name });
      return existing._id;
    }
    return await ctx.db.insert('users', { email: input.email, name: input.name });
    ```
  </CompareItem>
</Compare>

#### Cascade delete

<Compare>
  <CompareItem title="ORM (FK actions / cascade fan-out)">
    ```ts showLineNumbers
    await ctx.orm.delete(users).where(eq(users._id, userId)).cascade({ mode: 'hard' });
    ```
  </CompareItem>
  <CompareItem title="Native Convex (manual cleanup)">
    ```ts showLineNumbers {1-5,7}
    // Schema: index('by_user').on(t.userId) on posts
    const posts = await ctx.db
      .query('posts')
      .withIndex('by_user', (q) => q.eq('userId', userId))
      .collect();
    for (const post of posts) await ctx.db.delete('posts', post._id);

    await ctx.db.delete('users', userId);
    ```
  </CompareItem>
</Compare>

## Pagination

<Compare>
  <CompareItem title="Before (`paginate(paginationOpts)`)">
    ```ts title="convex/functions/posts.ts" showLineNumbers {3-7,11}
    import { query } from './_generated/server';
    import { paginationOptsValidator } from 'convex/server';

    export const list = query({
      args: { paginationOpts: paginationOptsValidator },
      handler: async (ctx, args) => {
        return ctx.db.query('posts').order('desc').paginate(args.paginationOpts);
      },
    });
    ```
  </CompareItem>
  <CompareItem title="After (`findMany({ cursor, limit })`)">
    ```ts title="convex/functions/posts.ts" showLineNumbers {2-4,8-12}
    import { z } from 'zod';
    import { publicQuery } from '../lib/crpc';

    export const list = publicQuery
      .input(z.object({ cursor: z.string().nullable() }))
      .query(async ({ ctx, input }) => {
        return ctx.orm.query.posts.findMany({
          orderBy: { _creationTime: 'desc' },
          cursor: input.cursor,
          limit: 20,
        });
      });
    ```
  </CompareItem>
</Compare>

The ORM pagination result matches Convex: `{ page, continueCursor, isDone }`.

If you want the cRPC procedure itself to standardize pagination input/output, use `publicQuery.paginated(...)`.
See [/docs/server/procedures#paginated-queries](/docs/server/procedures#paginated-queries).

## Full-Text Search

<Compare>
  <CompareItem title="Before (`withSearchIndex`)">
    ```ts showLineNumbers {4-6}
    const messages = await ctx.db
      .query('messages')
      .withSearchIndex('search_body', (q) =>
        q.search('body', args.query).eq('channel', '#general')
      )
      .take(10);
    ```
  </CompareItem>
  <CompareItem title="After (`findMany({ search })`)">
    ```ts showLineNumbers {2-9}
	    const messages = await ctx.orm.query.messages.findMany({
	      search: {
	        index: 'search_body',
	        query: input.query,
	        filters: { channel: '#general' },
	      },
	      cursor: null,
	      limit: 10,
	    });
	    ```
  </CompareItem>
</Compare>

Search mode uses Convex relevance ordering (no `orderBy`). See [/docs/db/orm/queries#full-text-search](/docs/db/orm/queries#full-text-search).

## Vector Search

Native Convex vector search runs only in actions via `ctx.vectorSearch(...)`.
Since actions don't have `ctx.db`, the typical pattern is: vector search in the action, then `runQuery(...)` to load documents.

<Compare>
  <CompareItem title="Before (native Convex)">
    ```ts title="convex/functions/posts.ts" showLineNumbers {2-4,14-19}
    import { v } from 'convex/values';
    import { action, internalQuery } from './_generated/server';
    import { internal } from './_generated/api';

    export const fetchByIds = internalQuery({
      args: { ids: v.array(v.id('posts')) },
      handler: async (ctx, args) => {
        const rows = [];
        for (const id of args.ids) {
          const doc = await ctx.db.get('posts', id);
          if (doc) rows.push(doc);
        }
        return rows;
      },
    });

    export const similarPosts = action({
      args: { embedding: v.array(v.number()) },
      handler: async (ctx, args) => {
        const hits = await ctx.vectorSearch('posts', 'embedding_vec', {
          vector: args.embedding,
          limit: 10,
        });
        return ctx.runQuery(internal.posts.fetchByIds, {
          ids: hits.map((h) => h._id),
        });
      },
    });
    ```
  </CompareItem>
  <CompareItem title="After (ORM + cRPC)">
    ```ts title="convex/functions/posts.ts" showLineNumbers {2-7,16-28}
    import { z } from 'zod';
    import { zid } from 'convex-helpers/server/zod4';
    import { internal } from './_generated/api';
    import { publicAction, privateQuery } from '../lib/crpc';

    export const fetchByIds = privateQuery
      .input(z.object({ ids: z.array(zid('posts')) }))
      .query(async ({ ctx, input }) => {
        return ctx.orm.query.posts.findMany({
          where: { _id: { in: input.ids } },
          limit: input.ids.length,
          with: { author: true },
        });
      });

    export const similarPosts = publicAction
      .input(z.object({ embedding: z.array(z.number()) }))
      .action(async ({ ctx, input }) => {
        const hits = await ctx.vectorSearch('posts', 'embedding_vec', {
          vector: input.embedding,
          limit: 10,
          filter: (q) => q.eq('type', 'news'),
        });

        const rows = await ctx.runQuery(internal.posts.fetchByIds, {
          ids: hits.map((h) => h._id),
        });

        const scoreById = new Map(hits.map((h) => [String(h._id), h._score]));
        return rows.map((row) => ({
          ...row,
          _score: scoreById.get(String(row._id)) ?? 0,
        }));
      });
    ```
  </CompareItem>
</Compare>

See [/docs/db/orm/queries#vector-search](/docs/db/orm/queries#vector-search) for the ORM vector-search API and constraints.

## Writing Data

<Callout icon={<InfoIcon />}>
`ctx.orm` intentionally does **not** expose native Convex writer methods (`patch`, `replace`, `insert('table', ...)`, `delete(id)`), so you can't bypass ORM checks by accident.
If you really need raw access, use `ctx.db` explicitly (it bypasses constraints/defaults/RLS).
</Callout>

### Insert (`db.insert` → `insert().values()`)

Native Convex `insert` returns an ID. ORM inserts return `void` unless you use `.returning()`.

<Compare>
  <CompareItem title="Before (native Convex)">
    ```ts title="convex/functions/users.ts" showLineNumbers
    import { mutation } from './_generated/server';
    import { v } from 'convex/values';

    export const createUser = mutation({
      args: { name: v.string(), email: v.string() },
      handler: async (ctx, args) => {
        return ctx.db.insert('users', { name: args.name, email: args.email });
      },
    });
    ```
  </CompareItem>
  <CompareItem title="After (ORM + cRPC)">
    ```ts title="convex/functions/users.ts" showLineNumbers {2-6,11-18}
    import { z } from 'zod';
    import { publicMutation } from '../lib/crpc';
    import { users } from '../schema';

    export const createUser = publicMutation
      .input(z.object({ name: z.string(), email: z.string().email() }))
      .mutation(async ({ ctx, input }) => {
        const [row] = await ctx.orm
          .insert(users)
          .values({ name: input.name, email: input.email })
          .returning({ id: users._id });
        return row.id;
      });
    ```
  </CompareItem>
</Compare>

### Patch / Replace (`db.patch` / `db.replace` → `update().set().where()`)

<Callout icon={<AlertTriangle />}>
Native Convex writes like `ctx.db.patch(...)` bypass ORM constraints and keep native `undefined` semantics. `ctx.orm` intentionally does not expose `patch`/`replace`; use `update().set().where(...)` instead.
</Callout>

<Compare>
  <CompareItem title="Before (native Convex)">
    ```ts title="convex/functions/users.ts" showLineNumbers
    import { mutation } from './_generated/server';
    import { v } from 'convex/values';

    export const renameUser = mutation({
      args: { userId: v.id('users'), name: v.string() },
      handler: async (ctx, args) => {
        await ctx.db.patch('users', args.userId, { name: args.name });
      },
    });
    ```
  </CompareItem>
  <CompareItem title="After (ORM)">
    ```ts showLineNumbers {2}
    import { eq, unsetToken } from 'better-convex/orm';
    ```

    ```ts showLineNumbers
    const { userId, ...patch } = input;

    // Patch-style update: `undefined` keys are ignored (no-op).
    await ctx.orm.update(users).set(patch).where(eq(users._id, userId));

    // Unset a field (native Convex: ctx.db.patch(..., { field: undefined })):
    await ctx.orm.update(users).set({ nickname: unsetToken }).where(eq(users._id, userId));

    // Replace-style update: set all fields explicitly (including nulls).
    await ctx.orm
      .update(users)
      .set({ name: input.name, email: input.email, role: input.role })
      .where(eq(users._id, userId));
    ```
  </CompareItem>
</Compare>

### Delete (`db.delete` → `delete().where()`)

<Compare>
  <CompareItem title="Before (native Convex)">
    ```ts showLineNumbers
    await ctx.db.delete('users', args.userId);
    ```
  </CompareItem>
  <CompareItem title="After (ORM)">
    ```ts showLineNumbers
    await ctx.orm.delete(users).where(eq(users._id, input.userId));
    ```
  </CompareItem>
</Compare>

For guardrails and async batching, see [/docs/db/orm/mutations](/docs/db/orm/mutations).

## System Tables

Better-Convex ORM exposes `db.system` as a passthrough to native Convex system tables:

```ts showLineNumbers {2-8}
const db = ctx.orm;

const files = await db.system.query('_storage').take(20);
const jobs = await db.system.query('_scheduled_functions').collect();
```

## Next Steps

<Cards>
  <Card title="Quickstart" href="/docs/db/orm/quickstart" />
  <Card title="Querying Data" href="/docs/db/orm/queries" />
  <Card title="Mutations" href="/docs/db/orm/mutations" />
  <Card title="RLS Policies" href="/docs/db/orm/rls" />
</Cards>
