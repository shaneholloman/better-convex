---
title: Delete
description: Delete rows with Drizzle-style builders (Better-Convex ORM)
links:
  doc: https://orm.drizzle.team/docs/delete
---

import { InfoIcon, AlertTriangle } from "lucide-react"

Better-Convex ORM provides a Drizzle-style `delete()` builder for Convex mutations.

## Delete Rows

```ts
import { eq } from 'better-convex/orm';

// db is ctx.orm
await db.delete(users).where(eq(users.email, 'dan@example.com'));
```

To delete all rows in a table (use with care):

```ts
await db.delete(users).allowFullScan();
```

<Callout icon={<AlertTriangle />}>
`delete()` without `.where(...)` throws unless you call `.allowFullScan()`.  
`strict` controls warning behavior, not whether full scans are allowed.
</Callout>

## Returning

```ts
const deleted = await db
  .delete(users)
  .where(eq(users.email, 'dan@example.com'))
  .returning();

const ids = await db
  .delete(users)
  .where(eq(users.email, 'dan@example.com'))
  .returning({ id: users._id });
```

## Safety Limits

`delete()` collects matching rows in bounded pages before applying writes:

- `mutationBatchSize`: defaults to `100`
- `mutationLeafBatchSize`: defaults to `900` (async non-recursive FK fan-out)
- `mutationMaxRows`: defaults to `1000`
- `mutationMaxBytesPerBatch`: defaults to `2_097_152` (async measured-byte budget)
- `mutationScheduleCallCap`: defaults to `100` (async schedule calls per mutation)

If matched rows exceed `mutationMaxRows`, delete throws.

```ts
export default defineSchema({ users, posts }, {
  defaults: {
    mutationBatchSize: 200,
    mutationMaxRows: 5000,
  },
});
```

## Paginated Delete Execution

For large workloads, process delete batches with `paginate({ cursor, numItems })`.

```ts
const page1 = await db
  .delete(users)
  .where(eq(users.status, 'inactive'))
  .paginate({ cursor: null, numItems: 100 });

if (!page1.isDone) {
  const page2 = await db
    .delete(users)
    .where(eq(users.status, 'inactive'))
    .paginate({ cursor: page1.continueCursor, numItems: 100 });
}
```

Paged delete result:
- `continueCursor`: cursor for the next batch
- `isDone`: `true` when no more pages remain
- `numAffected`: rows deleted in this page
- `page`: returned rows for this page (only when `.returning()` is used)

<Callout icon={<InfoIcon />}>
`paginate()` currently supports single-range index plans. Multi-probe filters (`inArray`, some `OR` patterns, complement ranges) are not yet supported in paged mutation mode.
</Callout>

## Async Batched Delete

Use async mode when a delete can affect large sets.

- Per call: `execute({ mode: 'async' })`
- Convenience alias: `executeAsync(...)`
- Global default: `defineSchema(..., { defaults: { mutationExecutionMode: 'async' } })`

Async mode runs the first delete batch in the current mutation, then schedules remaining batches through Convex scheduler.

```ts
const firstBatch = await db
  .delete(users)
  .where(eq(users.status, 'inactive'))
  .returning({ id: users._id })
  .execute({ mode: 'async', batchSize: 200, delayMs: 0 });
```

Important behavior:
- `execute()` in async mode returns the same type shape as sync `execute()` (with `.returning()`, rows from the first batch only).
- Remaining batches are scheduled asynchronously.
- Explicit async APIs (`execute({ mode: 'async' })` / `executeAsync()`) cannot be combined with `.paginate()` or resolved scheduled delete mode (`.scheduled(...)` or table-level `deletion('scheduled')`).
- `.paginate()` remains the caller-controlled execution path.
- `batchSize` resolves as: per-call `batchSize` → `defaults.mutationBatchSize` → `100`.
- `delayMs` resolves as: per-call `delayMs` → `defaults.mutationAsyncDelayMs` → `0`.
- FK/cascade async fan-out uses:
  - `mutationBatchSize` for recursive delete cascade (`onDelete: 'cascade'`)
  - `mutationLeafBatchSize` for non-recursive actions (`set null`, `set default`)
- Async fan-out stops at `mutationMaxBytesPerBatch` and may throw after `mutationScheduleCallCap` schedule calls in one mutation invocation.

Async execution requires wiring `scheduler` + `scheduledMutationBatch` when building `ctx.orm`.

## Table Default Delete Mode

Use table-level deletion config when a table should always default to soft/scheduled semantics.

```ts
import { convexTable, deletion, integer, text } from 'better-convex/orm';

const users = convexTable(
  'users',
  {
    slug: text().notNull(),
    deletionTime: integer(),
  },
  () => [deletion('scheduled', { delayMs: 60_000 })]
);
```

Delete mode precedence:
- per-query override (`.hard()`, `.soft()`, `.scheduled({ delayMs })`)
- table default via `deletion(...)`
- fallback `'hard'`

When a table defaults to scheduled mode, use `.hard()` to opt out for a specific delete (including `.hard().executeAsync(...)`).

## Scheduled Delete Cancellation

`.scheduled({ delayMs })` stores the current `deletionTime` and passes it to the scheduled worker.
The worker only proceeds if the row still has the same `deletionTime`.

To cancel a pending scheduled hard-delete, clear or change `deletionTime` before the worker runs.

## Drizzle Differences

<Callout icon={<AlertTriangle />}>
- SQL-only features like `limit`, `orderBy`, and `WITH` clauses are not applicable
- Deletes are executed against Convex documents; there is no SQL `DELETE FROM ...`
</Callout>

<Callout icon={<InfoIcon />}>
Foreign key actions and RLS policies are enforced at runtime for ORM deletes when you attach ORM to `ctx.orm`. Direct `ctx.db.delete(...)` bypasses these checks.
</Callout>
