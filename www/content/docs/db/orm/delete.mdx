---
title: Delete
description: Delete rows with Drizzle-style builders (Better-Convex ORM)
links:
  doc: https://orm.drizzle.team/docs/delete
---

import { InfoIcon, AlertTriangle } from "lucide-react"

Better-Convex ORM provides a Drizzle-style `delete()` builder for Convex mutations.

## Delete Rows

```ts
import { eq } from 'better-convex/orm';

// db is ctx.table
await db.delete(users).where(eq(users.email, 'dan@example.com'));
```

To delete all rows in a table (use with care):

```ts
await db.delete(users).allowFullScan();
```

<Callout icon={<AlertTriangle />}>
`delete()` without `.where(...)` throws unless you call `.allowFullScan()`.  
`strict` controls warning behavior, not whether full scans are allowed.
</Callout>

## Returning

```ts
const deleted = await db
  .delete(users)
  .where(eq(users.email, 'dan@example.com'))
  .returning();

const ids = await db
  .delete(users)
  .where(eq(users.email, 'dan@example.com'))
  .returning({ id: users._id });
```

## Safety Limits

`delete()` collects matching rows in bounded pages before applying writes:

- `mutationBatchSize`: defaults to `100`
- `mutationMaxRows`: defaults to `1000`

If matched rows exceed `mutationMaxRows`, delete throws.

```ts
export default defineSchema({ users, posts }, {
  defaults: {
    mutationBatchSize: 200,
    mutationMaxRows: 5000,
  },
});
```

## Paginated Delete Execution

For large workloads, process delete batches with `paginate({ cursor, numItems })`.

```ts
const page1 = await db
  .delete(users)
  .where(eq(users.status, 'inactive'))
  .paginate({ cursor: null, numItems: 100 });

if (!page1.isDone) {
  const page2 = await db
    .delete(users)
    .where(eq(users.status, 'inactive'))
    .paginate({ cursor: page1.continueCursor, numItems: 100 });
}
```

Paged delete result:
- `continueCursor`: cursor for the next batch
- `isDone`: `true` when no more pages remain
- `numAffected`: rows deleted in this page
- `page`: returned rows for this page (only when `.returning()` is used)

<Callout icon={<InfoIcon />}>
`paginate()` currently supports single-range index plans. Multi-probe filters (`inArray`, some `OR` patterns, complement ranges) are not yet supported in paged mutation mode.
</Callout>

## Drizzle Differences

<Callout icon={<AlertTriangle />}>
- SQL-only features like `limit`, `orderBy`, and `WITH` clauses are not applicable
- Deletes are executed against Convex documents; there is no SQL `DELETE FROM ...`
</Callout>

<Callout icon={<InfoIcon />}>
Foreign key actions and RLS policies are enforced at runtime for ORM deletes when you attach ORM to `ctx.table`. Direct `ctx.db.delete(...)` bypasses these checks.
</Callout>
