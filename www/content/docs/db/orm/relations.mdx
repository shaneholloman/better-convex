---
title: Relations
description: Define relationships between tables with Better-Convex ORM
links:
  doc: https://orm.drizzle.team/docs/relations-v2
---

import { InfoIcon, CheckCircle, AlertTriangle } from "lucide-react"

Define relationships between tables using Drizzle v1 `defineRelations()` API. Better-Convex ORM mirrors Drizzle v1 relation syntax.

## Overview

Relations in Better-Convex ORM use the same API as Drizzle v1 for **defining** and **loading** relationships. The `with:` option is type-safe, with a few nested constraints noted below.

<Callout icon={<AlertTriangle />}>
Relation loading via `with:` works end-to-end. Nested `with` has a depth limit and per-relation filters are post-fetch for `many()` relations.
</Callout>

<Callout icon={<AlertTriangle />}>
Relation loading requires indexes on relation fields (e.g. `posts.authorId`). Missing indexes throw unless you opt in with `allowFullScan: true`. Use `defineSchema(..., { strict: false })` to downgrade throws to warnings when `allowFullScan` is set.
</Callout>

<Callout icon={<AlertTriangle />}>
Loading `many()` relations requires explicit sizing (`with.<relation>.limit`), a schema `defaults.defaultLimit`, or `allowFullScan: true` on the parent query.
</Callout>

See Schema Options for strict policy details.

## Relation Config Options

Better-Convex mirrors Drizzle’s `defineRelations()` config shape.

### `one()`

```ts
r.one.users({
  from: r.posts.authorId,
  to: r.users._id,
  optional: false,
  alias: 'author',
  where: { isActive: true },
})
```

- `from` / `to`: describe the relationship using columns
- `optional`: type-level nullability (`true` by default)
- `alias`: disambiguate multiple relations between the same tables
- `where`: polymorphic relations / conditional relation loading

### `many()`

```ts
r.many.posts({
  from: r.users._id,
  to: r.posts.authorId,
  alias: 'posts',
  where: { published: true },
})
```

- `from` / `to`: optional when the inverse relation is unambiguous
- `alias`: disambiguate multiple relations between the same tables
- `where`: filter which related rows are loaded

## Relation Types

### One-to-One Relations

```ts title="convex/schema.ts" showLineNumbers {1-3,5-23}
import { convexTable, defineRelations, text, id } from 'better-convex/orm';

const users = convexTable('users', {
  name: text().notNull(),
});

const profiles = convexTable('profiles', {
  bio: text().notNull(),
  userId: id('users'),
});

const ormSchema = defineRelations({ users, profiles }, (r) => ({
  profiles: {
    user: r.one.users({
      from: r.profiles.userId,
      to: r.users._id,
    }),
  },
  users: {
    profile: r.one.profiles(),
  },
}));
```

<Callout icon={<InfoIcon />}>
**Relation Definition**: Use `from` and `to` to describe the foreign key relationship. In Convex, primary keys are `_id`.
</Callout>

<Callout icon={<AlertTriangle />}>
**1:1 uniqueness**: enforce a unique constraint on the foreign key column (`.unique()` / `uniqueIndex()`). Runtime uniqueness is best‑effort; concurrent mutations can still race.
</Callout>

### One-to-Many Relations

The most common relation type - one user has many posts.

```ts title="convex/schema.ts" showLineNumbers {1-3,5-21,23-31}
import { convexTable, defineRelations, text, boolean, id } from 'better-convex/orm';

const users = convexTable('users', {
  name: text().notNull(),
});

const posts = convexTable('posts', {
  title: text().notNull(),
  content: text().notNull(),
  published: boolean(),
  userId: id('users'),
});

const ormSchema = defineRelations({ users, posts }, (r) => ({
  users: {
    posts: r.many.posts(),
  },
  posts: {
    author: r.one.users({
      from: r.posts.userId,
      to: r.users._id,
    }),
  },
}));
```

**Key Points:**
- **Foreign key is on the "many" side**: `posts.userId` references `users._id`
- **Define both sides**: Define relations on both users and posts
- **Export both**: Both table and relations object must be in schema export

### Many-to-Many Relations (Join Table)

Better-Convex does not auto-create join tables. Model many-to-many with an explicit join table:

```ts title="convex/schema.ts" showLineNumbers {1-3,5-24,26-40}
import { convexTable, defineRelations, text, id } from 'better-convex/orm';

const posts = convexTable('posts', {
  title: text().notNull(),
});

const tags = convexTable('tags', {
  name: text().notNull(),
});

const postsTags = convexTable('postsTags', {
  postId: id('posts'),
  tagId: id('tags'),
});

const ormSchema = defineRelations({ posts, tags, postsTags }, (r) => ({
  posts: {
    tags: r.many.postsTags(),
  },
  tags: {
    posts: r.many.postsTags(),
  },
  postsTags: {
    post: r.one.posts({ from: r.postsTags.postId, to: r.posts._id }),
    tag: r.one.tags({ from: r.postsTags.tagId, to: r.tags._id }),
  },
}));
```

### Many-to-Many With Data (Join Table + Payload)

If you need extra data on the relationship (role, timestamps, etc.), put it on the join table. No special API required.

```ts title="convex/schema.ts" showLineNumbers {1-3,5-33,35-52}
import { convexTable, defineRelations, id, text, number } from 'better-convex/orm';

const users = convexTable('users', {
  name: text().notNull(),
});

const groups = convexTable('groups', {
  name: text().notNull(),
});

const memberships = convexTable('memberships', {
  userId: id('users').notNull(),
  groupId: id('groups').notNull(),
  role: text().notNull(),
  joinedAt: number().notNull(),
});

const ormSchema = defineRelations({ users, groups, memberships }, (r) => ({
  users: {
    memberships: r.many.memberships(),
  },
  groups: {
    memberships: r.many.memberships(),
  },
  memberships: {
    user: r.one.users({ from: r.memberships.userId, to: r.users._id }),
    group: r.one.groups({ from: r.memberships.groupId, to: r.groups._id }),
  },
}));
```

```ts title="convex/queries.ts"
const usersWithGroups = await db.query.users.findMany({
  with: {
    memberships: {
      columns: { role: true, joinedAt: true },
      with: { group: true },
    },
  },
});
```

### Many-to-Many Relations with `.through()`

You can also define direct many-to-many relations with `.through()` to point at junction table columns:

```ts title="convex/schema.ts" showLineNumbers {1-3,5-27}
import { boolean, convexTable, defineRelations, id, text } from 'better-convex/orm';

const users = convexTable('users', {
  name: text().notNull(),
});

const groups = convexTable('groups', {
  name: text().notNull(),
});

const usersToGroups = convexTable('usersToGroups', {
  userId: id('users').notNull(),
  groupId: id('groups').notNull(),
});

const ormSchema = defineRelations({ users, groups, usersToGroups }, (r) => ({
  users: {
    groups: r.many.groups({
      from: r.users._id.through(r.usersToGroups.userId),
      to: r.groups._id.through(r.usersToGroups.groupId),
      alias: 'users-groups-direct',
    }),
  },
  groups: {
    users: r.many.users({
      from: r.groups._id.through(r.usersToGroups.groupId),
      to: r.users._id.through(r.usersToGroups.userId),
      alias: 'users-groups-direct',
    }),
  },
}));
```

### Self-Referencing Relations

Define relations where a table references itself (e.g., user followers).

```ts title="convex/schema.ts" showLineNumbers {1-8}
import { convexTable, defineRelations, text, id } from 'better-convex/orm';

const users = convexTable('users', {
  name: text().notNull(),
  username: text().notNull(),
  managerId: id('users'),
});

const ormSchema = defineRelations({ users }, (r) => ({
  users: {
    manager: r.one.users({
      from: r.users.managerId,
      to: r.users._id,
      alias: 'manager',
    }),
    reports: r.many.users({
      from: r.users._id,
      to: r.users.managerId,
      alias: 'manager',
    }),
  },
}));
```

**Important:**
- **Use `alias`** to distinguish self-referencing relations
- **Unique names** are required to disambiguate

### Optional `one()` Relations

By default, `one()` relations are optional and return `null` when no match is found.  
Use `optional: false` when the relation is required:

```ts title="convex/schema.ts" showLineNumbers {1-3,5-18}
import { convexTable, defineRelations, id, text } from 'better-convex/orm';

const users = convexTable('users', {
  name: text().notNull(),
});

const posts = convexTable('posts', {
  title: text().notNull(),
  authorId: id('users').notNull(),
});

const ormSchema = defineRelations({ users, posts }, (r) => ({
  posts: {
    author: r.one.users({
      from: r.posts.authorId,
      to: r.users._id,
      optional: false,
    }),
  },
}));
```

## Relation Definition Rules

### Required Fields

Define the `one()` side with `from` and `to`. The `many()` side can be inferred from the inverse relation.

```ts
const ormSchema = defineRelations({ users, posts }, (r) => ({
  posts: {
    author: r.one.users({
      from: r.posts.userId,
      to: r.users._id,
    }),
  },
  users: {
    posts: r.many.posts(),
  },
}));
```

### Export Tables and Schema

```ts
export const ormSchema = defineRelations({ users, posts }, (r) => ({
  users: { posts: r.many.posts() },
  posts: { author: r.one.users({ from: r.posts.userId, to: r.users._id }) },
}));

export const ormEdges = extractRelationsConfig(ormSchema);
```

### Split Relations with `defineRelationsPart`

Use `defineRelationsPart` to split large relation graphs across modules and merge them later:

```ts title="convex/relations.ts" showLineNumbers {1-4,6-26}
import { defineRelations, defineRelationsPart } from 'better-convex/orm';
import { users, posts, comments } from './schema';

const userRelations = defineRelationsPart({ users, posts }, (r) => ({
  users: {
    posts: r.many.posts({
      from: r.users._id,
      to: r.posts.authorId,
    }),
  },
}));

const postRelations = defineRelationsPart({ posts, comments }, (r) => ({
  posts: {
    comments: r.many.comments({
      from: r.posts._id,
      to: r.comments.postId,
    }),
  },
}));

export const ormSchema = defineRelations({ users, posts, comments }, (r) => ({
  users: userRelations.users.relations,
  posts: {
    ...userRelations.posts.relations,
    ...postRelations.posts.relations,
  },
  comments: postRelations.comments.relations,
}));
```

<Callout icon={<InfoIcon />}>
If a relation relies on inference (no `from`/`to`), define both sides in the same part or use explicit `from`/`to`.
</Callout>

### Bidirectional Definitions

Define both sides when you want `with` loading in both directions.

### One‑Way Definitions

You can define relations only on the side you need. When you do, provide explicit `from`/`to` (and `alias` if ambiguous). The inverse side is optional and won’t be available for `with` unless you define it.

### Predefined Filters

You can attach a predefined `where` filter to a relation. It will always be applied:

```ts title="convex/schema.ts" showLineNumbers {1-4,6-20}
import { convexTable, defineRelations, id, text } from 'better-convex/orm';

const users = convexTable('users', {
  name: text().notNull(),
});

const posts = convexTable('posts', {
  title: text().notNull(),
  authorId: id('users'),
  published: boolean().notNull(),
});

const ormSchema = defineRelations({ users, posts }, (r) => ({
  users: {
    publishedPosts: r.many.posts({
      from: r.users._id,
      to: r.posts.authorId,
      where: { published: true },
      alias: 'published-posts',
    }),
  },
}));
```

## Relation Loading with `with:`

Better-Convex ORM supports Drizzle-style relation loading:

```ts
const db = ctx.table;

const usersWithPosts = await db.query.users.findMany({
  with: {
    posts: {
      limit: 5,
      orderBy: { _creationTime: 'desc' },
    },
  },
});
```

<Callout icon={<InfoIcon />}>
**Note**: `limit`, `orderBy`, and `where` apply to `many()` relations. If `limit` is omitted, configure `defineSchema(..., { defaults: { defaultLimit } })` or use `allowFullScan: true` on the parent query. Nested `with` works with a depth limit to prevent infinite recursion.
</Callout>

### Column Selection Semantics

`columns` follows Drizzle v1 selection rules:

```ts title="convex/queries.ts" showLineNumbers {1-4,6-24}
const users = await db.query.users.findMany({
  columns: { name: true, email: true }, // include-only
});

const usersNoEmail = await db.query.users.findMany({
  columns: { email: false }, // exclude-only
});

const usersOnlyPosts = await db.query.users.findMany({
  columns: {}, // no table columns
  with: { posts: true },
});
```

<Callout icon={<InfoIcon />}>
`columns` only affects table columns. Relation data and `extras` are preserved.
</Callout>

## Common Gotchas

| Issue | Solution |
|-------|----------|
| **Relations not working** | Define relations in `defineRelations()` and use `ormEdges` when building `ctx.table` |
| **Foreign key field missing** | Define the FK column yourself (e.g., `userId: id('users')`) |
| **Type errors in `from`/`to`** | Ensure `from` columns belong to the source table and `to` columns belong to the target table |
| **Self-referencing conflicts** | Use unique `alias` for each self-referencing relation |
| **`with:` not working** | Ensure relations are defined on both tables and `ormEdges` is used in `ctx.table` setup |
| **`many()` relation throws sizing error** | Add `with.<relation>.limit`, configure `defaults.defaultLimit`, or set `allowFullScan: true` |

## Next Steps

<Cards>
  <Card title="Querying Data" href="/docs/db/orm/queries">
    Learn findMany(), findFirst(), and filtering
  </Card>
  <Card title="Schema Definition" href="/docs/db/orm/schema">
    Deep dive into table definitions and type inference
  </Card>
  <Card title="Limitations" href="/docs/db/orm/limitations">
    Understand current limitations
  </Card>
  <Card title="Drizzle Comparison" href="/docs/db/orm/comparison">
    See how Better-Convex maps to Drizzle's API
  </Card>
</Cards>
