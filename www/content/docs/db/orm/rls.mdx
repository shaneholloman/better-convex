---
title: Row-Level Security
description: Drizzle-style rlsPolicy rules enforced at runtime for Better-Convex ORM
links:
  doc: https://orm.drizzle.team/docs/rls
---

import { InfoIcon, AlertTriangle } from "lucide-react"

Better-Convex ORM can enforce Drizzle v1-style RLS policies at runtime. Policies
live next to your table definitions and are applied automatically to all ORM
reads and writes.

## Define Policies

```ts title="convex/schema.ts"
import { convexTable, rlsPolicy, text, id, eq } from 'better-convex/orm';

export const secrets = convexTable.withRLS(
  'secrets',
  {
    value: text().notNull(),
    ownerId: id('users').notNull(),
  },
  (t) => [
    rlsPolicy('read_own', {
      for: 'select',
      using: (ctx) => eq(t.ownerId, ctx.viewerId),
    }),
    rlsPolicy('insert_own', {
      for: 'insert',
      withCheck: (ctx) => eq(t.ownerId, ctx.viewerId),
    }),
    rlsPolicy('update_own', {
      for: 'update',
      using: (ctx) => eq(t.ownerId, ctx.viewerId),
      withCheck: (ctx) => eq(t.ownerId, ctx.viewerId),
    }),
    rlsPolicy('delete_own', {
      for: 'delete',
      using: (ctx) => eq(t.ownerId, ctx.viewerId),
    }),
  ]
);
```

<Callout icon={<InfoIcon />}>
If you add at least one `rlsPolicy(...)` to a table, RLS is enabled automatically. You donâ€™t need to call `withRLS(...)` explicitly.
</Callout>

You can also enable RLS without adding policies:

<Callout icon={<AlertTriangle />}>
`enableRLS()` is deprecated (Drizzle parity). Prefer `convexTable.withRLS(...)` for new code.
</Callout>

```ts
const secrets = convexTable('secrets', {
  value: text().notNull(),
}).enableRLS();
```

## Context Setup (once)

Attach ORM to `ctx.orm` with RLS enabled. Do this once in your context layer:

```ts title="convex/lib/orm.ts"
import type { GenericDatabaseWriter } from 'convex/server';
import { createOrm } from 'better-convex/orm';
import { relations } from '../schema';

const orm = createOrm({ schema: relations });

export const withOrm = <Ctx extends { db: GenericDatabaseWriter<any> }>(ctx: Ctx) => {
  const ormDb = orm.db(ctx, { rls: { ctx } });
  return { ...ctx, orm: ormDb };
};
```

## Use In Handlers

```ts title="convex/queries.ts"
export const listSecrets = query({
  handler: async (ctx) => {
    const db = ctx.orm;
    return db.query.secrets.findMany();
  },
});
```

## Bypass Rules

Use `ctx.orm.skipRules` for trusted access:

```ts
await ctx.orm.skipRules.query.secrets.findMany();
```

## Roles (Optional)

`to` clauses are enforced only when you provide a `roleResolver`:

```ts
import { rlsRole, rlsPolicy } from 'better-convex/orm';

const admin = rlsRole('admin');

rlsPolicy('admin_only', {
  for: 'select',
  to: admin,
  using: (ctx, t) => eq(t.ownerId, ctx.viewerId),
});

const ormDb = orm.db(ctx, {
  rls: {
    ctx,
    roleResolver: (ctx) => ctx.roles ?? [],
  },
});
```

## Drizzle Differences

<Callout icon={<AlertTriangle />}>
- Policies are enforced at runtime, not in the database
- `ctx.db` bypasses RLS; only ORM access (`ctx.orm`) enforces rules
- If RLS is enabled with no permissive policies, access is denied by default
</Callout>

<Callout icon={<InfoIcon />}>
RLS policies are evaluated after query filters. They also apply to nested
relation loading.
</Callout>

<Callout icon={<AlertTriangle />}>
Foreign-key cascade fan-out (`cascade`, `set null`, `set default`) runs after the
root mutation row passes RLS. Fan-out writes are executed as system actions and
do not re-check child-table RLS policies.
</Callout>
