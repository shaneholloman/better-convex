---
title: Mutations
description: Insert, update, and delete operations with Drizzle-style builders
links:
  doc: https://orm.drizzle.team/docs/insert
---

import { InfoIcon, CheckCircle } from "lucide-react"

Mutation APIs mirror Drizzle v1 patterns with Convex semantics.

## Dedicated Pages

<Cards>
  <Card title="Insert" href="/docs/db/orm/insert">
    Insert rows, returning, and onConflict upserts
  </Card>
  <Card title="Update" href="/docs/db/orm/update">
    Update rows with set/where/returning
  </Card>
  <Card title="Delete" href="/docs/db/orm/delete">
    Delete rows with where/returning
  </Card>
</Cards>

## Setup

```ts title="convex/mutations.ts"
import { mutation } from './_generated/server';
import { v } from 'convex/values';
import { eq } from 'better-convex/orm';
import { users } from './schema';
```

These examples assume ORM is attached as `ctx.table` in your context.

## Insert

```ts title="convex/mutations.ts"
export const createUser = mutation({
  args: { name: v.string(), email: v.string() },
  handler: async (ctx, args) => {
    const db = ctx.table;

    await db.insert(users).values({
      name: args.name,
      email: args.email,
    });
  },
});
```

### Returning

```ts
const [user] = await db
  .insert(users)
  .values({ name: 'Ada', email: 'ada@example.com' })
  .returning({ id: users._id, email: users.email });
```

<Callout icon={<InfoIcon />}>
`returning()` always returns an array. Without `returning()`, the result is `void`.
</Callout>

### Upsert (onConflict)

```ts
await db
  .insert(users)
  .values({ email: 'ada@example.com', name: 'Ada' })
  .onConflictDoUpdate({
    target: users.email,
    set: { name: 'Ada Lovelace' },
  });
```

## Update

```ts
export const updateUserName = mutation({
  args: { userId: v.id('users'), newName: v.string() },
  handler: async (ctx, args) => {
    const db = ctx.table;

    await db
      .update(users)
      .set({ name: args.newName })
      .where(eq(users._id, args.userId));
  },
});
```

### Update + Returning

```ts
const updated = await db
  .update(users)
  .set({ name: 'New Name' })
  .where(eq(users._id, userId))
  .returning();
```

## Delete

```ts
export const deleteUser = mutation({
  args: { userId: v.id('users') },
  handler: async (ctx, args) => {
    const db = ctx.table;

    await db.delete(users).where(eq(users._id, args.userId));
  },
});
```

### Delete + Returning

```ts
const deleted = await db
  .delete(users)
  .where(eq(users._id, userId))
  .returning();
```

## Paginated Mutation Batches

For large update/delete workloads, run one page per mutation call:

```ts
const batch = await db
  .update(users)
  .set({ role: 'member' })
  .where(eq(users.status, 'pending'))
  .paginate({ cursor: null, numItems: 100 });
```

Batch result shape:
- `continueCursor`
- `isDone`
- `numAffected`
- `page` (only when `.returning()` is used)

<Callout icon={<CheckCircle />}>
Convex mutations are atomic: all changes succeed or fail together.
</Callout>
