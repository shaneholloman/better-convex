---
title: Limitations & Performance
description: Understand Better-Convex ORM limitations, workarounds, and performance characteristics
links:
  doc: https://docs.convex.dev/database
---

import { InfoIcon, AlertTriangle, CheckCircle, Zap } from "lucide-react"

Better-Convex ORM implements core query operations with column builder syntax. Some features are planned for future milestones, and some SQL-specific features don't apply to Convex's document model.

## Current Status

**âœ… Implemented (M1-M6.5):**
- Schema definition with column builders (`convexTable`, `text()`, `integer()`, etc.)
- Relations definition and loading (`one()`, `many()`, `with:`)
- Query operations (`findMany`, `findFirst`, `paginate`)
- Where filtering (all operators)
- Order by (multi-field, index-aware first sort)
- Limit/offset pagination
- Column selection (post-fetch projection)
- String operators (post-fetch)
- Type inference

**ðŸš§ Coming Soon:**
- Mutations (`insert`, `update`, `delete`)

**âŒ Not Applicable:**
- SQL-specific features (raw SQL, migrations, JOINs)

## Category 2: Limited Features

### Column Selection (post-fetch)

```ts
const users = await db.query.users.findMany({
  columns: { name: true, email: true },
});
```

**Why:** Convex returns full documents. Better-Convex projects columns after fetch for API parity and type safety.

### String Operators (post-fetch)

```ts
const users = await db.query.users.findMany({
  where: (users, { ilike }) => ilike(users.email, '%@example.com'),
});
```

**Performance:** String operators are post-fetch. For large datasets, prefer Convex search indexes.

### Relation Loading Constraints

- `with` is supported for `one()` and `many()` relations
- Nested `with` has a depth limit to avoid infinite recursion
- Per-relation filters (`where`, `orderBy`, `limit`) apply only to `many()` relations
- Relation filters are post-fetch (no index usage yet)

### Cursor Pagination Ordering

- `paginate()` uses the first `orderBy` field for cursor ordering
- Secondary `orderBy` fields are applied per page

## Planned Features

### Mutations (Insert, Update, Delete)

Mutation helpers are planned. Use native Convex mutations today:

```ts
const userId = await ctx.db.insert('users', {
  name: 'Alice',
  email: 'alice@example.com',
});
```

### Defaults and Upserts

- Column defaults are not applied automatically (mutation helpers not implemented yet)
- Upserts should be implemented with native mutations

## Category 4: Not Applicable

### Raw SQL

Better-Convex does not expose SQL execution. Convex uses document queries and indexes.

### Migrations

Convex is schemaless. You update schema in code and deploy.

### SQL JOINs

Use `with` relation loading instead of SQL joins.

## Performance Guidance

### Indexes

Create indexes for fields you filter or sort by frequently:

```ts
import { convexTable, text, integer } from 'better-convex/orm';

const users = convexTable('users', {
  name: text().notNull(),
  role: text().notNull(),
  createdAt: integer(),
}).index('by_role', ['role']);
```

### Cursor vs Offset Pagination

- Use `paginate()` for large lists or infinite scroll
- Use `limit`/`offset` for small admin tables

### Avoid N+1

Prefer `with` for relation loading to avoid per-row queries.

## Common Gotchas

| Issue | Cause | Solution |
|-------|-------|----------|
| **Slow queries without index** | Missing index on filtered field | Add `.index()` in schema |
| **Deep offset pagination slow** | Using offset for deep pages | Switch to cursor pagination |
| **Column selection not working** | Projection is post-fetch | Ensure `columns` is configured |
| **LIKE operator slow** | Post-fetch filtering | Use search indexes for large datasets |
| **Relations not loading** | Missing relations/edges | Export relations and pass `ormEdges` |

## Next Steps

<Cards>
  <Card title="Schema Definition" href="/docs/db/orm/schema">
    Learn how to define schemas with indexes
  </Card>
  <Card title="Querying Data" href="/docs/db/orm/queries">
    Master efficient query patterns
  </Card>
</Cards>
