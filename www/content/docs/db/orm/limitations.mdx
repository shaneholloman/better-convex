---
title: Limitations & Performance
description: Understand Better-Convex ORM limitations, workarounds, and performance characteristics
links:
  doc: https://docs.convex.dev/database
---

import { InfoIcon, AlertTriangle, CheckCircle, Zap } from "lucide-react"

Better-Convex mirrors Drizzle v1’s relational query builder on top of Convex’s document database. That means a few SQL-only features do not apply, and some features are implemented post-fetch for API parity.

## Not Available In Convex

These Drizzle features are SQL-specific and do not map to Convex:

- SQL joins
- Raw SQL execution
- RQB SQL-only features: `RAW` filters and SQL placeholders in `where`/`limit`/`offset` are not supported at runtime
- Database migrations and database-side constraints/triggers
- Custom SQL data types

## Post-Fetch Behavior

These features keep Drizzle’s API shape but run after data is fetched:

**Column selection**
```ts
const users = await db.query.users.findMany({
  columns: { name: true, email: true },
});
```

**String operators**
```ts
const users = await db.query.users.findMany({
  where: { email: { ilike: '%@example.com' } },
});
```

**Extras (computed fields)**
```ts
const users = await db.query.users.findMany({
  extras: {
    emailDomain: (row) => row.email.split('@')[1]!,
  },
});
```

**Relation filters on `many()`**
```ts
const users = await db.query.users.findMany({
  with: {
    posts: {
      where: { published: true },
      orderBy: { _creationTime: 'desc' },
      limit: 5,
    },
  },
});
```

## Indexes And Ordering

- `findMany({ paginate })` relies on the first `orderBy` field for cursor ordering
- Sorting without an index falls back to `_creationTime` ordering
- Post-fetch sorting (multi-field or non-indexable orderBy) sorts before `offset`/`limit`, so Better-Convex must read the full filtered candidate set first
- For these post-fetch sort paths, size non-paginated queries intentionally (`limit`, schema `defaultLimit`, or `allowFullScan: true`)
- Add `index('...').on(t.field)` on fields used for filter or sort

```ts
const posts = convexTable(
  'posts',
  {
    title: text().notNull(),
    numLikes: number().notNull(),
  },
  (t) => [index('by_likes').on(t.numLikes)]
);
```

## Constraints And Defaults

- Unique, foreign keys, and `check()` constraints are enforced only through Better‑Convex ORM mutations
- Foreign key actions require an index on the referencing columns
- Relation loading requires indexes on relation fields (missing indexes throw unless `allowFullScan: true`)
- Non-paginated `findMany()` must be explicitly sized (`limit`, `paginate`, schema `defaultLimit`, or `allowFullScan: true`)
- `many()` relation loading must be explicitly sized per parent (`with.<relation>.limit`, schema `defaultLimit`, or `allowFullScan: true`)
- Predicate `where` requires explicit `index: { name, range? }` and runs post‑fetch via stream filtering
- Search mode (`findMany({ search })`) is relevance-ordered; `orderBy` is not supported
- Search mode supports base-table object `where`, but not predicate `where` or relation-based `where`
- Update/delete without `where()` throws unless `allowFullScan: true`
- Update/delete matched rows are capped by `mutationMaxRows` (default `1000`) and collected in `mutationBatchSize` pages (default `100`)
- For large update/delete workloads, use builder-level `paginate({ cursor, numItems })` to process one mutation page at a time
- Paged update/delete currently does not support multi-probe filter plans (`inArray`, some `OR`, complement ranges)
- Check constraints follow SQL-like NULL semantics: the check fails only when the expression is `false` (and passes on `unknown`)
- Defaults are applied only by Better‑Convex ORM inserts/updates (`.default(...)`, `$defaultFn(...)`, `$onUpdateFn(...)`)
- Direct `ctx.db` writes bypass all ORM enforcement

**Default policy**
- Query sizing has no implicit fallback (no hidden row default unless you set `defaults.defaultLimit`).
- Mutation safety has built-in guardrail defaults (`mutationBatchSize=100`, `mutationMaxRows=1000`).

<Callout icon={<AlertTriangle />}>
**Uniqueness under concurrency**: runtime uniqueness checks are best‑effort within a mutation. Concurrent mutations can still race (including 1:1 relations).  
Recommended patterns:
- Use `onConflictDoNothing()` / `onConflictDoUpdate()` for idempotent writes
- Retry on conflict when appropriate
- Serialize writes per unique key in application logic when strict guarantees are required
</Callout>

## Soft & Scheduled Deletes

- Soft/scheduled deletes are **optional helpers** and not part of Drizzle v1
- Soft deletes require a `deletionTime` field in your table
- Scheduled deletes require wiring `scheduler` + `scheduledDelete` when you build `ctx.table`

## Performance Guidance

- Index every field you filter or order by frequently
- Use search indexes for large text filtering
- Use vector indexes only for embedding search
- Prefer `findMany({ paginate })` for infinite scroll and large datasets
- Avoid deep offset pagination for large tables
- Use `with` to avoid N+1 queries

## Common Gotchas

| Issue | Cause | Fix |
|---|---|---|
| Slow ordering | Missing index | Add `index('...').on(t.field)` in schema |
| `findMany({ paginate })` order changes | No index on primary sort | Add index on first `orderBy` field |
| `findMany()` throws explicit sizing error | Non-paginated query has no `limit` and no schema `defaultLimit` | Add `limit`, use `paginate`, set `defaults.defaultLimit`, or opt in with `allowFullScan: true` |
| `like` or `ilike` is slow | Post-fetch filtering | Use search indexes |
| Relations not loading | Missing edges | Export `ormSchema` and `ormEdges` |
| `update()`/`delete()` exceeds row cap | Matched rows > `mutationMaxRows` | Narrow filters, increase `defaults.mutationMaxRows`, or switch to paged mutation execution |
| Paged update/delete throws multi-probe error | Filter compiles to multiple index probes | Rewrite filter to a single index range (or use non-paged mode with row cap) |
| Missing defaults | Direct `ctx.db` bypasses ORM defaults | Use ORM inserts or set defaults in code |

## Schema Introspection

Better-Convex exposes Drizzle-style helpers for runtime schema metadata:

```ts
import { getTableColumns, getTableConfig } from 'better-convex/orm';

const columns = getTableColumns(users); // includes _id/_creationTime
const config = getTableConfig(users);   // indexes/unique/fks/rls/checks
```

## Next Steps

<Cards>
  <Card title="Schema Definition" href="/docs/db/orm/schema">
    Define tables, relations, and indexes
  </Card>
  <Card title="Querying Data" href="/docs/db/orm/queries">
    Learn filters, ordering, and pagination
  </Card>
</Cards>
