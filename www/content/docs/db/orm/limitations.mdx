---
title: Limitations & Performance
description: Understand Better-Convex ORM limitations, workarounds, and performance characteristics
---

import { AlertTriangle } from "lucide-react"

Better-Convex mirrors Drizzle v1’s relational query builder on top of Convex’s document database. That means a few SQL-only features do not apply, and some features are implemented post-fetch for API parity.

## Not Available In Convex

These Drizzle features are SQL-specific and do not map to Convex:

- SQL joins
- SQL subqueries and operators that depend on them (`exists`, `notExists`)
- ORM query-builder aggregations (`count`, `sum`, `avg`, `max`, `min`) should use Convex aggregate components
- Raw SQL execution
- RQB SQL-only features: `RAW` filters and SQL placeholders in `where`/`limit`/`offset` are not supported at runtime
- Database migrations and database-side constraints/triggers
- Custom SQL data types

Use relation filters for Convex-style existence checks:

```ts showLineNumbers
// Has at least one related post
await db.query.users.findMany({
  where: { posts: true },
});

// Has no related posts
await db.query.users.findMany({
  where: { NOT: { posts: true } },
});
```

For aggregation use cases today, use the Convex aggregate component:
- `@convex-dev/aggregate`
- Guide: [/docs/db/aggregates](/docs/db/aggregates)

## Post-Fetch Behavior

These features keep Drizzle’s API shape but run after data is fetched:

**Column selection**
```ts showLineNumbers
const users = await db.query.users.findMany({
  columns: { name: true, email: true },
});
```

**String operators**
```ts showLineNumbers
const users = await db.query.users.findMany({
  where: { email: { ilike: '%@example.com' } },
});
```

**Extras (computed fields)**
```ts showLineNumbers
const users = await db.query.users.findMany({
  extras: {
    emailDomain: (row) => row.email.split('@')[1]!,
  },
});
```

**Relation filters on `many()`**
```ts showLineNumbers
const users = await db.query.users.findMany({
  with: {
    posts: {
      where: { published: true },
      orderBy: { _creationTime: 'desc' },
      limit: 5,
    },
  },
});
```

## Indexes And Ordering

- `findMany({ paginate })` relies on the first `orderBy` field for cursor ordering
- Sorting without an index falls back to `_creationTime` ordering
- Post-fetch sorting (multi-field or non-indexable orderBy) sorts before `offset`/`limit`, so Better-Convex must read the full filtered candidate set first
- For these post-fetch sort paths, size non-paginated queries intentionally (`limit`, schema `defaultLimit`, or `allowFullScan: true`)
- Compound index planning follows prefix validity. Non-leading-only predicates (for example `numLikes` on `[type, numLikes]`) are treated as non-indexable and require `allowFullScan: true`
- Add `index('...').on(t.field)` on fields used for filter or sort

```ts showLineNumbers
const posts = convexTable(
  'posts',
  {
    title: text().notNull(),
    numLikes: integer().notNull(),
  },
  (t) => [index('by_likes').on(t.numLikes)]
);
```

## Constraints And Defaults

- Unique, foreign keys, and `check()` constraints are enforced only through Better‑Convex ORM mutations
- Foreign key actions require an index on the referencing columns
- Relation loading requires indexes on relation fields (missing indexes throw unless `allowFullScan: true`)
- Relation loading fail-fasts when unique relation lookup keys exceed `defaults.relationFanOutMaxKeys` (default `1000`) unless `allowFullScan: true`
- Non-paginated `findMany()` must be explicitly sized (`limit`, `paginate`, schema `defaultLimit`, or `allowFullScan: true`)
- `many()` relation loading must be explicitly sized per parent (`with.<relation>.limit`, schema `defaultLimit`, or `allowFullScan: true`)
- System tables (`_storage`, `_scheduled_functions`) are accessed via raw `db.system.get/query`, not `db.query.<table>.findMany()`
- Predicate `where` requires explicit `index: { name, range? }` and runs post‑fetch via stream filtering
- Search mode (`findMany({ search })`) is relevance-ordered; `orderBy` is not supported
- Search mode supports base-table object `where`, but not predicate `where` or relation-based `where`
- Vector mode (`findMany({ vectorSearch })`) does not support `paginate`, `where`, `orderBy`, `index`, or `offset`
- Update/delete without `where()` throws unless `allowFullScan: true`
- Update/delete matched rows are capped by `mutationMaxRows` (default `1000`) and collected in `mutationBatchSize` pages (default `100`)
- Async FK fan-out uses `mutationLeafBatchSize` for non-recursive actions (default `900`)
- Async FK fan-out enforces measured-byte budget `mutationMaxBytesPerBatch` (default `2_097_152`)
- Async FK fan-out enforces schedule-call cap `mutationScheduleCallCap` (default `100`)
- For large update/delete workloads, use builder-level `paginate({ cursor, numItems })` to process one mutation page at a time
- Async execution (`execute({ mode: 'async', batchSize?, delayMs? })` or `.executeAsync(...)`) runs the first update/delete batch inline and schedules remaining batches
- Async execution also applies to FK/cascade fan-out paths; large fan-out is paged and continued via scheduler instead of volume-fail-fast
- FK cascade fan-out is system-driven after root-row authorization; child-table RLS policies are not re-evaluated during fan-out
- Explicit async APIs (`execute({ mode: 'async' })` / `.executeAsync(...)`) are incompatible with builder-level `paginate(...)`; use one strategy per call
- Async execution is incompatible with resolved scheduled delete mode (`.scheduled(...)` or table-level `deletion('scheduled')`)
- Paged update/delete currently does not support multi-probe filter plans (`inArray`, some `OR`, complement ranges)
- Check constraints follow SQL-like NULL semantics: the check fails only when the expression is `false` (and passes on `unknown`)
- Defaults are applied only by Better‑Convex ORM inserts/updates (`.default(...)`, `$defaultFn(...)`, `$onUpdateFn(...)`)
- Direct `ctx.db` writes bypass all ORM enforcement

**Default policy**
- Query sizing has no implicit fallback (no hidden row default unless you set `defaults.defaultLimit`).
- Relation fan-out guardrails default to `relationFanOutMaxKeys=1000`.
- Mutation safety has built-in guardrail defaults (`mutationBatchSize=100`, `mutationMaxRows=1000`).
- Async fan-out defaults: `mutationLeafBatchSize=900`, `mutationMaxBytesPerBatch=2_097_152`, `mutationScheduleCallCap=100`.
- Non-paginated mutation mode defaults to sync (`defaults.mutationExecutionMode='sync'`) unless configured otherwise.

<Callout icon={<AlertTriangle />}>
**Uniqueness under concurrency**: runtime uniqueness checks are best‑effort within a mutation. Concurrent mutations can still race (including 1:1 relations).  
Recommended patterns:
- Use `onConflictDoNothing()` / `onConflictDoUpdate()` for idempotent writes
- Retry on conflict when appropriate
- Serialize writes per unique key in application logic when strict guarantees are required
</Callout>

## Soft & Scheduled Deletes

- Soft/scheduled deletes are **optional helpers** and not part of Drizzle v1
- Soft deletes require a `deletionTime` field in your table
- Table-level defaults are supported via `deletion('hard'|'soft'|'scheduled', options?)` in `convexTable(...)` extra config
- Per-query delete mode methods (`.hard()`, `.soft()`, `.scheduled(...)`) override table defaults
- Scheduled deletes require wiring `scheduler` + `scheduledDelete` when you build `ctx.orm`
- Async mutation batches require wiring `scheduler` + `scheduledMutationBatch` when you build `ctx.orm`

## Performance Guidance

- Index every field you filter or order by frequently
- Use search indexes for large text filtering
- Use vector indexes only for embedding search
- Prefer `findMany({ paginate })` for infinite scroll and large datasets
- Avoid deep offset pagination for large tables
- Use `with` to avoid N+1 queries

## Common Gotchas

| Issue | Cause | Fix |
|---|---|---|
| Slow ordering | Missing index | Add `index('...').on(t.field)` in schema |
| `findMany({ paginate })` order changes | No index on primary sort | Add index on first `orderBy` field |
| `findMany()` throws explicit sizing error | Non-paginated query has no `limit` and no schema `defaultLimit` | Add `limit`, use `paginate`, set `defaults.defaultLimit`, or opt in with `allowFullScan: true` |
| `like` or `ilike` is slow | Post-fetch filtering | Use search indexes |
| `vectorSearch` throws provider error | `createOrm(...).db(ctx)` was called without `vectorSearch` | Pass `vectorSearch: ctx.vectorSearch` when building ORM db |
| Relations not loading | Incomplete relation metadata | Define both relation sides or explicit `from`/`to` |
| `update()`/`delete()` exceeds row cap | Matched rows > `mutationMaxRows` | Narrow filters, increase `defaults.mutationMaxRows`, or switch to paged mutation execution |
| Paged update/delete throws multi-probe error | Filter compiles to multiple index probes | Rewrite filter to a single index range (or use non-paged mode with row cap) |
| Missing defaults | Direct `ctx.db` bypasses ORM defaults | Use ORM inserts or set defaults in code |

## Schema Introspection

Better-Convex exposes Drizzle-style helpers for runtime schema metadata:

```ts showLineNumbers
import { getTableColumns, getTableConfig } from 'better-convex/orm';

const columns = getTableColumns(users); // includes _id/_creationTime
const config = getTableConfig(users);   // indexes/unique/fks/rls/checks
```

## Next Steps

<Cards>
  <Card title="Schema Definition" href="/docs/db/orm/schema">
    Define tables, relations, and indexes
  </Card>
  <Card title="Querying Data" href="/docs/db/orm/queries">
    Learn filters, ordering, and pagination
  </Card>
</Cards>
