---
title: Filters
description: Full-text search and complex query patterns.
links:
  doc: https://docs.convex.dev/text-search
---

import { InfoIcon } from "lucide-react"

In this guide, we'll explore advanced querying in Convex. You'll learn to implement full-text search with relevance scoring, use predicate `where` for complex filtering (with explicit index ranges), and combine multiple queries with UNION and JOIN patterns.

## Overview

Convex provides powerful querying capabilities beyond basic filtering:

| Feature | Description |
|---------|-------------|
| Full-text search | Search string fields with relevance scoring |
| Predicate filters | Complex filtering with explicit full‑scan opt‑in |
| UNION patterns | Combine multiple queries into one paginated result |
| JOIN patterns | Paginate through related documents |
| DISTINCT | Get unique values efficiently |

Let's explore each one.

<Callout icon={<InfoIcon />}>
**Note:** Better‑Convex ORM supports search via `findMany({ search: { index, query, filters? } })`. Predicate `where` still runs post‑fetch and cannot be combined with search mode.
</Callout>

## Full-Text Search

Full-text search enables searching string fields with relevance scoring. Each search index can search ONE field, with optional filter fields for equality filtering.

### Schema Definition

Let's start by adding search indexes to your schema. Use the naming pattern `search_<searchField>`:

```ts title="convex/functions/schema.ts" showLineNumbers {8-12,14-16}
import { convexTable, defineSchema, searchIndex, text } from 'better-convex/orm';

export const articles = convexTable(
  'articles',
  {
    title: text().notNull(),
    content: text().notNull(),
    author: text().notNull(),
    category: text().notNull(),
  },
  (t) => [
    // Search content with category/author as filter fields
    searchIndex('search_content').on(t.content).filter(t.category, t.author),
    // Separate index for title search
    searchIndex('search_title').on(t.title),
  ]
);

export const tables = { articles };
export default defineSchema(tables, { strict: false });
```

<Callout icon={<InfoIcon />}>
**Note:** Each search index can only search ONE field. Add `filterFields` for fast equality filtering before text search.
</Callout>

### Basic Search

Now let's implement a basic search query:

```ts title="convex/functions/articles.ts" showLineNumbers {7-11}
import { z } from 'zod';
import { zid } from 'convex-helpers/server/zod4';
import { publicQuery } from '../lib/crpc';

export const search = publicQuery
  .input(z.object({
    query: z.string(),
    limit: z.number().min(1).max(100).default(10),
  }))
  .output(z.array(z.object({
    _id: zid('articles'),
    title: z.string(),
    content: z.string(),
  })))
  .query(async ({ ctx, input }) => {
    return await ctx.orm.query.articles.findMany({
      search: {
        index: 'search_content',
        query: input.query,
      },
      limit: input.limit,
    });
  });
```

<Callout icon={<InfoIcon />}>
**Important:** Always use `limit` or cursor pagination (`cursor` + `limit`) with search queries to limit results.
</Callout>

### Search with Filters

Filter fields enable fast pre-filtering before text search. Only equality filters are supported:

```ts title="convex/functions/articles.ts" showLineNumbers {8-16}
export const searchByCategory = publicQuery
  .input(z.object({
    query: z.string(),
    category: z.string(),
    author: z.string().optional(),
  }))
  .output(z.array(z.object({
    _id: zid('articles'),
    title: z.string(),
    content: z.string(),
    category: z.string(),
  })))
  .query(async ({ ctx, input }) => {
    return await ctx.orm.query.articles.findMany({
      search: {
        index: 'search_content',
        query: input.query,
        filters: {
          category: input.category,
          ...(input.author ? { author: input.author } : {}),
        },
      },
      limit: 20,
    });
  });
```

### Paginated Search

Use `.paginated({ limit, item })` ([paginated builder](/docs/server/procedures#paginated-queries)) for cursor-based pagination:

```ts title="convex/functions/articles.ts" showLineNumbers {3,9-17}
const ArticleSchema = z.object({
  _id: zid('articles'),
  title: z.string(),
  content: z.string(),
  category: z.string(),
});

export const searchPaginated = publicQuery
  .input(z.object({
    query: z.string(),
    category: z.string().optional(),
  }))
  .paginated({ limit: 20, item: ArticleSchema })
  .query(async ({ ctx, input }) => {
    return await ctx.orm.query.articles.findMany({
      search: {
        index: 'search_content',
        query: input.query,
        filters: input.category ? { category: input.category } : undefined,
      },
      cursor: input.cursor,
      limit: input.limit,
    });
  });
```

<Callout icon={<InfoIcon />}>
**Tip:** Search results are automatically sorted by relevance.
</Callout>

## Predicate `where` (Explicit Index Required)

Use a predicate `where` for complex JS logic. You must provide an explicit index range with `index: { name, range? }`.

```ts title="convex/functions/characters.ts" showLineNumbers {6-8,13-18,21-24}
const CharacterSchema = z.object({
  _id: zid('characters'),
  name: z.string(),
  categories: z.array(z.string()).nullable(),
  score: z.number(),
});

export const searchCharacters = publicQuery
  .input(z.object({
    category: z.string().optional(),
    minScore: z.number().optional(),
  }))
  .paginated({ limit: 20, item: CharacterSchema })
  .query(async ({ ctx, input }) => {
    return await ctx.orm.query.characters.findMany({
      where: (char) => {
        if (input.category && !char.categories?.includes(input.category)) {
          return false;
        }
        if (input.minScore && char.score < input.minScore) {
          return false;
        }
        return true;
      },
      index: {
        name: 'private',
        range: (q) => q.eq('private', false),
      },
      cursor: input.cursor,
      limit: input.limit,
    });
  });
```

<Callout icon={<InfoIcon />}>
**Tip:** Prefer index‑friendly object `where` for most queries. Use predicate `where` only when you need complex JS logic and can anchor it to an explicit index range.
</Callout>

## Search vs Predicate `where`

Understanding when to use each approach is critical. Here's a comparison:

| Feature | Search | Predicate `where` |
|---------|--------|-------------------|
| Text matching | Full-text search with relevance | No text search |
| Complex filters | `filterFields` only (equality) | Full TypeScript |
| Range queries | No | Yes |
| Pagination | Standard | Works with cursor pagination (`cursor` + `limit`) |
| UNION/JOIN | No | Manual merge in app code |
| Performance | Optimized for text | Depends on chosen index + predicate selectivity |
| **Combined** | **Supported with base-field object `where`** | Predicate / relation `where` still unsupported |

### Choosing the Right Approach

1. **Need text search?** → Use search indexes
2. **Need complex filters with pagination?** → Use predicate `where` + explicit `index`
3. **Need range queries (greater than, less than)?** → Use predicate `where` + explicit `index`
4. **Need UNION or JOIN operations?** → Merge in application code
5. **Need text search + relation/predicate filters?** → See options below

### Combining Search and Complex Filters

Search mode supports `search.filters` plus base-table object `where`. For predicate `where` or relation-based `where`, use one of these patterns.

**Option 1: Add more filterFields** (recommended)

Add equality filters to your search index:

```ts showLineNumbers {2-3}
searchIndex('search_content')
  .on(t.content)
  .filter(t.category, t.author, t.status, t.dateGroup);
```

**Option 2: Separate query paths**

Use search when text is provided, predicate filtering otherwise:

```ts showLineNumbers {7-8,10-19,21-30}
export const searchOrFilter = publicQuery
  .input(z.object({
    query: z.string().optional(),
    category: z.string().optional(),
    startDate: z.number().optional(),
  }))
  .paginated({ limit: 20, item: ArticleSchema })
  .query(async ({ ctx, input }) => {
    const db = ctx.orm;
    if (input.query) {
      // Text search path - limited filtering
      return await db.query.articles.findMany({
        search: {
          index: 'search_content',
          query: input.query!,
          filters: input.category ? { category: input.category } : undefined,
        },
        cursor: input.cursor,
        limit: input.limit,
      });
    }

    // Predicate where path - full filtering power with explicit index
    return await db.query.articles.findMany({
      where: (article) => {
        if (input.category && article.category !== input.category) return false;
        if (input.startDate && article.publishedAt < input.startDate) return false;
        return true;
      },
      index: { name: 'by_creation_time' },
      cursor: input.cursor,
      limit: input.limit,
    });
  });
```

**Option 3: Post-process search results** (small datasets only)

```ts showLineNumbers {2-4,6-8}
// Only viable for small result sets
const searchResults = await ctx
  .orm.query.articles.findMany({
    search: { index: 'search_content', query },
    limit: 100, // Hard limit
  });

const filtered = searchResults.filter((article) =>
  article.publishedAt >= startDate && article.publishedAt <= endDate
);
```

## Performance Considerations

Understanding performance is critical for production apps.

### Search Performance

- Search indexes have overhead - don't over-index
- Use `filterFields` to narrow results before text matching
- Always limit results with `limit` or cursor pagination (`cursor` + `limit`)

### Predicate `where` Performance

Predicate `where` runs post‑fetch against an explicit index stream. Use `maxScan` to cap scan size:

```ts showLineNumbers {2-6}
const results = await db.query.posts.findMany({
  where: (post) => expensiveCheck(post),
  index: { name: 'by_created_at' },
  cursor: input.cursor,
  limit: input.limit,
  maxScan: 500,
});
```

<Callout icon={<InfoIcon />}>
**Warning:** Predicate filters can scan a large portion of a table. Keep page sizes small and use indexes when possible.
</Callout>

### Cursor Stability

Cursor pagination is only stable when you reuse the same `where` predicate and `orderBy`:

```ts showLineNumbers {1-6}
const page1 = await db.query.messages.findMany({
  where: (m) => m.read,
  index: { name: 'by_creation_time' },
  orderBy: { _creationTime: 'desc' },
  cursor: null,
  limit: 20,
});
```

### Memory Efficiency

- Prefer cursor pagination (`cursor` + `limit`) for user‑facing lists
- Keep limits small for non‑paginated queries
- Use selective index ranges for predicate `where` and cap reads with `maxScan`

## Best Practices

Here are key practices to follow when using filters and search.

1. **Create appropriate indexes** - Each search field needs its own search index
2. **Limit results** - Always use `limit` or cursor pagination (`cursor` + `limit`)
3. **Use filterFields** - Pre-filter with equality before text search
4. **Bound predicate scans** - Use explicit `index` and cap reads with `maxScan`
5. **Normalize search terms** - Consider lowercase for consistent matching
6. **Handle empty queries** - Decide behavior when search query is empty
7. **Prefer cursor pagination** - Use `findMany({ cursor: null, limit: 20 })` for large lists

## Next Steps

<Cards>
  <Card title="ORM" href="/docs/db/orm" />
  <Card title="Triggers" href="/docs/db/triggers" />
  <Card title="Aggregates" href="/docs/db/aggregates" />
  <Card title="convex-helpers" href="https://github.com/get-convex/convex-helpers" />
</Cards>
