---
title: Server Components
description: Use cRPC in RSCs with prefetching and hydration.
links:
  doc: https://tanstack.com/query/latest/docs/framework/react/guides/advanced-ssr
---

import { InfoIcon } from "lucide-react"

In this guide, we'll explore using cRPC in React Server Components. You'll learn non-blocking prefetch patterns, direct server calls with `caller`, awaited preloads for metadata, and how hydration bridges server and client.

## Overview

cRPC provides a server-compatible proxy for RSCs with **non-blocking prefetch** - a pattern not available in vanilla Convex:

| | Vanilla Convex | better-convex |
|-|----------------|---------------|
| Non-blocking prefetch | **Not available** | `prefetch()` |
| Direct server calls | `fetchQuery()` | `caller` |
| Awaited + hydrated | `preloadQuery()` | `preloadQuery()` |
| Prop drilling | Required | Not needed |
| Client hooks | `usePreloadedQuery(preloaded)` | Standard `useQuery()` |

better-convex provides three patterns:

| Pattern | Description |
|---------|-------------|
| `prefetch` | Fire-and-forget, non-blocking, hydrated to client |
| `caller` | Direct server calls, **not cached/hydrated** (like tRPC) |
| `preloadQuery` | Awaited, returns data + hydrates to client |

Let's explore each one.

## Basic Usage

Prefetch queries in Server Components and wrap client components with `HydrateClient`:

```tsx title="app/posts/page.tsx" showLineNumbers {4,6-8}
import { crpc, HydrateClient, prefetch } from '@/lib/convex/rsc';
import { PostList } from './post-list';

export default async function PostsPage() {
  // Prefetch data on server (fire-and-forget)
  prefetch(crpc.posts.list.queryOptions({}));

  return (
    <HydrateClient>
      <PostList />
    </HydrateClient>
  );
}
```

```tsx title="app/posts/post-list.tsx" showLineNumbers {5,8}
'use client';

import { useQuery } from '@tanstack/react-query';
import { crpc } from '@/lib/convex/client';

export function PostList() {
  // Instant data from server prefetch, then real-time updates
  const { data: posts } = useQuery(crpc.posts.list.queryOptions({}));

  return (
    <ul>
      {posts?.map((post) => (
        <li key={post._id}>{post.title}</li>
      ))}
    </ul>
  );
}
```

## Auth-Aware Prefetching

Use `skipUnauth` to prefetch queries that require authentication without blocking:

```tsx title="app/layout.tsx" showLineNumbers {7}
import { crpc, HydrateClient, prefetch } from '@/lib/convex/rsc';

export default async function AppLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  // Skip if not authenticated, don't error
  prefetch(crpc.user.getCurrentUser.queryOptions({}, { skipUnauth: true }));

  return <HydrateClient>{children}</HydrateClient>;
}
```

## Multiple Prefetches

Prefetch multiple queries in parallel:

```tsx title="app/dashboard/page.tsx" showLineNumbers {5-7}
import { crpc, HydrateClient, prefetch } from '@/lib/convex/rsc';

export default async function DashboardPage() {
  // All prefetch in parallel (fire-and-forget)
  prefetch(crpc.user.getCurrentUser.queryOptions({}, { skipUnauth: true }));
  prefetch(crpc.posts.list.queryOptions({}));
  prefetch(crpc.stats.dashboard.queryOptions({}));

  return (
    <HydrateClient>
      <Dashboard />
    </HydrateClient>
  );
}
```

## caller

Direct server calls - **detached from query client, not cached, not hydrated to client**. Like tRPC's `createCaller`, use when you only need server-side access.

```tsx title="app/admin/page.tsx" showLineNumbers {4,6-8}
import { caller } from '@/lib/convex/rsc';

export default async function AdminPage() {
  // Direct call - server only, not hydrated
  const user = await caller.user.getSessionUser({});

  if (!user?.isAdmin) {
    redirect('/');
  }

  // Continue with admin logic...
  return <AdminDashboard />;
}
```

### When to use caller

| Use Case | Description |
|----------|-------------|
| Server-side conditionals | Redirects, auth checks where data isn't needed on client |
| API routes and middleware | Server-only logic |
| Sensitive data | Data that shouldn't be exposed to client |

See [Server Side Calls](/docs/server/server-side-calls) for setup.

## preloadQuery

**Equivalent to Convex's `preloadQuery`** - awaited fetch that returns data on the server. Use when you need server-side access to the data:

```tsx title="app/posts/[id]/page.tsx" showLineNumbers {7,9-11}
import { crpc, HydrateClient, preloadQuery } from '@/lib/convex/rsc';

export default async function PostPage({
  params,
}: {
  params: Promise<{ id: string }>;
}) {
  const { id } = await params;

  // Await data - available on server
  const post = await preloadQuery(crpc.posts.get.queryOptions({ id }));

  if (!post) {
    notFound();
  }

  return (
    <HydrateClient>
      <h1>{post.title}</h1>
      <PostContent post={post} />
    </HydrateClient>
  );
}
```

### When to use preloadQuery

| Use Case | Description |
|----------|-------------|
| Server-side conditionals | 404 checks, redirects |
| Metadata generation | Generate page metadata from the data |
| Server rendering | Render data directly in Server Components |

### Metadata Generation

```tsx title="app/posts/[id]/page.tsx" showLineNumbers {6,8-12}
import { crpc, preloadQuery } from '@/lib/convex/rsc';

export async function generateMetadata({
  params,
}: {
  params: Promise<{ id: string }>;
}) {
  const { id } = await params;
  const post = await preloadQuery(crpc.posts.get.queryOptions({ id }));

  return {
    title: post?.title ?? 'Post Not Found',
    description: post?.excerpt,
  };
}
```

## Data Ownership and Revalidation

<Callout icon={<InfoIcon />}>
**Important:** From the TanStack Query perspective, treat Server Components as a place to prefetch data, nothing more.
</Callout>

When using `preloadQuery` (fetchQuery), be aware of data ownership:

```tsx showLineNumbers {2,6,8}
// AVOID: Rendering fetched data in both Server and Client components
export default async function PostsPage() {
  const posts = await preloadQuery(crpc.posts.list.queryOptions({}));

  return (
    <HydrateClient>
      {/* Server-rendered - React Query can't revalidate this */}
      <div>Nr of posts: {posts.length}</div>
      {/* Client-rendered - React Query CAN revalidate this */}
      <PostList />
    </HydrateClient>
  );
}
```

The problem: When React Query revalidates on the client, the `PostList` component updates but `Nr of posts: {posts.length}` stays stale - React Query has no way to revalidate the Server Component.

**Best practices:**

| Practice | Reason |
|----------|--------|
| Prefer `prefetch` | Let client components own the data |
| Use `preloadQuery` only when needed | For metadata, 404 checks, redirects |
| Don't render fetched data in Server Components | If client components also use it |
| If you must use both | Understand they can get out of sync after revalidation |

See [TanStack Query Advanced SSR Guide](https://tanstack.com/query/latest/docs/framework/react/guides/advanced-ssr#data-ownership-and-revalidation) for more details.

## Comparison

| Feature | `prefetch` | `caller` | `preloadQuery` |
|---------|------------|----------|----------------|
| Convex equivalent | **None** (new) | `fetchQuery` | `preloadQuery` |
| Blocking | No | Yes | Yes |
| Returns data | No (void) | Yes | Yes |
| Client hydration | Yes | **No** | Yes |
| Revalidation safe | Yes | N/A | Requires care |
| Use case | Client-only data | Server-only logic | Server + client data |

## How It Works

Let's understand how hydration bridges server and client.

`HydrateClient` dehydrates the prefetched queries so client components receive data instantly:

1. Server prefetches queries into the QueryClient
2. `HydrateClient` serializes the cache via `dehydrate()`
3. `HydrationBoundary` restores data on the client
4. Client components get instant data, then subscribe for real-time updates

### Query Key Matching

The server and client proxies generate identical query keys, ensuring prefetched data is found:

```ts showLineNumbers {2,6}
// Server (RSC)
crpc.posts.list.queryOptions({ limit: 10 });
// queryKey: ['convexQuery', funcRef, { limit: 10 }]

// Client (same key)
crpc.posts.list.queryOptions({ limit: 10 });
// queryKey: ['convexQuery', funcRef, { limit: 10 }]
```

## Important Notes

### HydrateClient Placement

`HydrateClient` must wrap all client components that use prefetched queries:

```tsx showLineNumbers {2-6}
// Correct - HydrateClient wraps client component
prefetch(crpc.posts.list.queryOptions({}));
return (
  <HydrateClient>
    <PostList />
  </HydrateClient>
);
```

```tsx showLineNumbers {2-8}
// Wrong - PostList renders before hydration
return (
  <>
    <PostList />
    <HydrateClient>
      <OtherComponent />
    </HydrateClient>
  </>
);
```

## Migrate from Convex

If you're coming from vanilla Convex, here's what changes.

### What stays the same

- Server-side data fetching
- Server-side preloading via `preloadQuery`

### What's new

<Compare>
  <CompareItem title="Before (vanilla Convex)">
    ```tsx showLineNumbers {1-3,6-7,12-13}
    import { preloadQuery } from 'convex/nextjs';
    import { api } from '@convex/_generated/api';
    import { Preloaded, usePreloadedQuery } from 'convex/react';

    // Server Component
    export default async function Page() {
      const preloaded = await preloadQuery(api.posts.list);
      return <PostList preloadedPosts={preloaded} />;
    }

    // Client Component
    function PostList({ preloadedPosts }: { preloadedPosts: Preloaded<typeof api.posts.list> }) {
      const posts = usePreloadedQuery(preloadedPosts);
      return /* ... */;
    }
    ```
  </CompareItem>
  <CompareItem title="After (cRPC)">
    ```tsx showLineNumbers {1,4-5,7-9,14-15}
    import { crpc, HydrateClient, prefetch } from '@/lib/convex/rsc';

    // Server Component
    export default async function Page() {
      prefetch(crpc.posts.list.queryOptions({}));
      return (
        <HydrateClient>
          <PostList />
        </HydrateClient>
      );
    }

    // Client Component
    function PostList() {
      const { data: posts } = useQuery(crpc.posts.list.queryOptions({}));
      return /* ... */;
    }
    ```
  </CompareItem>
</Compare>

**Key differences:**

| Feature | Description |
|---------|-------------|
| No prop drilling | Preloaded data doesn't need to be passed as props |
| Standard hooks | Client components use standard `useQuery` hooks |
| Non-blocking | `prefetch` is fire-and-forget |
| Same options | Same query options as client-side code |
| Automatic hydration | Via `HydrateClient` |
| Auth configured once | Via `getToken` in QueryClient options |

## Next Steps

<Cards>
  <Card title="Setup" href="/docs/nextjs" />
  <Card title="HTTP Router" href="/docs/server/http" />
  <Card title="Auth Server" href="/docs/auth/server" />
</Cards>
