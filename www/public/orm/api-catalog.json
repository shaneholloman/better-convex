{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "version": "1.0.0-m6",
  "description": "ORM API Catalog (M1-M6) - Schema definition with column builders, relations, query operations, filtering, and mutations",
  "lastUpdated": "2026-02-02",
  "status": "Implemented: schema with column builders, relations definition, queries, filtering, mutations. Coming Phase 4: relation loading (with:)",

  "schema": {
    "convexTable": {
      "signature": "convexTable<TName extends string, TFields>(name: TName, fields: TFields): ConvexTable<TName, TFields>",
      "description": "Define a Convex table with Drizzle-style API",
      "parameters": {
        "name": "Table name (string)",
        "fields": "Object mapping field names to column builders (text(), integer(), etc.)"
      },
      "returns": "ConvexTable instance with full type inference",
      "example": "const users = convexTable('users', { name: text().notNull(), email: text().notNull() });",
      "docUrl": "/docs/db/orm/schema#table-definition",
      "category": "schema"
    },
    "relations": {
      "signature": "relations<TTable>(table: TTable, callback: (helpers: RelationHelpers) => Relations): TableRelations<TTable>",
      "description": "Define relations between tables (identical to Drizzle)",
      "parameters": {
        "table": "The table to define relations for",
        "callback": "Function receiving { one, many } helpers"
      },
      "returns": "Table relations configuration",
      "example": "const usersRelations = relations(users, ({ many }) => ({ posts: many(posts) }));",
      "docUrl": "/docs/db/orm/schema#relations",
      "category": "schema"
    }
  },

  "queries": {
    "findMany": {
      "signature": "db(ctx).query.tableName.findMany(options?: FindManyOptions): Promise<Array<TableRecord<T>>>",
      "description": "Query multiple records with filtering and pagination (M1-M4)",
      "parameters": {
        "where": "Filter condition using operators (eq, ne, gt, etc.)",
        "vectorSearch": "Vector similarity config: { index, vector, limit, filter? }",
        "limit": "Maximum number of records to return",
        "offset": "Number of records to skip"
      },
      "comingSoon": {
        "with": "Relation loading (M5)",
        "orderBy": "Sort order (M5)"
      },
      "returns": "Promise resolving to array of records with inferred types",
      "example": "const users = await db(ctx).query.users.findMany({ where: eq(users.role, 'admin'), limit: 10 });",
      "docUrl": "/docs/db/orm/queries#findmany",
      "category": "queries"
    },
    "findFirst": {
      "signature": "db(ctx).query.tableName.findFirst(options?: FindFirstOptions): Promise<TableRecord<T> | null>",
      "description": "Query first matching record (M1-M4)",
      "parameters": {
        "where": "Filter condition"
      },
      "comingSoon": {
        "with": "Relations loading (M5)",
        "orderBy": "Sort order (M5)"
      },
      "returns": "Promise resolving to first record or null",
      "example": "const user = await db(ctx).query.users.findFirst({ where: eq(users.email, 'alice@example.com') });",
      "docUrl": "/docs/db/orm/queries#findfirst",
      "category": "queries"
    },
    "vectorSearch": {
      "signature": "db(ctx).query.tableName.findMany({ vectorSearch: { index, vector, limit, filter? }, with?, columns?, extras? }): Promise<Array<TableRecord<T>>>",
      "description": "Vector similarity search in findMany mode (ordered by similarity)",
      "parameters": {
        "index": "Vector index name on the target table",
        "vector": "Embedding vector to query against",
        "limit": "Required result cap (1..256)",
        "filter": "Optional vector filter callback using vector index filterFields"
      },
      "constraints": [
        "Cannot be combined with orderBy",
        "Cannot be combined with cursor pagination",
        "Cannot be combined with where",
        "Cannot be combined with index or offset"
      ],
      "returns": "Promise resolving to rows in similarity order",
      "example": "const rows = await db(ctx).query.posts.findMany({ vectorSearch: { index: 'embedding_vec', vector: args.embedding, limit: 10, filter: (q) => q.eq('type', 'news') } });",
      "docUrl": "/docs/db/orm/queries#vector-search",
      "category": "queries"
    },
    "where": {
      "signature": "where(condition: FilterCondition)",
      "description": "Filter query results using operators",
      "parameters": {
        "condition": "Filter condition created with eq(), and(), or(), etc."
      },
      "returns": "Filtered query",
      "example": "{ where: and(eq(users.role, 'admin'), gt(users.age, 18)) }",
      "docUrl": "/docs/db/orm/queries#filtering-with-where",
      "category": "queries"
    },
    "with": {
      "status": "NOT_IMPLEMENTED",
      "comingSoon": "M5",
      "signature": "with(relations: RelationsConfig)",
      "description": "Load related records - Coming in M5 (not yet implemented)",
      "parameters": {
        "relations": "Object mapping relation names to true or options"
      },
      "workaround": "Use native Convex queries to load related data manually",
      "example": "// NOT YET IMPLEMENTED - Use native Convex queries for now",
      "docUrl": "/docs/db/orm/queries",
      "category": "queries"
    }
  },

  "mutations": {
    "insert": {
      "status": "NOT_IMPLEMENTED",
      "comingSoon": "M5-M6",
      "signature": "db(ctx).insert.tableName.values(data: InsertData | InsertData[]): Promise<Id<TableName> | Id<TableName>[]>",
      "description": "Insert one or more records - Planned for M5-M6 (not yet implemented)",
      "parameters": {
        "data": "Single object or array of objects to insert"
      },
      "returns": "Promise resolving to inserted record ID(s)",
      "workaround": "Use ctx.db.insert('tableName', data) for now",
      "example": "// NOT YET IMPLEMENTED - Use ctx.db.insert() for now",
      "docUrl": "/docs/db/orm/mutations",
      "category": "mutations"
    },
    "update": {
      "status": "NOT_IMPLEMENTED",
      "comingSoon": "M5-M6",
      "signature": "db(ctx).update.tableName.set(data: PartialData).where(condition: FilterCondition): Promise<void>",
      "description": "Update records matching condition - Planned for M5-M6 (not yet implemented)",
      "parameters": {
        "data": "Partial object with fields to update",
        "condition": "Filter condition (required)"
      },
      "returns": "Promise resolving when update complete",
      "workaround": "Use ctx.db.patch(id, data) for now",
      "example": "// NOT YET IMPLEMENTED - Use ctx.db.patch() for now",
      "docUrl": "/docs/db/orm/mutations",
      "category": "mutations"
    },
    "delete": {
      "status": "NOT_IMPLEMENTED",
      "comingSoon": "M5-M6",
      "signature": "db(ctx).delete.tableName.where(condition: FilterCondition): Promise<void>",
      "description": "Delete records matching condition - Planned for M5-M6 (not yet implemented)",
      "parameters": {
        "condition": "Filter condition (required)"
      },
      "returns": "Promise resolving when delete complete",
      "workaround": "Use ctx.db.delete(id) for now",
      "example": "await db(ctx).delete.users.where(eq(users._id, userId));",
      "docUrl": "/docs/db/orm/mutations#delete",
      "category": "mutations"
    }
  },

  "operators": {
    "eq": {
      "signature": "eq<T>(field: Field<T>, value: T): FilterCondition",
      "description": "Equal to operator",
      "example": "eq(users.role, 'admin')",
      "docUrl": "/docs/db/orm/queries#available-operators",
      "category": "operators"
    },
    "ne": {
      "signature": "ne<T>(field: Field<T>, value: T): FilterCondition",
      "description": "Not equal to operator",
      "example": "ne(users.status, 'banned')",
      "docUrl": "/docs/db/orm/queries#available-operators",
      "category": "operators"
    },
    "gt": {
      "signature": "gt<T>(field: Field<T>, value: T): FilterCondition",
      "description": "Greater than operator",
      "example": "gt(users.age, 18)",
      "docUrl": "/docs/db/orm/queries#available-operators",
      "category": "operators"
    },
    "gte": {
      "signature": "gte<T>(field: Field<T>, value: T): FilterCondition",
      "description": "Greater than or equal operator",
      "example": "gte(users.credits, 100)",
      "docUrl": "/docs/db/orm/queries#available-operators",
      "category": "operators"
    },
    "lt": {
      "signature": "lt<T>(field: Field<T>, value: T): FilterCondition",
      "description": "Less than operator",
      "example": "lt(users.age, 65)",
      "docUrl": "/docs/db/orm/queries#available-operators",
      "category": "operators"
    },
    "lte": {
      "signature": "lte<T>(field: Field<T>, value: T): FilterCondition",
      "description": "Less than or equal operator",
      "example": "lte(users.loginCount, 10)",
      "docUrl": "/docs/db/orm/queries#available-operators",
      "category": "operators"
    },
    "and": {
      "signature": "and(...conditions: FilterCondition[]): FilterCondition",
      "description": "Logical AND operator",
      "example": "and(eq(users.role, 'admin'), gt(users.age, 18))",
      "docUrl": "/docs/db/orm/queries#available-operators",
      "category": "operators"
    },
    "or": {
      "signature": "or(...conditions: FilterCondition[]): FilterCondition",
      "description": "Logical OR operator",
      "example": "or(eq(users.role, 'admin'), eq(users.role, 'moderator'))",
      "docUrl": "/docs/db/orm/queries#available-operators",
      "category": "operators"
    },
    "not": {
      "signature": "not(condition: FilterCondition): FilterCondition",
      "description": "Logical NOT operator",
      "example": "not(eq(users.banned, true))",
      "docUrl": "/docs/db/orm/queries#available-operators",
      "category": "operators"
    },
    "isNull": {
      "signature": "isNull(field: Field): FilterCondition",
      "description": "Check if field is undefined/null",
      "example": "isNull(users.deletedAt)",
      "docUrl": "/docs/db/orm/queries#available-operators",
      "category": "operators"
    },
    "isNotNull": {
      "signature": "isNotNull(field: Field): FilterCondition",
      "description": "Check if field is not undefined/null",
      "example": "isNotNull(users.email)",
      "docUrl": "/docs/db/orm/queries#available-operators",
      "category": "operators"
    }
  },

  "relations": {
    "one": {
      "signature": "one<TTarget>(target: TTarget, config: RelationConfig): OneRelation<TTarget>",
      "description": "Define one-to-one or many-to-one relation",
      "parameters": {
        "target": "Target table",
        "config": "{ fields: [...], references: [...] }"
      },
      "example": "one(users, { fields: [posts.userId], references: [users._id] })",
      "docUrl": "/docs/db/orm/relations-deep-dive#one-to-one-relations",
      "category": "relations"
    },
    "many": {
      "signature": "many<TTarget>(target: TTarget): ManyRelation<TTarget>",
      "description": "Define one-to-many relation",
      "parameters": {
        "target": "Target table"
      },
      "example": "many(posts)",
      "docUrl": "/docs/db/orm/relations-deep-dive#one-to-many-relations",
      "category": "relations"
    },
    "nestedLoading": {
      "signature": "{ with: { relation: { with: { nestedRelation: true } } } }",
      "description": "Load nested relations up to 3 levels deep",
      "example": "{ with: { posts: { with: { comments: { with: { author: true } } } } } }",
      "docUrl": "/docs/db/orm/relations-deep-dive#nested-loading",
      "category": "relations"
    },
    "selfReferencing": {
      "signature": "one(sameTable, { fields: [...], references: [...] })",
      "description": "Self-referencing relations (e.g., parent/child)",
      "example": "one(categories, { fields: [categories.parentId], references: [categories._id] })",
      "docUrl": "/docs/db/orm/relations-deep-dive#self-referencing-relations",
      "category": "relations"
    },
    "manyToMany": {
      "signature": "Junction table pattern with two many() relations",
      "description": "Many-to-many using junction table",
      "example": "const userGroups = convexTable('user_groups', { userId: v.id('users'), groupId: v.id('groups') });",
      "docUrl": "/docs/db/orm/relations-deep-dive#many-to-many-relations",
      "category": "relations"
    }
  },

  "ordering": {
    "orderBy": {
      "signature": "orderBy(field: Field | Field[])",
      "description": "Sort query results by one or more fields",
      "parameters": {
        "field": "Single field or array of fields with asc/desc"
      },
      "example": "{ orderBy: [desc(users._creationTime), asc(users.name)] }",
      "docUrl": "/docs/db/orm/ordering-pagination#basic-ordering",
      "category": "ordering"
    },
    "asc": {
      "signature": "asc(field: Field): SortOrder",
      "description": "Ascending sort order",
      "example": "asc(users.name)",
      "docUrl": "/docs/db/orm/ordering-pagination#basic-ordering",
      "category": "ordering"
    },
    "desc": {
      "signature": "desc(field: Field): SortOrder",
      "description": "Descending sort order",
      "example": "desc(users._creationTime)",
      "docUrl": "/docs/db/orm/ordering-pagination#basic-ordering",
      "category": "ordering"
    }
  },

  "pagination": {
    "paginate": {
      "signature": "db(ctx).query.tableName.findMany({ cursor, limit, ... }): Promise<PaginationResult>",
      "description": "Cursor-based pagination via findMany",
      "parameters": {
        "cursor": "Cursor from previous page or null",
        "limit": "Number of items per page",
        "where": "Optional filter condition",
        "with": "Optional relations to load",
        "orderBy": "Optional sort order"
      },
      "returns": "{ page: T[], continueCursor: string | null, isDone: boolean }",
      "example": "const result = await db(ctx).query.users.findMany({ cursor: args.cursor ?? null, limit: 20 });",
      "docUrl": "/docs/db/orm/pagination#cursor-based-pagination",
      "category": "pagination"
    },
    "offset": {
      "signature": "{ offset: number, limit: number }",
      "description": "Offset-based pagination (O(n+offset) performance)",
      "parameters": {
        "offset": "Number of records to skip",
        "limit": "Maximum records to return"
      },
      "example": "{ offset: page * 20, limit: 20 }",
      "docUrl": "/docs/db/orm/pagination#offset-pagination",
      "category": "pagination"
    },
    "limit": {
      "signature": "{ limit: number }",
      "description": "Limit number of results (renamed from Drizzle's 'take')",
      "example": "{ limit: 10 }",
      "docUrl": "/docs/db/orm/pagination#offset-pagination",
      "category": "pagination"
    }
  },

  "typeInference": {
    "$inferSelect": {
      "signature": "typeof table.$inferSelect",
      "description": "Infer TypeScript type for selected records",
      "example": "type User = typeof users.$inferSelect;",
      "docUrl": "/docs/db/orm/type-safety#type-extraction",
      "category": "types"
    },
    "$inferInsert": {
      "signature": "typeof table.$inferInsert",
      "description": "Infer TypeScript type for insert operations",
      "example": "type NewUser = typeof users.$inferInsert;",
      "docUrl": "/docs/db/orm/type-safety#type-extraction",
      "category": "types"
    },
    "InferSelectModel": {
      "signature": "type InferSelectModel<T extends Table>",
      "description": "Extract select type from table (utility type)",
      "example": "type User = InferSelectModel<typeof users>;",
      "docUrl": "/docs/db/orm/type-safety#type-extraction",
      "category": "types"
    },
    "InferInsertModel": {
      "signature": "type InferInsertModel<T extends Table>",
      "description": "Extract insert type from table (utility type)",
      "example": "type NewUser = InferInsertModel<typeof users>;",
      "docUrl": "/docs/db/orm/type-safety#type-extraction",
      "category": "types"
    },
    "QueryResult": {
      "signature": "type QueryResult<T> = Awaited<ReturnType<T>>",
      "description": "Extract type from query function return",
      "example": "type UsersResult = QueryResult<typeof getUsersWithPosts>;",
      "docUrl": "/docs/db/orm/type-safety#generic-helper-types",
      "category": "types"
    },
    "TypeNarrowing": {
      "signature": "Automatic type narrowing from filters",
      "description": "TypeScript narrows types based on where clauses",
      "example": "where: eq(users.role, 'admin') narrows role to literal 'admin'",
      "docUrl": "/docs/db/orm/type-safety#type-narrowing-from-filters",
      "category": "types"
    }
  },

  "metadata": {
    "compatibility": {
      "drizzle": "90%+ API compatible",
      "categories": [
        "Category 1: 100% Compatible - Core queries, relations, mutations, ordering",
        "Category 2: Limited/Workaround - Column selection, LIKE operators",
        "Category 3: Convex Advantages - Real-time, edge relations, cursor pagination (O(log n))",
        "Category 4: Not Applicable - Raw SQL, migrations, connection pooling"
      ]
    },
    "performance": {
      "cursorPagination": "O(log n) - constant time regardless of page depth",
      "offsetPagination": "O(n + offset) - scales with offset",
      "relations": "Edge-based, no JOINs, automatic N+1 prevention with 'with'",
      "realTime": "Built-in subscriptions with no additional setup"
    },
    "resources": {
      "docs": "/docs/db/orm",
      "quickstart": "/docs/quickstart#orm-setup",
      "migration": {
        "fromDrizzle": "/docs/db/orm/from-drizzle",
        "fromPrisma": "/docs/db/orm/from-prisma",
        "fromEnts": "/docs/db/orm/from-ents"
      },
      "advanced": {
        "relations": "/docs/db/orm/relations-deep-dive",
        "orderingPagination": "/docs/db/orm/ordering-pagination",
        "typeSafety": "/docs/db/orm/type-safety"
      },
      "agentNative": {
        "llmsIndex": "/docs/db/orm/llms-index.md",
        "errorCatalog": "/orm/error-catalog.json",
        "apiCatalog": "/orm/api-catalog.json",
        "examplesRegistry": "/orm/examples-registry.json"
      }
    }
  }
}
